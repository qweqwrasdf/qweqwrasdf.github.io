1
2
Аннотация:
Внедрение зависимостей позволяет уменьшить сильное связывание между программнымомпонентами. Вместо жесткого кодирования зависимостей (например, драйвера какой-
либо базы данных), внедряется список сервисов, в которых может нуждаться компонент.
После этого сервисы подключаются третьей стороной. Такой подход обеспечивает лучшеправление будущими изменениями и решение проблем в разрабатываемом программнобеспечении. Данная книга рассказывает о внедрении зависимостей и являетсрактическим руководством по их применению в приложениях .NET. Издание содержисновные шаблоны внедрения зависимостей, написанные на «чистом» C#. Кроме тогоассмотрены способы интеграции внедрений зависимостей со стандартнымехнологиями Microsoft, такими как ASP.NET MVC, а также примеры применениреймворков StructureMap, Castle Windsor и Unity.
3
Книга "Внедрение зависимостей в .NET" демонстрирует основные DI паттерны нбычном языке C#, поэтому вы в полной мере осознаете, как работает механизнедрения зависимостей, кроме того она охватывает интеграцию с такими стандартнымехнологиями компании Microsoft, как ASP.NET MVC, и учит вас, как использовать такие
DI фреймворки, как Structure Map, Castle Windsor и Unity.
Внедрение зависимостей – это прекрасный способ уменьшить сильное связывание междомпонентами программного обеспечения. Вместо жесткого кодирования зависимостейапример, указания драйвера базы данных, вы внедряете перечень сервисов, которыогут понадобиться компоненту. Затем сервисы соединяются при помощи стороннегомпонента. Эта методика позволяет вам лучшим образом справляться с будущимзменениями и другими возникающими в вашем программном обеспечении сложностями.
Книга "Внедрение зависимостей в .NET" знакомит вас с механизмом внедрениависимостей и предоставляет практическое руководство по применению этого механизма
.NET приложениях. Книга демонстрирует основные паттерны на обычном языке C#оэтому вы в полной мере поймете, как работает механизм внедрения зависимостей.
Далее вы научитесь интегрировать DI с такими стандартными технологиями компании
Microsoft, как ASP.NET MVC, и использовать такие DI фреймворки, как Structure Map,
Castle Windsor и Unity. К концу книги вы будете свободно применять эту мощнуетодику в рамках повседневной разработки .NET приложений.
Эта книга написана для разработчиков на языке C#. Не требуется никакогервоначального опыта работы с механизмом внедрения зависимостей или DI
фреймворками.
Что внутри:
? Множество примеров на языке C#
? Каталог DI паттернов и анти-паттернов
? Примеры использования как фреймворков компании Microsoft, так и DI
фреймворков с открытым исходным кодом
Появление механизма внедрения зависимостей
Каталог DI
DI самостоятельно
DI-контейнеры
4
Появление механизма внедрениависимостей
Механизм внедрения зависимостей (Dependency Injection или DI) принадлежит к спискамых неправильно воспринимаемых концепций объектно-ориентированногрограммирования. Эта путаница широко распространена и касается терминологии, целе механики. Должен ли этот механизм называться внедрением зависимостей, инверсиеправления (Inversion of Control) или даже сторонним подключением (T hird-Party
Connect)? Является ли целью DI всего лишь поддержка модульного тестирования или жмеется более широкая цель? DI – это тоже самое, что и Service Locator? Нужен ли DI-
контейнер?
Существует множество публикаций блогов, журнальных статей, конференционнырезентаций и т.д., в которых обсуждается механизм DI, но, к несчастью, во многих иих используется противоречивая терминология и даются неправильные советы. Этправедливо и за рамками указанных источников, и даже такие крупные и влиятельныеятели, как компания Microsoft, тоже вовлечены в эту путаницу.
Дело не должно обстоять таким образом. В этой книге я представляю и используепротиворечивую терминологию, которую, я надеюсь, примут и другие. В большинствлучаев я принимал и разъяснял существующую терминологию, определенную другимио временами я добавлял некоторую терминологию, которая ранее не существовала. Этрезвычайно помогло мне в выделении спецификаций области применения и границ DI.
Одной из основных причин противоречивости и неправильных советов является тот фактто границы DI довольны нечеткие. Где заканчивается DI и начинаются другие концепцибъектно-ориентированного программирования? Думаю, невозможно провестазграничительную линию между DI и другими аспектами написания качественногбъектно-ориентированного кода. При обсуждении DI нам приходится вовлекаться ругие концепции такие, как SOLID и Clean Code. Не думаю, что я могу достовернисать о механизме DI, не затрагивая при этом некоторых из этих других тематик.
Первая часть книги поможет вам осознать позицию DI по отношению к другим аспектаазработки программного обеспечения – заявляя, таким образом, о нем на всеуслышание.
Первая глава предоставляет вам быстрый обзор DI, охватывая его цели, принципы реимущества, а также предоставляя набросок области ее применения для остальноасти книги. Если вы хотите узнать, что такое DI и почему этот механизм должен вааинтересовать, то это как раз то, с чего вам следует начать. Содержание главредполагает, что у вас нет никаких первичных познаний DI, но даже если вы уже знали ей, вы все еще можете иметь желание прочитать ее – может оказаться, что ее содержанитлично от того, что вы ожидали.
Первая глава сфокусирована на общей картине представления и не вдается в детали. Глава
2, с другой стороны, всецело зарезервирована под крупный пример. Подразумевается, чттот пример даст вам намного больше конкретного понимания DI. Он разделен на двасти и сформирован практически в виде комментария. Для того чтобы противопоставить
DI другим "традиционным" стилям программирования, глава сначала демонстрируеипичную, сильно связанную реализацию шаблонного приложения, а впоследствии зановеализует его с помощью DI.
5
Третья и конечная глава части 1 вводит понятие DI-контейнера и объясняет, как онписывается в общую картину представления DI. Я обсуждаю DI в общих понятиях иесмотря на то, что я предоставляю примеры кода, которые демонстрируют, как работаеипичный DI-контейнер, целью главы не является объяснение деталей конкретного API.
Главная цель главы 3 – показать, что DI-контейнер является довольно полезнымеобязательным инструментом. Вполне допустимо использовать DI без использования DI-
контейнера, поэтому части 2 и 3 более или менее игнорируют DI-контейнеры и вместтого обсуждают DI, не затрагивая контейнеры. Далее в части 4 мы возвращаемся онятию DI-контейнера с целью анализа четырех конкретных контейнеров.
Часть 1 определяет контекст всей остальной книги. Она нацелена на читателей, которые имеют первичных познаний DI, но опытные специалисты, использующие DI, могуакже приобрести полезные знания, просматривая главы с целью получить пониманиерминологии, используемой в рамках всей книги. К концу части 1 вы должнриобрести прочное понимание словаря и общих понятий, даже если некоторыонкретные детали все еще слегка расплывчаты. Ничего страшного – книга становитсолее конкретной на протяжении ее чтения, поэтому части 2, 3 и 4 должны будут ответита вопросы, которые, скорее всего, появятся у вас после прочтения части 1.
1. "Дегустационное меню" механизма внедрения зависимостей
2. Комплексный пример
3. DI-контейнеры
6
1. "Дегустационное меню" механизмнедрения зависимостей
Меню:
? Неправильное понимание механизма внедрения зависимостей
? Цель механизма внедрения зависимостей
? Преимущества механизма внедрения зависимостей
? Когда необходимо применять механизм внедрения зависимостей
Вы могли слышать о том, что процесс приготовления беарнского соуса (sauce bearnaise)
достаточно сложен. Даже большинство из тех людей, которые регулярно занимаютсриготовлением пищи, никогда не пытались его приготовить. Это позорно, посколькоус очень вкусный (его традиционно подают вместе с бифштексом, но он также отличночетается с белой спаржей, яйцами-пашот и другими блюдами). Некоторые прибегают аким его заменителям, как готовые соусы или растворимые смеси, но нет ничего болеосхитительного истинного беарнского соуса.
О пределение.
Беарнский соус – это эмульсионный соус, приготовленный из яичного желтка и масла риправленный эстрагоном, кервелем, луком-шалотом и уксусом. Этот соус не содержиоды.
Самой большой проблемой при приготовлении беарнского соуса является то, что оожет и не получиться – соус может загуститься или расслоиться, и если это случится, ве сможете его восстановить. Процесс приготовления соуса занимает примерно 45 минутоэтому проваленная попытка означает, что у вас уже не будет времени на вторуопытку.
С другой стороны, любой шеф-повар умеет готовить беарнский соус. Это входит в ибучение и, как они скажут вам сами, это не трудно. Вам не нужно бытрофессиональным поваром, чтобы приготовить этот соус. Всякий, кто учился еготовить, по крайней мере, один раз терпел неудачу, но как только вы научитесь еготовить, у вас он будет получаться всегда.
Я думаю, что механизм внедрения зависимостей – это нечто вроде беарнского соуса.
Полагают, что он сложен, и поэтому немногие его применяют. Если вы попытаетесь егспользовать и потерпите неудачу, то у вас, скорее всего, не будет времени на вторуопытку.
О пределение.
Механизм внедрения зависимостей (Dependency Injection) – это набор принципов аблонов проектирования программного обеспечения, которые дают нам возможностазрабатывать слабосвязанный код.
Несмотря на Страх, Неопределенность и Сомнения (FUD), окружающие DI, ему так жегко научиться, как и приготовлению беарнского соуса. Вы можете допускать ошибки во
7
время обучения, но как только вы овладеете методикой, вы уже больше никогда нотерпите неудачу при применении этого механизма.
В разделе вопросов и ответов, связанных с разработкой программного обеспечения, веб-
сайта Stack Overflow демонстрируется ответ на вопрос "Как объяснить механизнедрения зависимостей пятилетнему ребенку?". Самый высоко оцененный ответоторый был дан Джоном Маншем, предоставляет поразительно точную аналогиюацеленную на (воображаемого) пятилетнего изыскателя:
Когда ты идешь к холодильнику и что-то самостоятельно достаеш ь из него, т ожет е стать причиной возникновения проблем. Ты можешь ост авить дверт крытой, т ы можешь взять то, чт о мама или папа не хотели бы, чтобы ты брал. Таже можеш ь искат ь т о, чего у нас и не было, или т о, чт о уже закончилось.
Все, чт о т ебе следует сделать, – это сформулировать, чт о т ебе нужно, "Мне нужно-то, чт обы выпить во время ланча", и после этого мы будем следить за т ем, чт обы ебя было эт о, когда т ы садиш ься кушать.
В терминах разработки программного обеспечения с использованием технологибъектно-ориентированного программирования это означает: взаимодейству ющие классы
(пятилетние дети) должны полагаться на инфраструктуру (родителей), котораредоставляет необходимые услуги.
Как продемонстрировано на рисунке 1-1, данная глава совершенно прямолинейна пвоей структуре. Сначала я знакомлю с DI, в том числе с его целями и преимуществами.
Несмотря на то, что я включаю в нее примеры, в целом в этой главе содержится меньшода, нежели в любой другой главе этой книги.
Рисунок 1-1: Структура книги совершенно прямолинейна. Вы должны прочитать первыаздел перед тем, как прочитать следующий и т.д. Это может показаться очевидным, некоторые из последующих глав этой книги менее прямолинейны по своей натуре.
8
Перед тем как познакомить вас с механизмом внедрения зависимостей, я буду обсуждатсновную цель DI: удобство сопровождения. Это важно, поскольку очень легкеправильно понять механизм DI, если вы не подготовлены должным образом. Далееосле примера (Hello DI), я буду рассматривать преимущества и область применения DI, ущности, прокладывая маршрутную карту этой книги. Когда вы закончите изучение этолавы, вы будете подготовлены к более продвинутым концепциям, обсуждаемым стальной части книги.
Для большинства разработчиков механизм внедрения зависимостей может казаться слегктсталым способом создания исходного кода и, по аналогии с беарнским соусом, в негключено слишком много Страха, Неопределенности и Сомнения. Для того чтобы изучитеханизм внедрения зависимостей, вам для начала необходимо понять его цель.
1.1. Написание поддерживаемого кода
1.2. Привет DI
1.3. Что внедрять, а что не внедрять
1.4. Область применения DI
1.5. Резюме
9
1.1. Написание поддерживаемого кода
Каким целям служит механизм внедрения зависимостей? DI, сам по себе, не являетселью, скорее, это средство достижения результата. В конечном итоге целью большинствехнологий программирования является предоставление программного обеспеченияаботающего настолько эффективно, насколько это возможно. Одним из аспектов этоели является написание поддерживаемого кода.
За исключением тех моментов, кода вы будете писать прототипы или приложения, оторых никогда не будет релиза выше первого, вы вскоре обнаружите, что занимаетесоддержанием и расширением существующего кода. Для того чтобы с таким кодоожно было эффективно работать, он должен быть настолько поддерживаемымасколько это возможно.
Одним из множества способов создания поддерживаемого кода является использованилабого связывания. Еще в 1995 году, когда "Банда четырех" (Эрих Гамма, Ричард Хелм,
Ральф Джонсон, Джон Влиссидс) написала книгу "Паттерны проектирования" ("Design
Patterns"), существовало универсальное знание:
Программируй, основываясь на интерфейсе, а не на классах.
Этот совет является не заключением, а скорее остроумной предпосылко й книги
"Паттерны проектирования": он появляется на странице 18. Слабое связывание делает коасширяемым, а расширяемость делает его поддерживаемым.
DI – это не более чем технология, которая разрешает слабое связывание. Как бы то ныло, существует множество моментов недопонимания механизма внедрениависимостей, и иногда они мешают истинному пониманию. Перед тем как приступить зучению, вы должны забыть то, что (как вы думаете) вы уже знали.
Какие знания о DI нужно забыть
Подобно стереотипу, касающемуся голливудских восточных единоборств, вы должнабыть все, что вы знали раньше, прежде чем сможете чему-то научиться. Существуеножество моментов недопонимания механизма DI, и если вы будете носить эти знания ебе, то вы неправильно поймете то, что вы прочитаете в этой книге. Вы должны очиститвой разум, чтобы понять механизм DI.
Существует, по крайней мере, четыре общих мифа, касающихся механизма внедрениависимостей:
? DI имеет отношение только к "позднему связыванию" (late binding).
? DI имеет отношение только к модульному тестированию (unit testing).
? DI – это вид абстрактной фабрики (Abstract Factory) на "стероидах".
? Для механизма DI необходим DI-контейнер.
Несмотря на то, что ни один из этих мифов не является правдой, они, тем не менееироко распространены. Мы должны развеять их до того, как приступим к изучениеханизма внедрения зависимостей.
Позднее связывание
10
В данном контексте под поздним связыванием понимается возможность заменять частриложения без необходимости перекомпиляции кода. Приложение, которое разрешаеобавление-вставку сторонних компонентов (таких, как Visual Studio), является одним иримеров позднего связывания.
Еще один пример – стандартное программное обеспечение, которое поддерживаеазличные исполняемые среды. У вас может быть приложение, которое может запускатьсольше, чем на одном движке базы данных: например, такое, которое поддерживает как
Oracle, так и SQL Server. Для поддержки такой возможности остальная часть приложениожет обращаться к базе данных посредством интерфейса. База кода может предоставлятазличные реализации этого интерфейса с целью обеспечения доступа к Oracle и SQL
Server соответственно. Для контроля над тем, какая реализация должна применяться дланной инсталляции, может использоваться опция конфигурации.
Тот факт, что механизм внедрения зависимостей имеет отношение только к такому видценариев, является повсеместным заблуждением. Это понятно, поскольку DI разрешаеакой сценарий, но ошибочно думать, что зависимость симметрична. То, что DI разрешаеозднее связывание, еще не означает, что он имеет отношение только к сценарияозднего связывания. Как это продемонстрировано на рисунке 1-2, позднее связыванивляется всего лишь одним из аспектов механизма внедрения зависимостей.
Рисунок 1-2: Позднее связывание разрешено механизмом внедрения зависимостей, нолагать, что DI применим только в сценариях позднего связывания значит приниматграниченное представление более широкой перспективы.
Если вы думали, что механизм внедрения зависимостей имеет отношение только озднему связыванию, то вам необходимо забыть об этом. М еханизм DI делает намногольше, чем просто разрешает позднее связывание.
Модульное тестирование
Некоторые люди думают, что механизм внедрения зависимостей имеет отношение тольк поддержке модульного тестирования. Это неверно, несмотря на то, что механизм DI
определенно является важной составляющей поддержки модульного тестирования.
По правде говоря, мое первоначальное знакомство с механизмом DI произошло во времорьбы с определенными аспектами технологии разработки через тестирование (Test-
Driven Developm ent или TDD). Во время этой борьбы я познакомился с DI и узнал, чтстальные использовали этот механизм для того, чтобы поддерживать некоторыценарии, похожие на те, к которым я обращался.
Даже если вы не пишите модульные тесты (если вы этого не делаете, то вам следуеачать прямо сейчас), механизм DI все еще уместен, благодаря всем остальныреимуществам, которые он предлагает. Утверждение о том, что механизм DI имеетношение только к поддержке модульного тестирования, подобно утверждению о томто DI имеет отношение только к поддержке позднего связывания. Рисунок 1-3
11
демонстрирует, что, несмотря на то, что это уже другое представление, это представлениакое же ограниченное, как и изображенное на рисунке 1-2. В данной книге я сделал всозможное, чтобы продемонстрировать вам общую картину.
Рисунок 1-3: Хотя предположение о том, что модульное тестирование являетсдинственной целью механизма DI, – это уже другое представление, нежели то, котороасалось позднего связывания, оно все равно является ограниченным представлениеолее широкой перспективы.
Если вы думали, что механизм внедрения зависимостей имеет отношение только одульному тестированию – забудьте об этом. Механизм DI делает намного больше, черосто разрешает модульное тестирование.
Абстрактная фабрика "на стероидах"
Возможно, самым опасным заблуждением является то, что механизм DI включает в себекоторого рода универсальну ю абстрактную фабрику, которую мы можем использоватля создания экземпляров необходимых нам зависимостей.
Во введении к данной главе я писал, что "взаимодействующие классы … должнолагаться на инфраструктуру …, которая предоставляет необходимые услуги".
Какими были ваши первоначальные соображения по поводу этого предложения? Думали вы об инфраструктуре, как о некоторого рода сервисе, к которому вы могли ббратиться, чтобы получить необходимую зависимость? Если это так, то вы не одиноки воих мыслях. Многие разработчики и архитекторы думают о механизме внедрениависимостей как о сервисе, который может использоваться для указания местоположениругих сервисов; этот сервис имеет название Service Locator (сервис-локатор), но овляется полной противоположно стью DI.
Если вы думали о механизме DI, как о сервис-локаторе, – а именно, универсальноабрике – вам нужно об этом забыть. Механизм внедрения зависимостей являетсротивоположностью Service Locator; это способ структурирования кода таким образомтобы нам никогда не нужно было обязательно запрашивать зависимости. В противнолучае мы принуждаем пользователей возмещать их.
DI-конте йнеры
Тесно связано с предыдущим заблуждением мнение о том, что для механизма DI
необходим DI-контейнер. Если бы вы придерживались предыдущего, ошибочного мнени том, что DI включает в себя Service Locator, то было бы легко прийти к выводу о томто DI-контейнер может взять на себя ответственность за Service Locator. Это имеет местыть, но это никак не является тем, как мы должны использовать DI-контейнер.
DI-контейнер – это необязательная библиотека, которая может упростить процесоздания компонентов при регистрации приложения, но это не обязательный способ.
12
Когда мы создаем приложения без использования DI-контейнера, мы называем это Poo an's DI; для этого требуется больше работы, но несколько другого рода, при которой нае нужно идти на компромисс при использовании какого-либо принципа механизмнедрения зависимостей.
Если вы думали, что для механизма DI нужен DI-контейнер, то забудьте об этом.
Механизм внедрения зависимостей – это набор принципов и паттернов, а DI-контейнер –
это полезный, но необязательный инструмент.
Вы можете думать, что, хотя я и изложил четыре мифа о механизме внедрениависимостей, мне, тем не менее, нужно предоставить неопровержимое доказательствротив каждого из этих мифов. Это верно. В некотором смысле, вся эта книга являетсольшим аргументом против этих общих заблуждений.
По моему мнению, забывание некоторых фактов жизненно необходимо, поскольку людмеют склонность к тому, чтобы пытаться модифицировать те факты, которые ассказываю им о механизме DI и совмещать это с тем, что, по их мнению, они уже знал механизме внедрения зависимостей. Когда такое случается, много времени тратитсрежде, чем они, в конце концов, осознают, что некоторые из их основных предпосыло е верны. Я хочу поделиться с вами этими знаниями. Поэтому, если вы сможетеопытайтесь прочитать эту книгу так, будто вы ничего не знаете о механизме DI.
Давайте предположим, что вы ничего не знаете о механизме внедрения зависимостей и го целях и начнем с того, что рассмотрим то, что механизм DI делает.
Осознание цели DI
Механизм DI – это не конечная цель, это средство достижения результата. Механизнедрения зависимостей разрешает слабое связывание, а слабое связывание делает коолее поддерживаемым. Это совершенное утверждение, и, несмотря на то, что я мог бтослать вас за подробностями к таким прочно установившимся авторитетам, как "Бандетырех", я думаю, что справедливо будет объяснить вам, почему это именно так.
Разработка программного обеспечения все еще остается довольно новорофессионально й сферой, поэтому в большинстве случаев мы все еще находимся роцессе разгадывания того, как реализовать хорошую архитектуру. Тем не менееекоторые личности, имеющие опыт в более традиционных профессиях (напримеронструирование), давно это разгадали.
Проверка в дешевом отеле
Если вы останавливаетесь в дешевом отеле, то можете столкнуться со зрелищем, подобному, которое продемонстрировано на рисунке 1-4. На этом рисунке продемонстрироваен, дружелюбно предоставленный отелем для вашего удобства, но, по-видимомудминистрация отеля не верит, что вы оставите фен следующему гостю: прибор напрямурисоединен к стенной розетке. Несмотря на то, что шнур достаточно длинный для тоготобы предоставить вам определенную степень подвижности, вы не можете взять фен обой. По-видимому, управление отеля решило, что стоимость замены украденных феноостаточно высока и оправдывает то, что в противном случае явно является худшееализацией.
13
Рисунок 1-4: В комнате дешевого отеля вы можете найти фен, подсоединенный к стенноозетке напрямую. Это эквивалентно использованию универсальной практики написаниильно связанного кода.
Что происходит, когда фены прекращают работать? Отелю приходится вызыватвалифициро ванного профессионала, который умеет решать эту проблему. Для ремонтестко встроенного фена им придется отключить питание во всей комнате, делая ее пртом временно бесполезной. Затем специалист будет использовать специальнынструменты для того, чтобы тщательно отсоединить фен и заменить его на новый. Еслам повезет, то специалист не забудет снова включить питание в комнате и проверитьаботает ли новый фен… Если вам повезет. Знакома ли вам вообще эта процедура?
Так вы бы приступали к работе с сильно связанным кодом. В этом сценарии фен сильнвязан со стеной, и вы не сможете с легкостью модифицировать одного без влияния нругого.
С равнение электрической проводки с паттернами прое ктирования
Обычно мы не монтируем электрические устройства вместе, напрямую присоединяабель к стене. Вместо этого, как продемонстрировано на рисунке 1-5, мы используеилки и розетки. Розетка определяет форму, к которой необходимо присоединить вилку.
Если провести аналогию с проектированием программного обеспечения, то розетка – этнтерфейс.
14
Рисунок 1-5: Посредством использования розеток и вилок фен можно слабо связать стенной розеткой.
В противоположност ь жестко встроенному фену вилки и розетки определяют слабвязанную модель соединения электрических устройств. Поскольку вилка вставляется озетку, мы можем комбинировать устройства различными способами. Что в особенностнтересно, так это то, что многие из этих универсальных комбинаций можно сравнить орошо известными принципами и паттернами проектирования программногбеспечения.
Во-первых, мы больше не стеснены рамками фенов. Если вы самый обычный читатель, т бы предположил, что вам больше нужен компьютер, чем фен. Это не проблема: мыдернем из розетки фен и подключим компьютер к той же розетке, как это показано нисунке 1-6.
Рисунок 1-6: Используя розетки и вилки, мы можем заменить первоначальнспользуемый фен из рисунка 1-5 на компьютер. Это соответствует принципу замещения
Лисков.
15
Удивительно, что понятие розетки стало использоваться на десятилетия раньше, чеоявились компьютеры, и до сих пор она также является существенным для компьютеррибором. Первоначальные разработчики розеток, вероятно, не могли предсказатоявление персональных компьютеров, но, поскольку их конструкция таканиверсальная, можно столкнуться с потребностями, которые первоначально нассматривались. Возможность замены одной конечной детали без смены другой схожа ентральным принципом проектирования программного обеспечения, который носиазвание принцип замещения Лисков. Этот принцип утверждает, что мы могли баменить одну реализацию интерфейса на другую, не разрушив при этом ни клиента, неализацию.
Что касается механизма внедрения зависимостей, принцип замещения Лисков – это одиз самых важных принципов проектирования программного обеспечения. Это принципоторый дает нам возможность обращаться к потребностям, которые возникнут удущем, даже если мы не можем предвидеть их сегодня.
Как это проиллюстрировано на рисунке 1-7, мы можем выдернуть шнур компьютера иозетки, если на данный момент нам не нужно его использовать. Даже если ничего нодключено к розетке, стена не взрывается.
Рисунок 1-7: Отключение компьютера не приводит ни к взрыву стены, ни к взрывомпьютера. Это можно приближенно сравнить с паттерном Null O bject.
Если мы отсоединим компьютер от стены, то ни стена, ни компьютер не разрушатся (ействительности, если это портативная ЭВМ, то она может работать и на собственных
16
батарейках в течение некоторого времени). Тем не менее, что касается программногбеспечения, клиент часто ожидает, что сервис будет доступен. Если сервис был удалено мы получаем NullReferenceException. Для того чтобы справиться с этой ситуациейы можем создать реализацию интерфейса, которая ничего не делает. Это паттерроектирования, известный как Null Object, и он приблизительно соответствуетсоединению компьютера от стены. Благодаря тому, что мы используем слабовязывание, мы можем заменить существующу ю реализацию чем-то таким, что ничего ныполняет и при этом не приводит к проблемам.
Существует множество других вещей, которые мы можем сделать. Если мы живем поседству со скачкообразным отключением электричества, то мы можем захотеть, чтобаш компьютер продолжал работать и после отключения питания, подключив его длтого к системе бесперебойного питания (Uninterrupted Power Supply), как этродемонстрировано на рисунке 1-8: мы подсоединяем систему бесперебойного питания тенной розетке, а компьютер к этой системе.
Рисунок 1-8: Можно воспользоваться системой бесперебойного питания для того, чтобомпьютер продолжал работать при отключении электричества. Это соответствуеаттерну проектирования Decorator.
Компьютер и система бесперебойного питания служат разным целям. Каждый из нибладает самостоятельной ответственностью, на которую не может посягнуть другостройство. Скорее всего, система бесперебойного питания и компьютер производятсвумя разными производителями, покупаются в разное время и подключаются в разноремя. Как демонстрирует рисунок 1-6, мы можем запустить компьютер без системесперебойного питания (СБП), но мы также могли бы, возможно, использовать фен время отключения электричества путем подключения его к СБП.
В проектировании программного обеспечения этот способ пересечения реализации другоеализацией того же самого интерфейса известен как паттерн проектирования Decorator.
Он предоставляет нам возможность последовательно вводить новые возможности квозные сущности без необходимости заново переписывать и изменять огромные объемуществующего кода.
Еще один способ добавления новой функциональности в существующий код –
комбинировать существующу ю реализацию интерфейса с новой реализацией. Когда моединяем несколько реализаций в одну, мы используем паттерн проектирования
C om posite. Рисунок 1-9 иллюстрирует то, как это соответствует подключению различныстройств к удлинителю.
17
Рисунок 1-9: Удлинитель дает возможность подключать несколько устройств к однотенной розетке. Это соответствует паттерну проектирования Composite.
Удлинитель имеет единственную вилку, которую мы можем вставить в единственнуозетку, тогда как сам удлинитель предоставляет несколько розеток для множествстройств. Это позволяет нам подключать и отключать фен во время работы компьютера.
Аналогично паттерн C om posite облегчает процесс добавления и удалениункциональности посредством модификации набора составных реализаций интерфейса.
Ниже приведен окончательный пример. Мы иногда обнаруживаем, что вилка не подходи определенной розетке. Если вы путешествовали в другую страну, то вы, скорее всегоамечали, что розетки во всем мире отличаются друг от друга. Если вы во времутешествия возите с собой что-то, например фотоаппарат, как показано на рисунке 1-10о вам нужен адаптер для того, чтобы заряжать его. Соответственно, это паттерроектирования с таким же именем – Adapter.
Рисунок 1-10: Во время путешествия нам часто нужно использовать адаптер для тоготобы подключить устройство к иностранной розетке (например, чтобы перезарядитотоаппарат). Это соответствует паттерну проектирования Adapter.
Паттерн проектирования Adapter работает так же, как и его физический тезка. Он можеспользоваться для соединения двух связанных, но разделенных интерфейсов друг ругом. Это в особенности полезно, когда у вас есть существующее стороннее APIоторое вы хотите использовать в качестве экземпляра интерфейса, используемого вашириложением.
18
По отношению к модели розетки и вилки удивительным является тот факт, что нротяжении десятилетий она является простой и универсальной моделью, и это доказано.
После создания инфраструктура может использоваться кем угодно и адаптироваться зменениям потребностей и непредсказуемым требованиям. Что еще более интересно, тато то, что когда мы связываем эту модель с разработкой программного обеспечения, встроительные блоки уже находятся на своих местах в виде принципов и паттернороектирования.
Слабое связывание может сделать код более поддерживаемым.
Это самая простая часть. Программировать на основании интерфейса, а не реализациегко. Возникает вопрос, откуда берутся интерфейсы? В некотором смысле, это то, чемосвящена эта книга.
Вы можете создать новый экземпляр интерфейса так же, как вы создаете новый экземпляонкретного типа. Код, подобный продемонстрированному ниже, не компилируется:
IMessageWriter writer = new IMessageWriter()
IMessageWriter: Программирование на основании интерфейсоew IMessageWriter(): Не компилируется
У интерфейса нет конструктора, поэтому это невозможно. Экземпляр writer должен бытоздан с помощью другого механизма. Механизм DI решает эту проблему.
С таким представлением цели механизма DI, думаю, вы готовы к примеру.
19
1.2. Привет DI
В традиции бесчисленных учебников по программированию давайте рассмотрим простоонсольное приложение, которое выводит "Hello DI!" на экран. В этом разделе родемонстрирую вам, на что похож код и вкратце обрисую некоторые ключевыреимущества, не вдаваясь при этом в детали, – в остальной части книги я рассмотрю этолее детально.
Код приложения "Hello DI!"
Вероятно, вы привыкли видеть примеры "Hello World", которые пишутся в одну строкода. В этой книге мы берем нечто чрезвычайно простое и делаем его сложным. Зачем?
Мы скоро доберемся до этого, но сначала давайте посмотрим, как бы выглядел пример
"Hello World" с использованием механизма внедрения зависимостей.
Партнеры
Чтобы понять структуру программы, мы начнем с рассмотрения метода Main консольногриложения, а затем я продемонстрирую вам взаимодействующие классы:
private static void Main()
{
IMessageWriter writer = new ConsoleMessageWriter();
var salutation = new Salutation(writer);
salutation.Exclaim();
}
Программа должна вводить данные в консоль, поэтому она создает новый экземпляр
ConsoleMessageWriter, который как раз и инкапсулирует эту функциональность. Оередает этого автора сообщения в класс Salutation, таким образом, экземпляр
Salutation знает, куда записывать эти сообщения. Поскольку на данный момент всодсоединено должным образом, вы можете выполнить логику, что приведет к тому, чтообщение будет записано на экране.
Рисунок 1-11 демонстрирует взаимоотношения между партнерами.
Рисунок 1-11: Метод Main создает новые экземпляр ы как класса ConsoleMessageWriterак и класса Salutation. ConsoleMessageWriter реализует интерфейс IMessageWriterоторый используется Salutation. В сущности Salutation использует
ConsoleMessageWriter, несмотря на то, что это непрямое использование нродемонстрировано.
Основная логика приложения инкапсулирована в классе Salutation, чтродемонстрировано в следующем листинге.
20
Листинг 1-1: Класс Salutation
1. public class Salutation
2. {
3. private readonly IMessageWriter writer;
4. public Salutation(IMessageWriter writer)
5. {
6. if (writer == null)
7. {
8. throw new ArgumentNullException("writer");
9. }
10. this.writer = writer;
11. }
12. public void Exclaim()
13. {
14. this.writer.Write("Hello DI!");
15. }
16. }
Строка 4: Внедряет зависимость
Строка 14: Использует зависимость
Класс Salutation зависит от пользовательского интерфейса под названием
IMessageWriter и запрашивает экземпляр этого интерфейса через его конструктор. Этороцесс называется внедрением через конструктор (Constructor Injection) и описываетсодробно в главе 4, которая также содержит более детальный анализ похожего примерода.
Экземпляр IMessageWriter впоследствии используется в реализации метода Exclaimоторый записывает соответствующее сообщение в зависимость.
IMessageWriter – это простой интерфейс, определенный следующим образом:
public interface IMessageWriter
{
void Write(string message);
}
Он мог бы иметь другие элементы, но в этом простом примере вам нужен только метод
Write. Этот интерфейс реализуется с помощью класса ConsoleMessageWriter, которыетод Main передает в класс Salutation:
public class ConsoleMessageWriter : IMessageWriter
{
public void Write(string message)
{
Console.WriteLine(message);
}
}
Класс ConsoleMessageWriter реализует IMessageWriter путем упаковывания класса
Console из библиотеки базовых классов. Это простое приложение паттернроектирования Adapter, о котором мы говорили в разделе "Осознание цели DI".
21
Возможно, вам интересно будет узнать о преимуществе замены однострочного кода нва класса и интерфейс, объем которых составляет 11 строк, и это вполне справедливо.
Существует несколько преимуществ, которые можно получить, поступая таким образом.
Преимущества DI
Чем предыдущий пример лучше обычного однострочного кода, который мы обычнспользуем для реализации "Hello World" в C#? В этом примере механизм DI прибавляездержок в размере 1,100%, но как только сложность кода возрастает от одной строки десятков тысяч строк, эти издержки сокращаются и почти исчезают. Глава 2
предоставляет более сложный пример применения механизма внедрения зависимостей, иесмотря на то, что этот пример все еще слишком прост по сравнению с реальнымриложениями, вы должны заметить, что механизм DI менее навязчивый.
Я не виню вас в том, что вы можете найти предыдущий пример слишком надуманным, нбдумайте следующее: по своей сущности классический пример "Hello World" – этростая проблема с хорошо заданными и ограниченными требованиями. В реальном миразработка программного обеспечения никогда не происходит таким образом. Требованизменяются и часто являются довольно расплывчатыми. Возможности, которые ваеобходимо реализовывать, также стремятся к усложнению. Механизм внедрениависимостей помогает решать такие вопросы путем разрешения слабого связывания. В
частности мы получаем преимущества, перечисленные в таблице 1-1.
В таблице 1-1 я сначала указал такое преимущество как "позднее связывание", потому чтоо моему опыту, это является самым важным для большинства людей. Когда архитектор разработчики не осознают преимуществ слабого связывания, это, главным образомроисходит, потому что они не рассматривают другие преимущества.
Таблица 1-1: Преимущества, получаемые при использовании слабого связывания. Каждореимущество доступно всегда, но может быть по-разному оценено в зависимости обстоятельств.
Преимущество Описание Когда оно полезно?
Поздневязывание
Сервисы могут менятьсестами с другими сервисами.
Ценится в стандартно м программнобеспечении, но, возможно, менее ценится орпоративных приложения х, в которысполня ющая среда стремится к тому, чтобыть хорошо определенной.
Расширяемость
Код можно расширять спользовать заново омощью явно напланированных способов.
Ценится всегда
Параллельнаазработка
Код может разрабатывать сараллельно.
Ценится в больших, сложных приложениях; не так сильно в небольших, простыриложениях
Удобствопровождения
Классы с явно определеннымбязанностя ми легчоддерживать.
Ценится всегда
Тестируемость Классы можно тестироватодульно.
Ценится только, если вы выполняете модульноестирование (а вы действитель но должны этелать)
22
Позднее связывание
При объяснении преимуществ программирования на основании интерфейсов и механизмнедрения зависимостей возможность заменять один сервис другим является самыреобладающим преимуществом для большинства людей, поэтому они стремятсзвесить все достоинства и недостатки, имея в виду только это преимущество.
Помните тот момент, когда я просил вас забыть все, что вы знали до этого, прежде чеачнете изучение? Вы можете сказать, что вы настолько хорошо знаете ваши потребностито уверены в том, что вам никогда не придется заменять, скажем, вашу базу данных SQL
Server чем-то еще. Тем не менее, потребности изменяются.
NoSQ L, Windows Azure и аргументы в пользу композиции (composability)
Несколько лет назад я часто наталкивался на безразличные выражения, когда пыталсбедить разработчиков и архитекторов в преимуществах механизма внедрениависимостей.
"Допустим, таким образом, вы можете заменить ваш реляционный компонент доступа анным чем-то другим. Чем?" Существует ли какая-нибудь альтернатива реляционных баанных?"
XML файлы никогда не казались подходящей альтернативой для крупномасштабныорпоративных сценариев. За последнюю пару лет все значительно изменилось.
О Windows Azure было объявлено на конференции Microsoft PDC 2008, и эта платформногое сделала для того, чтобы убедить даже консервативные организации, которыспользуют только продукцию Microsoft, в том, что необходимо переоценить их позициасаемо хранилища данных. На данный момент существует реальная альтернативеляционных баз данных, и мне приходится спрашивать людей только о том, хотели бни, чтобы их приложение было "cloud-ready" приложением. Аргумент в пользамещения на данный момент становится все весомее.
Связанное движение можно обнаружить во всей концепции NoSQL, которая моделируериложения на основе ненормализованных данных – часто документо-ориентированныаз данных, но такие концепции, как Event Sourcing, также становятся все более важными.
В разделе "Код приложения "Hello DI!"" вы не использовали "позднее связывание"оскольку вы явно создавали новый экземпляр IMessageWriter при помощи жестко-
закодированного создания нового экземпляра ConsoleMessageWriter. Т ем не менее, вожете ввести "позднее связывание" путем изменения только одного фрагмента кода. Ваужно всего лишь изменить следующую строку кода:
IMessageWriter writer = new ConsoleMessageWriter();
Для того чтобы разрешить позднее связывание, вы могли бы заменить эту строку кодем-то вроде этого:
var typeName = ConfigurationManager.AppSettings["messageWriter"];
var type = Type.GetType(typeName, true);
IMessageWriter writer = (IMessageWriter)Activator.CreateInstance(type);
23
Посредством вытаскивания имени типа из конфигурационного файла приложения оздания из него экземпляра Type вы можете использовать рефлексию для созданикземпляра IMessageWriter во время компиляции без знания конкретного типа.
Чтобы выполнить это, вы указываете имя типа при настройке приложения messageWrite конфигурационном файле этого приложения:
<appSettings>
<add key="messageWriter"
value="Ploeh.Samples.HelloDI.CommandLine.ConsoleMessageWriter, HelloDI" />
</appSettings>
Предупреждение
В этом примере для доказательства используются некоторые кратчайшие пути. В
действительности на этот пример оказывает негативное влияние анти-паттерн
C onstrained Construction, который подробно рассматривается в главе 5.
Слабое связывание разрешает "позднее связывание", поскольку существует только однесто, где вы создаете экземпляр IMessageWriter. В связи с тем, что класс Salutatioаботает только по отношению к интерфейсу IMessageWriter, он никогда не замечаеазницы.
В примере "Hello DI" "позднее связывание" будет предоставлять вам возможность писатообщения другим адресатам, а не только в консоль – например, в базу данных или файл.
Можно добавлять такие возможности, даже если вы явно не планировали их до этого.
Расширяемость
Успешное программное обеспечение должно быть способно к модификации. Вам можеонадобиться добавить в него новые возможности, а также расширить существующие.
Слабое связывание позволяет вам эффективно перестраивать приложение, подобно томуак мы можем заново подключать электрические устройства при помощи вилок и розеток.
Давайте скажем, что вы хотите сделать пример "Hello DI" более безопасным, разрешаолько авторизованным пользователям писать сообщения. Следующий листинемонстрирует, как вы можете добавить эту возможность без изменения какой-либуществующей возможности: вы добавляете новую реализацию интерфейса
IMessageWriter.
Листинг 1-2: Расширение приложения "Hello DI" путем добавления возможностбеспечения безопасности
1. public class SecureMessageWriter : IMessageWriter
2. {
3. private readonly IMessageWriter writer;
4. public SecureMessageWriter(IMessageWriter writer)
5. {
6. if (writer == null)
7. {
8. throw new ArgumentNullException("writer");
9. }
10. this.writer = writer;
11. }
12. public void Write(string message)
24
13. {
14. if (Thread.CurrentPrincipal.Identity.IsAuthenticated)
15. {
16. this.writer.Write(message);
17. }
18. }
19. }
Строка 14: Проверяет наличие авторизации
Строка 16: Записывает сообщение
Класс SecureMessageWriter реализует интерфейс IMessageWriter и в то же времспользует его: он использует механизм внедрения зависимости через конструктор длого, чтобы запросить экземпляр IMessageWriter. Это стандартное приложение паттернроектирования Decorator, о котором я упоминал в разделе "Осознание цели DI". Болеодробно об этом паттерне мы поговорим в главе 9.
При реализации метода Write сначала проверяется, авторизован ли текущий пользователь.
Только в этом случае этому пользователю разрешается записывать сообщения в полriter с помощью метода Write.
Примечание
Метод Write в листинге 1-2 обращается к текущему пользователю через Ambient Context
(окружающий контекст). Более гибкий, но в то же время немного более сложный варианакже мог бы предоставить пользователя посредством внедрения через конструктор.
Единственное место, где вам нужно будет изменить существующий код – это метод Mainоскольку вам нужно скомпоновать доступные классы несколько другим способомежели вы это делали до этого:
IMessageWriter writer =
new SecureMessageWriter(
new ConsoleMessageWriter());
Заметьте, что вы награждаете предыдущий экземпляр ConsoleMessageWriter классом
SecureMessageWriter. В очередной раз класс Salutation не модифицируется, посколькн использует только интерфейс IMessageWriter.
Слабое связывание позволяет вам писать код, который открыт для расширяемости, накрыт для модификации. Это называется принципом открытости/закрытости
(Open/closed principle). Единственное место, где вам нужно модифицировать код – в точкхода приложения; мы называем ее Com position Root.
SecureMessageWriter реализует возможность обеспечения безопасности в приложения, о время, как ConsoleMessageWriter обращается к пользовательскому интерфейсу. Этозволяет нам варьировать эти аспекты независимо друг от друга и компоновать их такак нам нужно.
Паралле льная разработка
25
Концепция разделения делает возможным разработку кода параллельными командами.
Когда проект разработки программного обеспечения достигает определенного размератановится необходимым разделить команду разработчиков на несколько команд легкправляемого размера. За каждой командой закрепляется ответственность за некоторубласть приложения.
Для того чтобы разграничить ответственности, каждая команда будет разрабатывать одили более одного модуля, которые нужно будет интегрировать в законченное приложение.
За исключением тех случаев, когда области деятельности каждой команды точно нависят друг от друга, некоторые команды, скорее всего, зависят от функционально стиоторая разрабатывается другими командами.
В приведенном выше примере благодаря тому, что классы SecureMessageWriter и
ConsoleMessageWriter не зависят друг от друга напрямую, они могут разрабатыватьсараллельными командами. Момент, который им нужно будет согласовывать – этовместно используемый интерфейс IMessageWriter.
Удобство сопровождения
Как только ответственность каждого класса становится явно определенной граниченной, процесс сопровождения всего приложения облегчается. Это хорошзвестное преимущество принципа единственной ответственности (singlesponsibility principle), который утверждает, что каждый класс должен обладать толькдинственной ответственностью.
Процесс добавления новых возможностей в приложение упрощается, поскольковершенно ясно, где нужно выполнить изменения. Почти всегда нам даже не нужнзменять существующий код, но вместо этого мы можем добавлять новые классы и зановомпоновать приложение. Здесь в игру снова вступает принцип единственнответственности.
Поиск неисправностей также становится менее утомительным, поскольку областозможных виновников неисправностей сужается. Благодаря явно определеннытветственностям у вас всегда будет четкое осознание того, откуда нужно начинать поисорневой причины появления проблемы.
Тестируе мость
Для некоторых тестируемость является наименьшим поводом для беспокойства; длругих это абсолютная потребность. Лично я принадлежу к последней категории людей:
за мою карьеру я отклонил несколько предложений, потому что в них входила работа пределенными, нетестируемыми продуктами.
О пределение
Приложение считается тестируемым, когда его можно тестировать помодульно.
Преимущество тестируемости, возможно, самое спорное из всех преимуществ, которые еречислил ранее. Многие разработчики и архитекторы не практикуют модульноестирование, поэтому они считают это преимущество в лучшем случае несущественным.
Другие, такие как я, считают его существенным. Майкл Физерс даже дает определение
26
термину "унаследованное приложение" как любое приложение, которое не охваченодульным тестированием.
Практически случайно слабое связывание разрешает модульное тестирование, потому чтользователи руководствуются принципом замещения Лисков: они не заботятся о томтобы у их зависимостей были конкретные типы. Это означает, что мы можем внедритублеры теста (Test Doubles) в т естируемую сист ему (System Under Test (SUT)), как мто видим в листинге 1-3.
Возможность подменять заданную зависимость заменителем конкретного теста – этобочный результат слабого связывания, но я предпочел указать эту возможность катдельное преимущество, поскольку унаследованное значение отличается оервоначального.
Тестируе мость
Термин "тестируемость" ужасно неопределенный, однако он широко используется бществе разработчиков программного обеспечения, главным образом теми, ктрактикует модульное тестирование.
В принципе любое приложение можно тестировать таким образом. Тесты могуыполняться людьми, которые используют это приложение, посредством иользовательского интерфейса или какого-нибудь другого интерфейса, которыредоставляет это приложение. Такие ручные тесты требуют больших временных енежных затрат, поэтому наиболее предпочтительным является автоматизированноестирование.
Существует множество различных видов автоматизированного тестирования, напримеродульное тестирование, интеграционное тестирование, тестирование продуктивностиагрузочное тестирование (stress testing) и т.д. Поскольку модульное тестирование имееебольшое количество требований к исполняющим средам, оно является самыффективным и сильным видом теста; часто в этом контексте и оцениваетсестируемость.
Модульные тесты обеспечивают быструю ответную реакцию на состояние приложенияо модульные тесты можно писать только тогда, когда тестируемый модуль может бытвно изолирован от его зависимостей. Существует некоторая неоднозначность тогоасколько в действительности детализирован модуль, но все соглашаются, что этействительно не является тем, что соединяет множественные модули. Возможностестировать модули изолированно друг от друга очень важна для модульногестирования.
Только когда приложение поддается модульному тестированию, его можно считатестируемым. Самый безопасный способ обеспечения тестируемости приложения – этазрабатывать приложение при помощи технологии тестирования через разработку
(T DD).
Необходимо отметить, что сами по себе модульные тесты не являются гарантиеаботоспособности приложения. Для того чтобы проверить, работает ли приложение такак планировалось, все еще необходимы тесты всей системы или другие промежуточныиды тестов.
27
В зависимости от типа приложения, которое я разрабатываю, я могу заботиться, а могу е заботиться о возможности выполнять "позднее связывание", но я всегда забочусь естируемости приложения. Некоторые разработчики не заботятся о тестируемости, нчитают "позднее связывание" важным для разрабатываемого ими приложения.
Дублеры те ста
Это универсальная методика создания реализаций зависимостей, которые выступают ачестве заменителей реальных или планируемых реализаций. Такие реализациазываются дублерами теста, и они никогда не будут использоваться в конечнориложении. Вместо этого они служат заполнителями для реальных зависимостей, когдни недоступны или не подходят для использования.
Для дублеров теста существует законченный язык паттернов и множество подтипов такихак Stubs, Mocks и Fakes.
Пример: Модульное тестирование логики приложения "Hello"
В разделе "Код приложения "Hello DI!"" вы видели пример приложения "Hello DI".
Несмотря на то, что я сначала продемонстрировал вам конечный код, я, ействительности, разрабатывал это приложение при помощи тестирования череазработку. Листинг 1-3 демонстрирует самый важный модульный тест.
Примечание
Не волнуйтесь, если у вас нет опыта работы с модульным тестированием илинамическими mock-объектами. Они могут случайно всплывать на протяжении всениги, но ни коим образом не являются обязательными для чтения.
Листинг 1-3: Модульное тестирование класса Salutation
[Fact]
public void ExclaimWillWriteCorrectMessageToMessageWriter()
{
var writerMock = new Mock<IMessageWriter>();
var sut = new Salutation(writerMock.Object);
sut.Exclaim();
writerMock.Verify(w => w.Write("Hello DI!"));
}
Для класса Salutation требуется экземпляр интерфейса IMessageWriter, поэтому ваужно его создать. Вы могли бы использовать любую реализацию, но в модульных тестаогут быть очень полезными динамические mock-объекты – в данном случае вспользуете Moq, но могли бы использовать и другие библиотеки или вместо этогвернуть свою собственную. Важная составляющая – обеспечение реализации
IMessageWriter для конкретного теста с целью убедиться в том, что вы тестируете толькдин объект за раз; в настоящий момент вы тестируете метод Exclaim класса Salutationоэтому вы не хотите, чтобы какая-нибудь производственная реализация IMessageWriteахламляла тест.
Чтобы создать класс Salutation, вы передаете Mock-экземпляр IMessageWriter.
Поскольку writerMock – это экземпляр Mock<IMessageWriter>, свойство Object – этинамически создаваемый экземпляр IMessageWriter. Внедрение нужной зависимостосредством конструктора носит название "внедрение через конструктор".
28
После применения тестируемой системы (System Under Test (SUT)) вы можетспользовать Mock, чтобы проверить, что метод Write был вызван с корректным текстом.
При использовании Moq вы выполняете это путем вызова метода Verify, в качествараметра которого задано выражение, которое определяет то, что вы запланировали.
Если метод IMessageWriter.Write был вызван со строкой "Hello DI!", то вызов метода
Verify завершается, но если метод Write не вызывался или вызывался с другиараметром, то метод Verify выдавал бы исключение и тест бы не выполнялся.
Слабое связывание предоставляет множество преимуществ: код становится прощазрабатывать, поддерживать, расширять, и он становится более тестируемым. Слабовязывание даже не особо и сложное. Мы программируем на основании интерфейсов, а нонкретных реализаций. Единственный основной недостаток – понять, как достаткземпляры этих интерфейсов. Механизм внедрения зависимостей дает ответ на этоопрос путем внедрения зависимостей из вне. Внедрение через конструктор – этаиболее предпочтительный метод внедрения зависимостей из вне.
29
1.3. Что внедрять, а что не внедрять
Базы данных – это отличный пример типов BCL, которые являются неустойчивымависимостями: даже если LINQ to Entities – это технология, которая содержится в BCLе использование подразумевает реляционную базу данных.
В предыдущем разделе я описывал мотивационные силы, которые заставляют нас ервую очередь думать о механизме внедрения зависимостей. Если я убедил вас в томто слабое связывание – это отличная идея, то вы можете захотеть делать все слабвязанным. В целом это хорошая идея. В те моменты, когда вам нужно решить, капаковать модули, слабое связывание предоставляет особенно полезные рекомендации.
Вам не приходится все абстрагировать и делать все подключаемым. В данном разделе редоставлю вам некоторые средства, которые помогут вам принять решение о том, каоделировать ваши зависимости.
Стандартная библиот ека классов .NET (Base Class Library) состоит из множества сборок.
Каждый раз при написании кода, который использует тип из сборки стандартноиблиотеки классов, вы добавляете в ваш модуль зависимость. В предыдущем разделе ассуждал на тему того, как важно слабое связывание, и насколько программирование нсновании интерфейсов является основополагающим.
Означает ли это, что вы не можете ссылаться ни на одну из сборок стандартноиблиотеки классов и использовать их типы напрямую в приложении? Что если ваахочется применить XmlWriter, который определен в сборке System .Xm l?
Вам не приходится обрабатывать все зависимости одинаково. Многие типы стандартноиблиотеки классов можно использовать, не подвергая при этом опасности степенвязанности приложения – но не все. Важно знать, как отличать типы, которые нредставляют опасности, и типы, которые могут усилить степень связанностриложения. Сосредоточим наше внимание на последних.
Seams (Швы)
Везде, где мы решаем программировать на основании интерфейса, а не конкретного типаы вводим в приложение Seam. Seam – это место, где приложение монтируется из егоставных частей, подобно тому, как куски материи сшиваются вместе с помощью швов.
Также это место, где мы можем распаковать приложение и работать с модулямзолированно.
Пример "Hello DI", который я создавал в разделе "Hello DI", содержит Seam междлассами Salutation и ConsoleMessageWriter, как это проиллюстрировано на рисунке 1-
12. Класс Salutation не зависит напрямую от класса ConsoleMessageWriter; скорее, оспользует интерфейс IMessageWriter для записи сообщений. Вы можете разобратриложение на части в месте этого Seam и смонтировать приложение заново с другимоставителями сообщений.
Рисунок 1-12: Пример "Hello DI" из раздела "Hello DI" содержит Seam между классами
Salutation и ConsoleMessageWriter, потому что класс Salutation выполняет записолько при помощи абстракции интерфейса IMessageWriter.
30
Как только вы изучите механизм внедрения зависимостей, он поможет валассифициро вать ваши зависимости на стабильные и неустойчивые, но принятиешения о том, куда вставлять Seams вскоре станет для вас второстепенным. В
следующих разделах будут более детально обсуждаться эти понятия.
Стабильные зависимости
Многие модули в стандартной библиотеке классов и за ее пределами не представляюикакой угрозы для степени модульности приложения. Они содержат функциональностьопускающую повторное использование, которую вы можете использовать для тоготобы сделать ваш код более кратким.
Модули стандартной библиотеки классов всегда доступны в рамках вашего приложенияоскольку для его запуска необходим .NET Framework. Концепция параллельноазработки не применима к этим модулям, поскольку они уже существуют, и вы всегдожете повторно использовать стандартную библиотеку классов в других приложениях.
По умолчанию вы можете считать, что большинство (но не все) типов, определенных в
BCL в качестве безопасных или стабильных зависимостей – я называю их ст абильнымиотому что они уже присутствуют там, склонны к обратной совместимости, а их вызомеет детерминированные последствия.
Большинство стабильных зависимостей являются типами BCL, но и другие зависимостакже могут быть стабильными. Важными критериями стабильных зависимостевляются перечисленные ниже критерии:
? Класс или модуль уже существует.
? Вы считаете, что новые версии не будут содержать разрушительных изменений.
? Рассматриваемые типы содержат детерминированные алгоритмы.
? Вы никогда не думаете о том, что вам придется заменять класс или модуль на что-
то другое.
Как ни странно, DI-контейнеры сами по себе будут проявлять себя как стабильныависимости, потому что они удовлетворяют всем критериям. Когда вы решаете взять зснову вашего приложения определенный DI-контейнер, вы рискуете спотыкаться об этоыбор на протяжении всего жизненного цикла приложения; тем не менее, это еще однричина того, почему вы должны ограничить использование контейнера в C omposition
Root.
31
Другие примеры приложений могут включать в себя специализированные библиотекиоторые инкапсулируют алгоритмы, имеющие отношение к вашему приложению. Если вазрабатываете приложение, имеющее дело с химией, вы можете ссылаться на стороннюиблиотеку, которая содержит химико-специфическую функциональность.
Обычно зависимости можно считать стабильными путем исключения: они стабильнысли они не являются неустойчивыми.
Неустойчивые зависимости
Введение в приложение Seam s является дополнительно й работой, поэтому вам следуето делать только при необходимости. Может существовать более одной причинеобходимости изоляции зависимости за пределами Seam, но они тесно связаны реимуществами слабого связывания, которое обсуждалось в разделе "Преимущества DI".
Такие зависимости можно узнать по их склонности создавать препятствия для одного илольшинства из этих преимуществ. Они не стабильны, потому что они не обеспечиваюостаточное основание для приложений, и по этой причине я называю их неустойчивымависимостями. Зависимость следует считать неуст ойчивой, если соблюдается любой иледующих критериев:
? Зависимость вводит требование, согласно которому необходимо установить конфигурировать исполняющую среду для приложения. Реляционная база даннывляется архитипическим примером: если мы не скроем реляционную базу данныа Seam, мы никогда не сможем заменить ее на какую-либо другую технологию.
Это требование также усложняет процесс установки и запуска автоматизированныодульных тестов.
Базы данных – это отличный пример типов BCL, которые являются неустойчивымависимостями: даже если LINQ to Entities – это технология, которая содержится в BCLе использование подразумевает реляционную базу данных.
Другие необрабатываемые ресурсы такие, как очереди сообщений, веб-сервисы и дажайловые системы также попадают в эту категорию. Пожалуйста, отметьте, что это нами конкретные .NET типы являются неустойчивыми, но скорее то, что онодразумевают об исполняющей среде.
Признаками этого вида зависимостей является отсутствие слабого связывания асширяемости, а также невозможность тестирования.
? Зависимость еще не существует, но все еще разрабатывается. Очевидныризнаком таких зависимостей является неспособность выполнять параллельну азработку.
? Зависимость не установлена на всех машинах организации, занимающейсазработкой. Это может быть аргументом в пользу дорогих сторонних библиотели зависимостей, которые не могут устанавливаться на все операционныистемы. Наиболее универсальный признак – невозможнос ть тестирования.
? Зависимость содержит недетерминированное поведение. Это чрезвычайно важно одульных тестах, поскольку все тесты должны быть детерминированными.
Типичными источниками недетерминированности являются случайные числа лгоритмы, которые зависят от текущих даты и времени.
32
Заметьте, что такие универсальные источники недетерминированности, как
System.Random, System.Security.Cryptography.RandomNumberGenerator или
System.DateTime.Now определены в mscorlib, поэтому вам не избежать ссылки на сборку которой они определены. Тем не менее, вам следует относиться к ним, как еустойчивым зависимостям, потому что они склонны к разрушению тестируемости.
Неустойчивые зависимости являются центральным вопросом механизма внедрениависимостей. Мы вводим Seams в приложение скорее для неустойчивых зависимостейежели для стабильных. Кроме того, они обязывают нас компоновать их при помощеханизма DI.
Теперь, когда вы поняли разницу между стабильными и неустойчивыми зависимостямиы можете приступить к рассмотрению горизонтов области применения механизмнедрения зависимостей. Слабое связывание – это доминирующий принцироектирования, поэтому механизм DI (как инструмент его реализации) должен быть ашем коде повсюду. Не существует четкой границы между предметом механизмнедрения зависимостей и проектированием добротного программного обеспечения, нля того чтобы определить контекст остальной части книги, я быстро опишу, что какиопросы охватывает механизм DI.
33
1.4. Область применения DI
Как мы видели в разделе "Hello DI", важный элемент механизма внедрения зависимостей
– это вынесение различных ответственностей в отдельные классы. Одна итветственностей, которую мы выносим в классы – это задача создания экземпляроависимостей.
Как только класс уступает контроль над зависимостями, он отказывается от решениыбирать конкретные реализации. Тем не менее, как разработчики, мы приобретаеекоторые преимущества.
Примечание
Как разработчики мы приобретаем контроль путем удаления этого контроля из классовоторые применяют зависимости. Это применение принципа единст веннответственности: эти классы должны иметь дело только с их заданной областьтветственности, не беспокоясь при этом о том, как создаются зависимости.
Поначалу может показаться недостатком позволять классу отказываться от контроля наем, какие объекты создаются, но, как разработчики, мы не теряем этот контроль – мсего лишь переносим его в другое место.
Тем не менее, композиция объектов (object composition) является не единственныластом управления, который мы удаляем, поскольку класс также теряет способностонтролировать время жизни объекта. Когда в класс внедряется экземпляр зависимостиотребитель не знает, когда он был создан или когда он выйдет из области видимости. Вногих случаях это не представляет интереса для потребителя, но в некоторых случаято важно.
Механизм внедрения зависимостей дает нам возможность управлять зависимостямниверсальным способом. Когда пользователи напрямую создают и настраиваюкземпляры зависимостей, каждый из них может делать это своим собственным способомоторый может противоречить тому, как это делают остальные. Не существует способа, омощью которого мы могли бы централизованно управлять зависимостями, а такжпособа, при помощи которого мы бы с легкостью обращались к сквозным концепциям.
Благодаря механизму DI мы приобретаем возможность перехватывать каждый экземпляависимости и влиять на него до того, как он будет передан пользователю.
Благодаря механизму внедрения зависимостей мы можем компоновать приложения время перехватывания зависимостей и контролирования их жизненного цикла.
Композиция объектов, механизм перехвата и управление жизненным циклом – это трспекта механизма внедрения зависимостей. Далее я вкратце раскрою эти аспекты; болеетальное описание приводится в части 3 этой книги.
Композиция объектов
Чтобы воспользоваться результатами таких преимуществ, как расширяемость, поздневязывание и параллельная разработка, мы должны уметь компоновать классы риложениях (см. рисунок 1-13). Такая композиция объектов часто является самолавной мотивацией для введения в приложение механизма внедрения зависимостей.
Первоначально механизм DI был синонимичен композиции объектов; это единственный
34
аспект, обсуждаемый в оригинальной статье Мартина Фаулера относительно этогопроса.
Рисунок 1-13: Композиция объектов означает, что модули в приложениях можномпоновать.
Существует несколько способов, с помощью которых мы можем компоновать классы риложении. Когда я рассматривал позднее связывание, я использовал конфигурационныайл и несколько реализаций динамических объектов для того, чтобы вручнукомпоновать приложение из доступных модулей, но я также мог использовать ехнологию конфигурирования в коде или DI-контейнер. Мы вернемся к этим вопросам лаве 7.
Несмотря на то, что первоначальное значение механизма внедрения зависимостей теснвязано с композицией объектов, остальные аспекты также оказались уместными.
Жизненный цикл объектов
Класс, который отдает контроль над своими зависимостями, отказывается не просто оозможности выбирать определенные реализации абстракций. Он также отказывается и оозможности контроля над тем, когда создаются экземпляр ы зависимостей, и когда оныходят за рамки области применения механизма DI.
В .NET о большинстве из этих вещей заботится за нас Garbage Collector. Пользователожет иметь внедренные в класс зависимости и использовать их настолько долгоасколько того требует класс. Когда это происходит, зависимости выходят за рамкбласти применения механизма DI. Если на эти зависимости не ссылается больше ни одиласс, то они как раз подходят для "сборки мусора" (garbage collection).
Что если два пользователя используют один и тот же вид зависимостей? Рисунок 1-14
иллюстрирует тот факт, что мы можем выбрать вариант внедрения отдельного экземплярля каждого пользователя, тогда как рисунок 1-15 демонстрирует, что мы можем наобороыбрать вариант, при котором единственный экземпляр будет совместно использоватьсесколькими пользователями. Тем не менее, с точки зрения пользователей между этимариантами нет никакой разницы. Согласно принципу замещения Лисков пользователолжен одинаково воспринимать все экземпляры данного интерфейса.
Рисунок 1-14: Для каждого из пользователей, совместно использующих один и тот же тиависимостей, внедряется свой собственный приватный экземпляр.
35
Рисунок 1-15: индивидуа льных пользователей, совместно использующих один и тот жип зависимостей, внедряется один и тот же экземпляр.
Поскольку зависимости могут использоваться несколькими пользователямдновременно, единичный пользователь, вероятно, не может управлять их жизненныиклом. Поскольку управляемый объект может выходить за рамки области применениеханизма DI и может быть удален сборщиком мусора (garbage collector), это не слишкоажно, но когда зависимости реализуют интерфейс IDisposable, все становится намногложнее.
В целом управление жизненным циклом является отдельным аспектом механизмнедрения зависимостей и настолько важным, что я выделил для него всю главу 8.
Отказ от контроля над зависимостью также означает отказ от контроля над ее жизненныиклом; нечто, находящееся выше в стеке вызовов, должно управлять жизненным циклоависимости.
Перехват
Когда мы делегируем контроль над зависимостями стороннему компоненту, как этемонстрирует рисунок 1-16, мы также приобретаем возможность модифицировать этависимости до того, как мы передадим их в классы, которые используют этависимости.
Рисунок 1-16: Вместо того, чтобы внедрять первоначально запланированныависимости, мы можем модифицировать эти зависимости посредством упаковывания и другой класс до того, как передать их пользователю. Пунктирная стрелка указывает направление действия – направление зависимости идет в обратном направлении.
36
В примере "Hello DI" я первоначально внедрял экземпляр ConsoleMessageWriter в класс
Salutation. Затем, модифицируя пример, я добавил возможность обеспечениезопасности путем создания нового SecureMessageWriter, который всего лишелегирует дальнейшу ю работу ConsoleMessageWriter при аутентификациользователя. Это позволяет нам поддерживать принцип единственной ответст венности.
Это возможно сделать, потому что мы всегда программируем на основании интерфейсов;
помните, что эти зависимости всегда должны быть абстракциями. Что касается класса
Salutation, то он не заботится о том, является ли используемый IMessageWriteкземпляром ConsoleMessageWriter или SecureMessageWriter. SecureMessageWriteожет упаковывать ConsoleMessageWriter, который, однако, выполняет реальнуаботу.
Примечание
Перехват – это применение паттерна проектирования Decorator. Не переживайте, если вае знаком паттерн проектирования Decorator – в главе 9 я предоставлю вам повторныурс, который всецело посвящен механизму перехвата.
Такие возможности перехвата переносят нас прямиком к аспектно-ориентированномрограммированию (Aspect-Oriented Program ming) – тесно связанная с механизмонедрения зависимостей тема, которая, тем не менее, выходит за пределы этой книги.
Благодаря механизму перехвата мы можем применять такие сквозные механизмы, кавторизация, контрольные проверки, управление доступом, валидация и т.д. в хороштруктурированной манере, которая позволяет нам поддерживать концепцию разделения.
Механизм DI с точки зрения трех аспектов
Несмотря на то, что механизм внедрения зависимостей был задуман как набор паттерновелью которых было решение проблемы композиции объектов, этот термин был альнейшем расширен и теперь также охватывает такие понятия, как жизненный цикбъектов и механизм перехвата. На сегодняшний момент я считаю, что механизм DI
логично заключает в себе все три аспекта.
Композиция объектов доминирует среди этих трех аспектов, поскольку без гибкоомпозиции объектов не было бы ни механизма перехвата, ни необходимости управлятизненным циклом объектов. Композиция объектов доминировала на протяжении
37
большей части этой главы и будет продолжать доминировать на протяжении всеставшейся книги, но мы не должны забывать об остальных аспектах. Композицибъектов предоставляет фундамент, а механизм управления жизненным циклобращается к некоторым важным побочным эффектам, но пожинать плоды преимущестеханизма внедрения зависимостей мы начинаем, главным образом, когда переходим еханизму перехвата.
В части 3 я посвятил каждую главу отдельному аспекту, но в данной главе я предоставибзор этих аспектов, поскольку важно знать, что на практике механизм внедрениависимостей – это больше, чем просто композиция объектов.
38
1.5. Резюме
Механизм внедрения зависимостей по своей природе является средством достижениезультата, а не целью. Это самый лучший способ разрешения слабого связыванияажной составляющей поддерживаемого кода. Преимущества, которые мы можеаполучить благодаря слабому связыванию, не всегда тотчас же очевидны, но становятсаметными с течением времени, когда возрастает сложность кода. Сильно связанный код конце концов, выродится в "спагетти-код" (Spaghetti Code), между тем, как хорошконструированный, слабо связанный код может оставаться поддерживаемым. Для тогтобы достичь поистине "гибкого проектирования" (Supply Design), нужно не простлабое связывание, но программирование на основании интерфейса являетсеобходимым условием "гибкого проектирования".
Механизм DI – это больше, чем просто набор принципов и паттернов. Это, скорее, спосоридумывания и конструирования кода, нежели средства и приемы – важный пунклабого связывания, это и есть механизм внедрения зависимостей, и для эффективностн должен присутствовать в вашем коде повсюду.
Подсказка
Механизм внедрения зависимостей должен быть доминирующим. Вы не можете егкостью подстраивать слабое связывание под существующий код.
Существует множество моментов неправильного понимания механизма DI. Некоторыюди думают, что он касается только таких узких проблем, как позднее связывание илодульное тестирование; несмотря на то, что эти аспекты проектирования программногбеспечения, безусловно, извлекают пользу из механизма внедрения зависимостейбласть его применения намного шире. Абсолютной целью механизма внедрениависимостей является удобство сопровождения кода.
В начале главы я утверждал, что вы должны забыть все, что вы знали до этого еханизме внедрения зависимостей. Это остается справедливым и для всей оставшейсасти книги: вы должны очистить свой разум. В потрясающей публикации блога Николас
Блумхардт пишет:
Словарь и ассоциативный массив – это одни из перв ых конструкций, о которых мы узнаем при разработкрограмм ного обеспечения. Легко увидеть аналогию между словарем и IoC-контейнером, которыомпонует объекты посредством испол ьзования механизма внедрения зав исимостей.
Понимание механизма внедрения зависимостей как сервиса, смоделированного нсновании строк словаря, напрямую ведет к анти-паттерну Service Locator. Вот поэтому ак много акцентировал ваше внимание на необходимости очистить ваш разум даже оамых основных предположений. В конце концов, говоря о словарях, мы говорим о некоубстанции, которая принадлежит к "раболепному разуму программирования".
Цель механизма DI – сделать код поддерживаемым. Небольшие по размеру базы кодаодобные примеру "Hello World", являются по существу поддерживаемыми благодарвоему размеру; вот поэтому механизм внедрения зависимостей воспринимается ростых примерах как лишняя разработка. Чем больше по размеру становится база кодаем более видимыми становятся преимущества механизма внедрения зависимостей. Я
39
посвятил следующу ю главу более значительному и сложному примеру для того, чтобродемонстрировать эти преимущества.
40
2. Комплексный пример
Меню:
? Комплексный пример
? Как не стоит поступать
? Как действовать правильно
Сообщение о том, что беарнский соус – это "эмульсионный соус, приготовленный иичного желтка и масла", не привьет вам способность готовить этот соус. Самый лучшипособ обучения – это практика; пример часто может преодолеть разрыв между теорией рактикой. Полезно понаблюдать за тем, как профессиональный повар готовит беарнскиоус, перед тем, как попытаться приготовить его самостоятельно.
Когда я знакомил вас в предыдущей главе с механизмом внедрения зависимостей, редоставил вам высококлассный обзор для того, чтобы вы поняли его цель и основныринципы. Тем не менее, с помощью этого примера нельзя по достоинству оценить DI.
Механизм внедрения зависимостей – это способ разрешения слабого связывания, а слабовязывание – это первый и самый главный эффективный способ справиться сложностью.
Большинство программного обеспечения является сложным в том плане, что ему нужнбращаться ко многим сущностям одновременно. Помимо бизнес-сущностей (которыами по себе могут быть сложными), программное обеспечение должно также обращатьс сущностям, связанным с вопросами обеспечения безопасности, диагностики, операций асширяемости. Вместо того обращения ко всем этим сущностям в одном большом комкелабое связывание позволяет нам обращаться к каждой сущности по отдельности. Прощбращаться к каждой сущности изолированно – но, в конечном счете, мы все еще должномпоновать этот сложный набор сущностей. Давайте рассмотрим сложный пример длого, чтобы лучше продемонстрировать механизм внедрения зависимостей.
Предупреждение
Весь смысл слабо связанного кода – борьба со сложностью эффективным способом, и наеобходимы комплексные примеры для того, чтобы проиллюстрировать сложныущности. Должно быть, вы предполагаете, что большинство примеров в этой книгвляются сложными, и в них входят составные классы из составных библиотек.
Сложность – это часть игры.
Я посвятил всю эту главу сложному примеру. Думаю, что это важно – сравнить слабвязанный код с более "традиционным", сильно связанным примером, поэтому в этолаве вы найдете одну и ту же возможность, реализованную двумя способами. Сначала одготавливаю почву, демонстрируя, как легко писать сильно связанный код. Затем еализую ту же функциональность при помощи механизма внедрения зависимостей. Вожете пропустить пример сильно связанного кода, если хотите прямо сейчас увидетекоторый слабо связанный код. После прочтения этой главы вы должны уже начатонимать, как можно использовать DI для того, чтобы создавать слабо связанный код.
Рисунок 2-1: Эта глава содержит две разновидности одного и того же примера. Сначалы увидите, как легко писать сильно связанный код. Затем вы увидите, как писать то жамое приложение при помощи слабо связанного кода. Оба примера содержат как сам
41
пример, так и его анализ. Если вы хотите прямо сейчас увидеть слабо связанный код, ты можете пропустить первый раздел.
2.1. Как не стоит поступать
2.2. Как действовать правильно
2.3. Расширение шаблонного приложения
2.4. Резюме
42
2.1. Как не стоит поступать
Сама идея создания слабо связанного кода не является чрезвычайно противоречивой, нуществует огромный разрыв между намерением и практикой. Перед тем как показатам, как использовать механизм внедрения зависимостей для создания слабо связанныриложений, я хочу продемонстрировать вам, как легко все может пойти неправильныутем.
Общепринятой попыткой использования слабо связанного кода является созданиногоуровневого приложения. Всякий может нарисовать схему трехуровневогриложения, и рисунок 2-2 доказывает, что я тоже могу это сделать.
Рисунок 2-2: Стандартная архитектура трехуровневого приложения. Это самая простабщепринятая разновидность архитектуры n-уровневого приложения, где приложениостоит из n-уровней, каждый из которых состоит из одного или более одного модуля.
Некоторые разновидности n-уровневых схем будут иметь вертикальные блоки, которыбозначают уровни составного приложения. Такие схемы часто используются длредставления таких сквозных сущностей, как обеспечение безопасности и вход истему.
Создание трехуровневой схемы является обманчиво простым процессом, но самисование схемы похоже на утверждение о том, что у вас будет беарнский соус обственным стейком: это объявление намерения, которое не дает никаких гарантитносительно окончательного результата. У вас может получиться и что-то другое, как вами это скоро увидите.
Создание сильно связанного приложения
Существует более одного способа просмотра и проектирования гибкого оддерживаемого сложного приложения, но архитектура n-уровневого приложенисновывается на хорошо известном, практически опробованном подходе. Проблема в томтобы реализовать его корректно.
Вооружившись трехуровневой схемой, подобной той, что продемонстрирована на рисунке
2-2, вы можете приступить к созданию приложения.
43
Знакомство с Мэри Роуэн
Мэри Роуэн – профессиональный .NET разработчик, работающая на местногертифицированного партнера компании Microsoft, который, в основном, занимаетсазработкой веб-приложений. Ей 34 и с программным обеспечением она работает уже 11
лет. Это делает ее одним из самых опытных разработчиков компании, и она частыступает в роли наставника для младших разработчиков в дополнение к выполнению еегулярных обязанностей в качестве старшего разработчика.
В целом Мэри получает удовольствие от своей работы, но ее расстраивает то, чтсновные этапы работы зачастую пропускаются, и это вынуждает ее и ее коллег работат течение многих часов и недель, чтобы успеть выполнить все в срок. Она полагает, чтолжны существовать более эффективные способы создания программного обеспечения.
Стремясь узнать больше информации об эффективности, она покупает множество книг программированию – но у нее редко есть время на их прочтение.
Большинство своего свободного времени она тратит на мужа и двух дочерей. Мэри любианиматься восхождением в горы. К тому же она увлеченный повар и уж точно знает, кариготовить настоящий беарнский соус.
Мэри попросили создать новое приложение электронной коммерции на платформе
ASP.NET MVC и Entity Framework с SQL Server, используемым в качестве хранилищанных. Для того чтобы максимально увеличить модульность, это приложение должныть трехуровневым.
Первой реализованной возможностью должен быть простой список рекомендуемыоваров, который вытаскивается из таблицы базы данных и отображается на веб-странице;
пример продемонстрирован на рисунке 2-3. Если список просматриваеривилегированный пользователь, то цена всех товаров должна быть снижена на 5
процентов.
Рисунок 2-3: Скриншот веб-приложения электронной коммерции, которое попросилоздать Мэри. На нем изображен простой список рекомендуемых товаров и их цен ("kr." –
это буквенный символ валюты для датских крон)
44
Давайте подсмотрим, как Мэри реализует первую возможность приложения.
Уровень данных
Поскольку Мэри нужно вытаскивать данные из таблицы базы данных, она решила начат реализации уровня данных. Первый шаг – определить саму таблицу базы данных. Длоздания таблицы, продемонстрированно й на рисунке 2-4, Мэри использует SQL Server
Management Studio.
Рисунок 2-4: Мэри создает таблицу Product при помощи SQL Server Management Studio;
альтернативные подходы включают написание T-SQL скрипта, или создание таблицы омощью Visual Studio или с помощью каких-либо других средств
Для реализации уровня "Data Access Layer" (уровень доступа к данным) Мэри добавляет вое решение новую библиотеку. В Visual Studio она использует мастер Entity Data Model
Wizard для того, чтобы сгенерировать целостную модель сущностей из базы данныхоторую она ранее создала. Чтобы завершить оформление модели, она изменяеесколько названий, как это показано на рисунке 2-5.
Рисунок 2-5: Сущность Product, которая сгенерирована из таблицы базы данных
Product, продемонстрированной на рисунке 2-4. Мэри изменила название столбца
Featured на IsFeatured, а также изменила несколько названий в сгенерированном
ObjectContext (не продемонстрировано).
45
Примечание
Не стоит волноваться, если вы не знакомы с Microsoft Entity Framework. Подробнанформация о реализации доступа к данным в данном контексте не является важнойоэтому вам нужно всего лишь суметь последовать данному примеру, даже если вы боленакомы с другой технологией доступа к данным.
Сгенерированные сущности ObjectContext и Product – это открытые типы, которыаходятся в пределах одной и той же сборки. Мэри знает, что в дальнейшем ей нужнудет добавить в приложение больше возможностей, но добавление компонента доступа анным, который необходим для реализации первой возможности, на этом завершено.
Рисунок 2-6 демонстрирует, как далеко Мэри зашла в реализации многоуровневорхитектуры, которая была представлена на рисунке 2-2.
Рисунок 2-6: До настоящего времени Мэри реализовывала уровень "Data Access Layer"
(уровень доступа к данным) своего приложения. Уровни "Domain Logic Layer" (уровеноменной логики) и "User Interface Layer" (уровень пользовательского интерфейса)
отодвинуты на второй план до тех пор, пока не будет реализована первая возможность.
Теперь, когда уровень доступа к данным реализован, следующий логичный шаг –
реализация уровня доменной логики.
Доменный уровень
При отсутствии какой-либо доменной логики список товаров, предоставляемых омощью сгенерированного ObjectContext, формально мог использоваться напрямую нровне пользовательского интерфейса.
Предупреждение
За исключением простых приложений, содержащих отчеты, в приложениях всегдрисутствует доменная логика. Сначала вы можете и не понять ее, но как только вачнете узнавать предметную область приложения, его вложенные и скрытые правила редположения постепенно всплывут. Реализация данной логики на уровнользовательского интерфейса или на уровне доступа к данным приведет к печальныоследствиям. Окажите себе честь и создайте сначала уровень доменной логики.
46
В требованиях к приложению Мэри говорится, что для привилегированных пользователеолжен отображаться список цен с пятипроцентной скидкой. Мэри еще не поняла, кадентифицировать привилегированного пользователя, поэтому она попросила совета воего коллеги Дженса:
Мэри: Мне нужно реализоват ь эту бизнес-логику так, чт обы привилегированныользователь получал пят ипроцент ную скидку.
Дженс: Звучит легко. Просто умножь на 0,95.
Мэри: Спасибо, но я не об эт ом хот ела тебя спросит ь. Я хотела спросить, как мнледует идентифицировать привилегированного пользователя?
Дженс: Понятно. У т ебя веб-приложение или настольное приложение?
Мэри: Веб-приложение.
Дженс: Ясно, т огда т ы можеш ь определить профиль пользователя и использоватвойство IsPreferredCustomer. Ты можешь получит ь профиль через HttpContext.
Мэри: Прит ормози-ка, Дженс. Этот код должен быть на уровне доменной логики. Этиблиот ека. Нет никакого HttpContext.
Дженс: О… (некот орое время думает). Я все еще считаю, что тебе нужно использоват озможност ь Profile ASP.NET для поиска значения по пользоват елю. Ты можешь потоередат ь значение в т вою доменную логику как булево.
Мэри: Я не знаю…
Дженс: Это ещ е и даст т ебе уверенность в т ом, чт о т ы следуешь концепциазделения, пот ому чт о доменной логике не приходит ся иметь дело с обеспечениеезопасност и. Сама знаеш ь: Принцип единичной ответственности! Это самыыст рый способ дост ижения эт ого!
Мэри: Думаю, т ы прав.
Предупреждение
Дженс базировал свой совет на своем техническом знании ASP.NET. Как толькбсуждение вывело его из его же комфортной зоны, он стал отбиваться от Мэри промощи тройной комбинации умных словечек. Знайте, что он не знает, о чем говорит: оеправильно использует концепцию разделения понятий, абсолютно неправильнспользует принцип единичной ответственности, и он упоминает о том, что это самыыстрый способ, только потому что недавно слышал, как кто-то еще с энтузиазмооворил об этом.
Вооружившись советом Дженса, Мэри создает новый проект библиотеки C# и добавляеласс с названием ProductService, который продемонстрирован в листинге ниже. Длого чтобы сделать класс ProductService компилируемым, она должна добавить ссылка свою библиотеку Data Access, поскольку там определен класс CommerceObjectContext.
47
Листинг 2-1: Класс ProductService, добавленный Мэрublic partial class ProductService
{
private readonly CommerceObjectContext objectContext;
public ProductService()
{
this.objectContext = new CommerceObjectContext();
}
public IEnumerable<Product> GetFeaturedProducts(bool isCustomerPreferred)
{
var discount = isCustomerPreferred ? .95m : 1;
var products = (from p in this.objectContext.Producthere p.IsFeatureelect p).AsEnumerable();
return from p in productelect new Product
{
ProductId = p.ProductId,
Name = p.Name,
Description = p.Description,
IsFeatured = p.IsFeatured,
UnitPrice = p.UnitPrice * discount
};
}
}
Мэри счастлива, что смогла инкапсулировать технологию доступа к данным (LINQ to
Entities), конфигурацию и доменную логику в классе ProductService. Она делегировалнания о пользователе вызывающему оператору путем передачи параметра sCustomerPreferred, и использует это значение для расчета скидки для всех товаров.
Дальнейшая обработка могла бы включать замену жестко-зако дированного значеникидки (0,95) на настраиваемое число, но на данный момент такой реализациостаточно. Мэри почти все сделала – остался только пользовательский интерфейс. Мэрешила, что это может подождать до следующего дня.
Рисунок 2-7 демонстрирует, как далеко Мэри зашла в реализации архитектурыредставленной на рисунке 2-2.
Рисунок 2-7: На данном этапе Мэри реализовала уровень доступа к данным и уровеноменной логики. Если сравнивать с рисунком 2-6, то здесь добавлен уровень доменноогики. Уровень пользовательского интерфейса все еще остается не реализованным
48
После реализации уровня доступа к данным и уровня доменной логики остаетсеализовать только уровень пользовательского интерфейса.
Уровень пользовательского интерфейса
На следующий день Мэри возобновляет свою работу над приложением электроннооммерции, добавляя новое ASP.NET MVC приложение в свое решение.
Примечание
Не стоит волноваться, если вы не знакомы с фреймворком ASP.NET MVC. Запутанныетали того, как функционирует MVC framework, не рассматриваются в этой книге.
Важной составляющей является то, как используются зависимости, а это относительнейтральная тема.
Ускоренный курс по ASP.NET MVC
ASP.NET MVC берет свое название от паттерна проектирования Model View Controller. В
данном контексте самое важное, что необходимо понять, – это то, что, когда поступаееб-запрос, контроллер управляет этим запросом, потенциально используя модель
(доменную) для того, чтобы затронуть этот запрос и сформировать ответ, который, онце концов, отображается с помощью представления.
Контроллер – это обычно класс, который наследуется от абстрактного класса Controller.
У него есть один или более одного метода действия, которые управляют запросамиапример. Класс HomeController обладает методом Index, который управляет запросотраницы, отображаемой по умолчанию.
При возврате метода действия он передает итоговую модель в представление посредствокземпляра ViewResult.
Следующий листинг демонстрирует, как Мэри реализует метод Index класса
HomeController для того, чтобы извлечь обработанные товары из базы данных и передатх в представление. Для того чтобы сделать этот код компилируемым, ей нужно добавитсылки как на библиотеку Data Access, так и на библиотеку Domain, поскольку класс
ProductService определен в библиотеке Domain, а класс Product определен в библиотеке
Data Access.
Листинг 2-2: Метод Index в используемом по умолчанию классе контроллерublic ViewResult Index()
{
bool isPreferredCustomer = this.User.IsInRole("PreferredCustomer");
var service = new ProductService();
var products = service.GetFeaturedProducts(isPreferredCustomer);
this.ViewData["Products"] = products;
return this.View();
}
Являясь частью жизненного цикла ASP.NET MVC, свойство User класса HomeControlleвтоматически заполняется корректным объектом пользователя, поэтому М эри используего для того, чтобы определить, является ли текущий пользователь привилегированным.
49
Вооружившись этой информацией, она может вызвать доменную логику, чтобы получитписок рекомендуемых товаров. Через некоторое время я вернусь к этому моментуотому что здесь есть ловушка, но сейчас я позволю Мэри обнаружить эту ошибкамостоятельно.
Список товаров должен отображаться с помощью представления Index. Следующиистинг демонстрирует разметку для этого представления.
Листинг 2-3: Разметка представления Index
1. <h2>Featured Products</h2>
2. <div>
3. <% var products = (IEnumerable<Product>)this.ViewData["Products"];
4. foreach (var product in products)
5. { %>
6. <div>
7. <%= this.Html.Encode(product.Name) %>
8. (<%= this.Html.Encode(product.UnitPrice.ToString("C")) %>)
9. </div>
10. <% } %>
11. </div>
Строка 3: Получает товары, заполненные при помощи контроллера
ASP.NET MVC позволяет вам писать стандартный HTML-код с фрагментаммперативного кода, который вставляется для получения доступа к объектам, созданны переданным контроллером, который создал представление. В данном случае метод
Index класса HomeController передал список рекомендуемых товаров ключу с названием
Products, который Мэри использует в представлении для того, чтобы отображать списооваров.
Рисунок 2-8 демонстрирует, как Мэри реализовала архитектуры, показанную на рисунке
2-2.
Рисунок 2-8: На данный момент Мэри реализовала все три уровня приложения. Этоисунок идентичен рисунку 2-2, но повторяется здесь для того, чтобы проиллюстрироватекущее состояние приложения Мэри.
50
Когда все три уровня находятся на своих местах, теоретически приложения должнаботать, но только тест может проверить, действительно ли они работают.
Дымовой тест (Smoke test)
На данный момент Мэри реализовала все три уровня, поэтому пришло время понятьаботает ли приложение. Она нажимает клавишу F5 и вскоре получает сообщение:
Указанное именованное соединение либо не найдено в конфигурации, либо нредназначено для использования в рамках EntityClient провайдера, либо не валидно.
Поскольку Мэри использовала конструктор по умолчанию CommerceObjectContext
(продемонстрированный в листинге 2-1), то по смыслу ожидается, что строка соединениод названием CommerceObjectContext присутствует в файле web.config. Как я поминал в обсуждении листинга 2-2, эта имплицитность содержит в себе ловушку. Зочь Мэри забыла детали реализации ее доменного уровня. Код компилируется, но сайе работает.
В этом случае фиксирование ошибки является прямолинейным. Мэри вставляеорректную строку соединения в файл web.config. При запуске приложения появляетсродемонстрированная на рисунке 2-3 страница.
Возможность "Рекомендуемые товары" на данный момент реализована, и Мэри чувствуе себе уверенность и готовность реализовывать следующу ю возможность приложения. В
конце концов, она последовала доказанным оптимальным методам и создалрехуровневое приложение.
Анализ
Удалось ли Мэри создать совершенное, многоуровневое приложение? Нет, не удалось –
несмотря на то, что у нее наверняка были самые наилучшие намерения. Она создала три
Visual Studio проекта, которые соответствуют трем уровням запланированно рхитектуры, что продемонстрировано на рисунке 2-9. Для обычного наблюдателя такаеализация похожа на желаемую архитектуру, но как вы увидите, такой код являетсильно связанным.
Рисунок 2-9: В вэб-приложении электронной коммерции, созданном Мэри, присутствуео одному Visual Studio проекту для каждого уровня запланированно й архитектуры – нвляется ли оно трехуровневым?
Visual Studio делает такой способ работы с решениями и проектами более простым стественным. Если нам нужна функциональность из разных библиотек, то мы можем егкостью добавить ссылку на нее и написать код, который создаст новые экземпляры
51
типов, определенных в этих библиотеках. Каждый раз при добавлении ссылки мспользуем зависимость.
Диаграмма зависимосте й
При работе с решениями в Visual Studio очень легко потерять путь перемещения важныависимостей, поскольку Visual Studio показывает их вместе со всеми остальнымсылками проекта, которые могут указывать на сборки стандартной библиотеки классов
.NET (BCL).
Для того чтобы понять, как модули приложения Мэри соотносятся друг с другом, можем нарисовать диаграмму зависимостей (см. рисунок 2-10).
Рисунок 2-10: Диаграмма зависимостей приложения Мэри, показывающая, какибразом модули зависят друг от друга. Стрелки указывают на зависимость модуля
Самым примечательным знанием, полученным из рисунка 2-10, является то, чтиблиотека пользовательского интерфейса (User Interface library) зависит как от доменноиблиотеки (Domain library), так и от библиотеки доступа к данным (Data Access library).
Кажется, что пользовательский интерфейс может обходиться в некоторых случаях беоменного уровня. Это предположение несет за собой дальнейшие исследования.
Анализ композиции
Главная цель создания трехуровневого приложения – разделить сущности. Нам ботелось отделить нашу доменную модель от уровня доступа к данным и уровнользовательского интерфейса таким образом, чтобы ни одна из этих сущностей насоряла доменную модель. Для больших приложений существенной являетсозможность работы с одной областью изолированно.
Для того чтобы оценить реализацию Мэри, мы можем задать простой вопрос:
Тест
Возможно ли использовать каждый модуль в изоляции от других модулей?
Теоретически мы должны иметь возможность компоновать модули так, как нам хочется.
Возможно, нам понадобится написать новые модули для того, чтобы связывать
52
существующие модули вместе новыми и неожиданными способами, но в идеале, молжны иметь возможность делать это без необходимости модифицироватуществующие модули.
Примечание
Следующий анализ рассматривает вопрос того, можно ли заменять модули, но знайте, чтто методика, которую мы используем для анализа композиции. Даже если нам никогда нужно будет заменять модули, этот вид анализа раскрывает потенциальные вопросыасающиеся связывания. Если мы обнаружим, что код сильно связан, то все преимуществлабого связывания будут утеряны.
Можем ли мы использовать модули приложения Мэри новыми и увлекательнымпособами? Давайте рассмотрим некоторые возможные сценарии.
Новый пользовательский интерфейс
Если приложение Мэри будет иметь успех, то заинтересованные стороны проекта захотяттобы она разработала полную клиентску ю версию в системе построения клиентскириложений Windows – Windows Presentation Foundation (W PF). Возможно ли это сделато время повторного использования доменного уровня и уровня доступа к данным?
При рассмотрении диаграммы зависимостей на рисунке 2-10 мы можем быстрпределить, что ни один из модулей не зависит от пользовательского веб-интерфейсаоэтому можно удалить его и заменить на WPF пользовательский интерфейс.
Создание полной клиентской версии на базе WPF – это новое приложение, котороспользует большинство своих реализаций совместно с первоначальным веб-
приложением. Рисунок 2-11 иллюстрирует, как WPF приложению может понадобитьсспользовать те же самые зависимости, что и веб-приложение. Первоначальное веб-
приложение может оставаться неизмененным.
Рисунок 2-11: Замена пользовательского веб-интерфейса пользовательским WPF
интерфейсом возможна, так как ни один из модулей не зависит от пользовательского веб-
интерфейса. Первоначальный пользовательский веб-интерфейс на рисунке остаетсыделенным серым цветом для того, чтобы проиллюстрировать, что добавление новогользовательского интерфейса не исключает первоначальный пользовательскинтерфейс
Замена уровня пользовательского интерфейса наверняка возможна в реализации Мэриоэтому давайте рассмотрим еще одну интересную декомпозицию.
53
Новый уровень доступа к данным
Представьте себе, что рыночные аналитики поймут, что для оптимизации прибылриложение Мэри должно быть доступным в виде облачного приложения, размещеннога W indows Azure. В Windows Azure данные могут храниться в весьма масштабируемоервисе Azure Table Storage Service. Этот механизм хранения данных основан на гибкиata-контейнерах, которые содержат не свободные данные. Сервис не навязывает никакоонкретной схемы базы данных, и отсутствует соответствующая целостность.
Протокол, используемый для взаимодействия с Table Storage Service, – это HTTP, аиболее очевидная .NET технология доступа к данным основывается на ADO.NET Data
Services.
Такой тип базы данных иногда называют базы данных ключ-значение, и это несколькругой зверь, нежели реляционная база данных, доступ к которой осуществляетсосредством Entity Framework.
Чтобы дать возможность использовать приложение электронной коммерции в видблачного приложения, библиотеку доступа к данным можно заменить модулем, которыспользует Table Storage Service. Возможно ли это?
Из диаграммы зависимостей рисунка 2-10 мы уже знаем, что и библиотекользовательского интерфейса, и доменная библиотека зависят от библиотеки доступа анным, которая базируется на Entity Framework. Если мы попытаемся удалитиблиотеку доступа к данным, то решение больше не будет компилироваться, поскольктсутствует необходимая зависимость.
В большом приложении, состоящем из дюжины модулей, мы также могли бы попытатьсдалить те модули, которые не компилируются, чтобы увидеть, что останется. Чтасается приложения Мэри, то здесь очевидно, что нам пришлось бы удалить все модулиичего при этом не оставляя.
Несмотря на то, что можно было бы разработать библиотеку Azure Table Data Accessоторая имитирует API, используемое первоначальной библиотекой доступа к даннымет ни одного способа, с помощью которого мы бы могли внедрить ее в приложение.
Приложение еще не настолько компонуемо, насколько того хотели бы заинтересованнытороны. Для разрешения облачных возможностей, которые максимально увеличиваюрибыль, необходимо значительно переписать приложение, поскольку ни один иуществующих модулей нельзя использовать повторно.
Рисунок 2-12: Попытка удаления реляционной библиотеки доступа к данным приводит ому, что ничего не остается, потому что все остальные модули зависят от нее. Нет ндного места, где мы могли дать доменной библиотеке указание использовать новуиблиотеку Azure Table Data Access вместо первоначально используемой
54
Другие комбинации
Мы могли бы проанализировать приложение на возможность других комбинаций модуляо это было бы спорным вопросом, поскольку мы уже знаем, что они не поддерживаюажный сценарий.
Кроме того, не все комбинации имеют смысл. Мы могли бы поинтересоваться, можно ламенить доменную модель другой реализацией. В большинстве случаев это было бтранным вопросом, потому что доменная модель инкапсулирует сердце приложения. Беоменной модели большинство приложений не имеют оснований для существования.
Анализ
Почему реализация Мэри не достигла желаемой степени компоновки? Не произошло лто, потому что пользовательский интерфейс напрямую зависит от библиотеки доступа анным? Давайте исследуем эту возможность более подробно.
Анализ диаграммы зависимостей
Почему пользовательский интерфейс зависит от библиотеки доступа к данным?
Виновником этого является сигнатура метода данной доменной модели:
public IEnumerable<Product> GetFeaturedProducts(bool isCustomerPreferred)
Product: Раскрывает тип доступа к данным для клиентов
Метод GetFeaturedProducts возвращает последовательность товаров, но класс Producпределен в библиотеке доступа к данным. Любой клиент, использующий метод
GetFeaturedProducts должен ссылаться на библиотеку доступа к данным длозможности компиляции.
Можно изменить сигнатуру метода так, чтобы возвращалась последовательность типовпределенных в доменной модели. Такой подход был бы еще и более корректным, но эте решает имеющуюся проблему.
Давайте предположим, что мы разрушаем зависимость между библиотекоользовательского интерфейса и библиотекой доступа к данным. Измененная диаграммависимостей выглядела бы сейчас так, как показано на рисунке 2-13.
55
Рисунок 2-13: Диаграмма зависимостей гипотетической ситуации, при котороазрывается зависимость пользовательского интерфейса от библиотеки доступа к данным
Позволило бы Мэри такое изменение заменить реляционную библиотеку доступа анным такой библиотекой, которая инкапсулирует доступ к сервису Azure Table? К
несчастью, не позволило бы, поскольку доменная библиотека все еще зависит оиблиотеки доступа к данным. Пользовательский интерфейс, в свою очередь, все ещависит от доменной модели, поэтому если мы попытаемся удалить первоначальнуиблиотеку доступа к данным, то в приложении ничего не останется.
Основная причина этой проблемы находится где-то в другом месте.
Анализ интерфейса доступа к данным
Доменная модель зависит от библиотеки доступа к данным, поскольку вся модель данныпределена в этой библиотеке. Класс Product был сгенерирован, когда Мэри запускаластер LINQ to Entities. Использование Entity Framework для реализации уровня доступа анным может стать разумным решением.
Как бы то ни было, не используйте его напрямую в доменной модели.
Код, являющийся виновником возникшей проблемы, разбросан по классу
ProductService. Конструктор создает новый экземпляр класса CommerceObjectContext ередает его в приватную переменную члена класса:
this.objectContext = new CommerceObjectContext();
Такой подход сильно связывает класс ProductService с библиотекой доступа к данным.
Не существует разумного способа, с помощью которого мы могли бы перехватить эторагмент кода и заменить его чем-то еще. Ссылка на библиотеку доступа к данныестко закодирована в классе ProductService.
Реализация метода GetFeaturedProducts использует CommerceObjectContext для тоготобы вытянуть объекты Product из базы данных.
var products = (from p in this.objectContext.Producthere p.IsFeatureelect p).AsEnumerable();
56
Это только усиливает жестко закодированную зависимость, но на данном этаповреждения уже нанесены. Все что нам нужно – это более подходящий спосоомпоновки модулей без использования такого сильного связывания.
Прочие вопросы
Перед тем как показать вам лучшую альтернативу, мне хотелось бы обратить вашнимание на некоторые другие вопросы, связанные с кодом Мэри, к которым обязательнужно обратиться.
? Кажется, что большинство доменных моделей реализуются в библиотеке доступа анным. Несмотря на то, что тот факт, что библиотека доменной модели ссылаетса библиотеку доступа к данным, является технической проблемой, то, чтиблиотека доступа к данным определяет такой класс, как класс Product, чтвляется, в свою очередь, концептуальной проблемой. Открытый класс Producринадлежит к доменной модели.
? Оказавшись под влиянием Дженса, Мэри решила реализовать код, которыпределяет, является ли пользователь привилегированным покупателем ользовательском интерфейсе. Тем не менее, то, каким образом покупателдентифицируется в качестве привилегированного, является фрагментом бизнес-
логики, поэтому это должно быть реализовано в доменной модели.
Аргумент Дженса в пользу концепции разделения и принципа единственно тветственности никак не оправдывает размещение кода в неправильном месте.
Следование принципу единственной ответственности в рамках единичноиблиотеки вполне возможно – это ожидаемый подход.
? Класс ProductService полагается на XML конфигурацию. Как вы видели праблюдении за стараниями Мэри, она забыла, что ей пришлось поместить частонфигурационного кода в ее файл web.config. Несмотря на то, что способностонфигурирования компилируемого приложения является важной, тольккончательное приложение должно полагаться на конфигурационные файлы.
Удобнее, когда повторно используемые библиотеки обязательно конфигурируютсызывающими их объектами.
В конце концов, конечный вызывающий объект сам по себе является приложением.
На данном этапе все соответствующие конфигурационные данные можнрочитать из .config файла и загрузить при необходимости в основныиблиотеки.
? Кажется, что представление (продемонстрированное в листинге 2-3) содержилишком много функциональности. Оно выполняет расчеты и конкретнотроковое форматирование. Такая функциональность должна быть перемещена сновную модель.
В следующем разделе я продемонстрирую вам более скомпонованный способ созданириложения с теми же самыми возможностями, которые создавала Мэри. Кроме того, акже обращусь к этим второстепенным вопросам.
57
2.2. Как действовать правильно
Механизм внедрения зависимостей (DI) можно было использовать для решения теопросов, которые мы обсуждали. Поскольку DI – это радикальное отклонение от тогпособа, с помощью которого Мэри создавала свое приложение, я не собираюсь егзменять. Вместо этого я собираюсь заново создать его с самого начала.
Вам не следует делать из этого решения вывод о том, что можно выполнить рефакторинуществующего приложения относительно DI; это можно сделать, но это очень сложно.
По моему опыту для этого потребуется много раз выполнять рефакторинг.
Примечание
Пока я буду вести вас этому примеру, не волнуйтесь, если вы вдруг потеряетесь по пути.
Механизм внедрения зависимостей очень сложный, и в нем множество элементов. Я
выбрал этот пример, потому что он похож на реалистичный сценарий, но недостаток этогримера – это то, что он сложнее, чем выдуманный пример. В дальнейшем в этой книге обираюсь погрузиться глубже в те сущности и методики, которые были введены здесь.
После того, как вы прочитаете больше информации, вы всегда сможете вернуться обратн заново прочитать этот раздел.
Многие люди называют механизм внедрения зависимостей инверсией управления
(Inversion of Control). Иногда эти термины используются как взаимозаменяемые, но DI –
это подмножество инверсии управления. На протяжении всей этой книги я будоследовательно использовать самый конкретный термин: DI. Если я буду иметь ввиднверсию управления, то я буду говорить об этом конкретно.
Внедрение зависимостей или И нверсия управления?
Термин инверсия управления (IoC) первоначально означал любой вид стилрограммирования, в котором полноценный фреймворк или исполняющая средонтролировали ход выполнения программы. Согласно этому определению большинстврограммного обеспечения, разработанного на .NET Framework, использует принцинверсии управления.
При написании ASP.NET приложения вы попадаете в жизненный цикл ASP.NET
страницы, но вы ничем не управляете, всем управляет ASP.NET.
При написании WCF сервиса вы реализуете интерфейсы, помеченные атрибутами. Вожете писать код сервиса, но, в конце концов, вы ничем не управляете, всем управляет
WCF.
В настоящее время мы настолько привыкли работать с фреймворками, что уже не считаех особенными, но эта модель уже не находится под полным вашим контролем. Это всще может случиться и с .NET приложением – наиболее заметно при выполнении команомандной строки. Как только вызывается Main, ваш код приобретает полный контроль.
Он контролирует ход выполнения программы, жизненный цикл, в общем все. Никакисобенных событий не происходит, и никакие переопределенные члены не вызываются.
До того момента, как механизм внедрения зависимостей приобрел свое название, людачинали называть фреймворки, которые управляли зависимостями, IoC-контейнерами, и
58
вскоре смысл IoC постепенно сместился к конкретному значению: инверсия управлениависимостями. Будучи постоянным систематиком, Мартин Фаулер ввел терминедрение зависимост ей для того, чтобы в частности ссылаться на IoC в контекстправления зависимостями. С тех пор внедрение зависимост ей широко применяется ачестве самого корректного термина.
Короче говоря, инверсия управления – более широкой термин, который содержит в себермин внедрение зависимостей, но не ограничивается им.
В контексте управления зависимостями инверсия управления в точности описывает тото мы пытаемся выполнить. В приложении Мэри код напрямую управляет егависимостями: когда ProductService требуется новый экземпляр класса
CommerceObjectContext, он просто создает экземпляр с помощью ключевого слова new.
Когда HomeController требуется новый экземпляр класса ProductService, он такжоздает новый экземпляр с помощью ключевого слова new. Приложение находится поотальным контролем. Это может звучать сильно, но в действительности контролграничен. Я называю это анти-паттерном Control Freak (прим. ред. – термин в психологиарактеризует человека, который пытается диктовать всем вокруг как, по его мнениюолжно все происходить. В переводе, с точки зрения анти-паттерна, упоминается как
Руководитель-наркоман, но мы оставим английский вариант). Инверсия управления даеам указание отпустить этот контроль и позволить еще кому-то управлять зависимостями.
Создание коммерческого приложения заново
При написании программного обеспечения я предпочитаю приступать к этому в наиболеначимом месте. Чаще всего это пользовательский интерфейс. Поэтому я работаюобавляя еще больше функциональности до тех пор, пока возможность не осуществлена,  могу перейти к следующей возможности. Эта методика "снаружи-внутрь" помогает мнфокусироваться на запрашиваемой функционально сти без необходимости зановерестраивать приложение.
Примечание
Методика "снаружи-внутрь" тесно связана с принципом YAGNI ("You Aren’t Gonna Need
It") – "Вам это не понадобится". Этот принцип подчеркивает, что необходимеализовывать только требуемые возможности, и что реализация должна быть настолькростой, насколько это возможно.
Так как я всегда практикую разработку через тестирование (T DD), я начинаю писатодульные тесты, как только используемый мной подход "снаружи-внутрь" начинаеамекать мне на создание нового класса. Несмотря на то, что я написал множестводульных тестов, чтобы создать этот пример, разработка через тестирование не требуееализации и использования механизма внедрения зависимостей, поэтому я не собираюсемонстрировать эти тесты в моей книге. Если вам интересно, то эти тесты доступны сходном коде, который приложен к этой книге.
Пользовательский интерфейс
Необходимым условием для списка рекомендуемых товаров является написанириложения, которое извлекает рекомендуемые товары из базы данных и отображает их писке, как это показано на рисунке 2-3. Поскольку я знаю, что заинтересованным
59
сторонам проекта, главным образом, будет интересен визуальный результат, то лучшсего начать с пользовательского интерфейса.
Первое, что я делаю после открытия Visual Studio – добавляю в мое решение новое
ASP.NET MVC приложение. Так как список рекомендуемых товаров должен продолжатитульную страницу, я начинаю с изменения Index.aspx таким образом, чтобы онодержала разметку, продемонстрированную в следующем листинге.
Листинг 2-4: Разметка Index представления
<h2>Featured Products</h2>
<div>
<% foreach (var product in this.Model.Products)
{ %>
<div><%= this.Html.Encode(product.SummaryText) %></div>
<% } %>
</div>
Заметьте, насколько чище листинг 2-4 по сравнению с листингом 2-3. Первосовершенствование – это то, что больше не нужно приводить элемент словаря оследовательности товаров до того, как итерация станет возможной. Я с легкостьыполнил это, разрешив странице Index.aspx наследоваться от
System.Web.Mvc.ViewPage<FeaturedProductsViewModel>, а не от
System.Web.Mvc.ViewPage. Это означает, что свойство Model страницы имеет тип
FeaturedProductsViewModel.
Вся строка отображения товара берется прямо из свойства SummaryText этого товара.
Оба усовершенствования связаны с введением моделей конкретных представленийоторые инкапсулируют поведение представления. Эти модели являются POCO-
объектами (Plain Old CLR Objects). Рисунок 2-14 предоставляет обзор структуры такибъектов.
Рисунок 2-14: FeaturedProductsViewModel содержит список ProductViewModels. И
FeaturedProductsViewModel, и ProductViewModel являются POCO-объектами, что делаех в высокой степени доступными для модульного тестирования. Свойство SummaryTexолученно из свойств Name и UnitPrice для того, чтобы инкапсулировать логиктображения.
60
Чтобы код из листинга 2-4 был рабочим, HomeController должен возвращатредставление с экземпляром FeaturedProductsViewModel. Например, на первом шаге оожет быть реализован внутри HomeController, как это продемонстрировано ниже:
public ViewResult Index()
{
var vm = new FeaturedProductsViewModel();
return View(vm);
}
Это позволит веб-приложению выполняться без ошибок, но список рекомендуемыоваров всегда будет пустым. Предоставление списка рекомендуемых товаров – это задачоменной модели.
Рисунок 2-15 демонстрирует текущее состояние реализации архитектуры, показанной нисунке 2-2.
Рисунок 2-15: На данном этапе реализован только уровень пользовательскогнтерфейса, осталось реализовать уровни доменной логики и доступа к данным. Сравнитот рисунок с рисунком 2-6, который демонстрирует успехи Мэри на этом же самотапе. Одним из преимуществ того, что мы начинаем создание приложения ользовательского интерфейса, является то, что мы уже получаем приложение, котороожно запускать и тестировать. Только на более позднем этапе, продемонстрированноа рисунке 2-8, Мэри приходит к тому моменту, когда она может запускать и тестироватвое приложение.
61
Несмотря на то, что пользовательский интерфейс теперь существует, он не представляесобого интереса. Список рекомендуемых товаров всегда пуст, поэтому мне нужнеализовать некоторую доменную логику, которая сможет обеспечить должный списооваров.
Доменная модель
Доменная модель – это обычная, несложная C# библиотека, которую я добавляю в своешение. Эта библиотека будет содержать POCO-объекты и абстрактные типы. POCO-
объекты будут моделировать домен, в то время, как абстрактные типы обеспечиваюбстракции, которые будут выступать в роли моих основных внешних записей в доменноодели.
Принцип программирования на основании интерфейсов, а не конкретных классов – этснова механизма внедрения зависимостей. Именно этот принцип позволяет нам заменятдну реализацию другой.
Интерфейсы или абстрактные классы?
Многие руководства по объектно-ориентированному проектированию фокусируются ннтерфейсах как на главном механизме абстракций, в то время, как руководства проектированию на базе .NET Framework поддерживают превосходство абстрактнылассов над интерфейсами. Следует ли вам использовать интерфейсы или же все-такбстрактные классы?
Относительно механизма внедрения зависимостей утешительный ответ на данный вопрос
– не имеет значения, что вы будете использовать. Важно лишь то, что вы программируеттносительно некоторого рода абстракции.
Выбор между интерфейсами и абстрактными классами важен в других контекстах, но не анном. Вы заметите, что я использую эти понятия взаимозаменяемо; я часто используермин "абстракция", чтобы объединить оба этих термина "интерфейсы" и абстрактнылассы.
Я все еще руководствуюсь подходом "снаружи-внутрь", поэтому я на некоторое времобавлю код в уровень пользовательского интерфейса. Некоторый добавленный мной код
62
будет использовать типы из доменной модели. Это означает, что я добавлю ссылку номенную модель из пользовательского интерфейса, как это делала Мэри. Все получитстлично, но я отложу анализ диаграммы зависимостей до раздела "Анализ слабвязанной реализации", чтобы я смог предоставить вам полную картину.
Универсальная абстракция доступа к данным обеспечивается паттерном Repositoryоэтому я определю абстрактный класс ProductRepository в библиотеке доменноодели.
public abstract class ProductRepository
{
public abstract IEnumerable<Product> GetFeaturedProducts();
}
Готовый Repository будет иметь больше методов для поиска и изменения товаров, нледуя принципу "снаружи-внутрь", я определяю только классы и члены, которые мнужны для текущей задачи. Проще добавить функциональность в код, чем удалить все.
Класс Product также реализован с самым минимальным количеством членов, чтроиллюстрировано на рисунке 2-16.
Рисунок 2-16: Класс Product содержит только свойства Name и UnitPrice, поскольку этдинственные свойства, которые нужны для реализации желаемой возможностриложения. ApplyDiscountFor применяет в случае необходимости предоставить скидкля пользователя и возвращает экземпляр класса DiscountedProduct. Абстрактный
GetFeaturedProducts возвращает последовательность Products.
Метод Index HomeController должен использовать экземпляр ProductService для тоготобы извлечь список рекомендуемых товаров, применить какую-либо скидку,
63
сконвертировать экземпляры Product в экземпляры ProductViewModel, затем добавить и FeaturedProductsViewModel. Поскольку класс ProductService принимает в своонструктор экземпляр ProductRepository, самое сложное – обеспечить егоответствующим экземпляром. Вспомните из анализа реализации Мэри, что созданиависимостей при помощи ключевого слова new является неправильным. Как только я этделаю, я окажусь сильно связанным с типом, который я только что использовал.
Я собираюсь отказаться от контроля над зависимостью ProductRepository. Кародемонстрировано в следующем листинге, я лучше буду полагаться на что-нибудругое, чтобы получить экземпляр с помощью конструктора HomeController. Этоаттерн называется Constructor Injection (внедрение через конструктор) – как и кеоздается экземпляр не является заботой HomeController.
Листинг 2-5: HomeController с паттерном Constructor Injection
1. public partial class HomeController : Controller
2. {
3. private readonly ProductRepository repository;
4.
5. public HomeController(ProductRepository repository)
6. {
7. if (repository == null)
8. {
9. throw new ArgumentNullException("repository");
10. }
11. this.repository = repository;
12. }
13.
14. public ViewResult Index()
15. {
16. var productService = new ProductService(this.repository);
17.
18. var vm = new FeaturedProductsViewModel();
19.
20. var products = productService.GetFeaturedProducts(this.User);
21. foreach (var product in products)
22. {
23. var productVM = new ProductViewModel(product);
24. vm.Products.Add(productVM);
25. }
26. return View(vm);
27. }
28. }
Строка 5: Внедрение через конструктор
Строка 11: Сохраняет внедренную зависимость для дальнейшего использования
Строка 16: Передает внедренную зависимость
Конструктор HomeController указывает, что каждый, кому захочется использовать классолжен предоставить экземпляр ProductRepository (который, как вы, возможноомните, является абстрактным классом). Ограждающее условие гарантирует выполнениутем генерирования исключения в случае, если используемый экземпляр пуст.
Внедренная зависимость может быть сохранена и в дальнейшем безопасно использоватьсругими членами класса HomeController.
64
В первый раз, когда я услышал о внедрении через конструктор, мне понадобилось многремени на то, чтобы осознать реальную пользу этого паттерна. Не приведет лспользование такого подхода к тому, что вся тяжесть управления зависимостями ляжеа другой класс?
Да, приведет – и в этом-то все дело. В n-уровневых приложениях мы можем вынестправление зависимостями любыми способами на самый верхний уровень приложения – в
C om position Root. Это централизованное место, в котором могут компоноватьсазличные модули приложения. Это можно сделать вручную или же делегировать этадачу DI-контейнеру.
HomeController делегирует большую часть своей работы классу ProductServiceродемонстрированному в следующем листинге. Класс ProductService соответствуелассу Мэри с тем же именем, но на данный момент он является подлинным классооменной модели.
Листинг 2-6: Класс ProductService
1. public class ProductService
2. {
3. private readonly ProductRepository repository;
4.
5. public ProductService(ProductRepository repository)
6. {
7. if (repository == null)
8. {
9. throw new ArgumentNullException("repository");
10. }
11. this.repository = repository;
12. }
13. public IEnumerable<DiscountedProduct> GetFeaturedProducts(IPrincipaser)
14.
15. {
16. if (user == null)
17. {
18. throw new ArgumentNullException("user");
19. }
20.
21. return from p in this.repository.GetFeaturedProducts()
22. select p.ApplyDiscountFor(user);
23. }
24. }
Строка 5: И снова используем Constructor Injection
Строка 14: Паттерн Method Injection
Строка 21-22: Используем обе внедренные зависимости для реализации поведения
Метод GetFeaturedProducts теперь принимает в качестве параметра экземпляр
IPrincipal, который представляет собой текущего пользователя. Это еще однтклонение от реализации Мэри, показанной в листинге 2-1, которая всего лишринимала в качестве параметра булево значение, указывая, является ли пользователривилегированным. Тем не менее, поскольку решение о том, является ли пользователеривилегированным, – это часть доменной логики, корректнее будет явно смоделировать
65
текущего пользователя в виде зависимости. Мы должны всегда соблюдать принцирограммирования на основании интерфейса, но в данном случае мне не нужно ничегзобретать (как я это делал с ProductRepository), потому что в библиотеку стандартнылассов .NET уже входит интерфейс IPrincipal, который представляет соботандартный способ моделирования пользователей приложения.
Передача зависимости в метод в качества параметра называется внедрением череараметры метода (Method Injection). И снова управление делегируется вызывающемператору, подобно внедрению через конструктор. Несмотря на то, что детали могуарьироваться, основная технология остается той же.
На данном этапе приложение все еще не работает. Осталось две проблемы:
? Отсутствует конкретная реализация ProductRepository. Эта проблема легкешается. В следующем разделе я буду реализовывать конкретный
ProductRepository, который считывает рекомендуемые товары из базы данных.
? По умолчанию ASP.NET MVC предполагает, что контроллеры обладаюонструкторами по умолчанию. Поскольку я ввел параметр в конструктор
HomeController, MVC framework не знает, как создать экземпляр HomeController.
Эта проблема может быть решена путем создания пользовательского
IControllerFactory. То, как это делается, выходит за рамки данной главы, но этоопрос будет обсуждаться в главе 8. Достаточно просто сказать, что этользовательская фабрика создаст экземпляр конкретного ProductRepository ередаст его в конструктор HomeController.
В доменной модели я работаю только с типами, определенными в рамках доменноодели (и библиотеки стандартных классов. NET). Сущности доменной моделеализуются в виде POCO-объектов. На данном этапе существует одна единственнаредставленная сущность, названная Product. Доменная модель должна уметзаимодействовать с внешним миром (например, с базами данных). Эта необходимостмоделирована в виде абстрактных классов (например, Repositories), которые молжны заменить конкретными реализациями перед тем, как доменная модель станеолезной.
Рисунок 2-17 демонстрирует текущее состояние реализации архитектурыродемонстрированной на рисунке 2-2.
Рисунок 2-17: Уровень пользовательского интерфейса и уровень доменной логики ужеализованы, остается реализовать уровень доступа к данным. Сравните этот рисунок исунком 2-7, который демонстрирует успехи Мэри на данном этапе.
66
Доменная модель приложения еще не является объектно-ориентированной; чтобавершить цикл, мне нужно реализовать только один абстрактный ProductRepository.
Доступ к данным
Как и Мэри, мне хотелось бы реализовать мою библиотеку доступа к данным при помощехнологии LINQ to Entities, поэтому я последую тем же шагам, которые она выполняла азделе "Создание сильно связанного приложения" при создании модели. Главнотличие – модель и CommerceObjectContext теперь являются всего лишь деталямеализации; но с помощью них я могу создать реализацию ProductRepository, чтродемонстрировано в следующем листинге.
Листинг 2-7: Реализация ProductRepository с помощью LINQ to Entities
1. public class SqlProductRepository : Domain.ProductRepository
2. {
3. private readonly CommerceObjectContext context;
4.
5. public SqlProductRepository(string connString)
6. {
7. this.context = new CommerceObjectContext(connString);
8. }
9.
10. public override IEnumerable<Domain.Product> GetFeaturedProducts()
11. {
12. var products = (from p in this.context.Products
13. where p.IsFeatured
14. select p).AsEnumerable();
15. return from p in products
16. select p.ToDomainProduct();
17. }
18. }
Строка 16: Конвертирует в Domain Product
В приложении Мэри сгенерированная сущность Product использовалась в качествоменного объекта, несмотря на то, что она была определена в базе данных. Так больше происходит, потому что я уже определил класс Product в доменной модели. Когда генерировал модуль, мастер создал для меня еще один класс Product и мне нужныполнить конвертацию между этими классами. Рисунок 2-18 иллюстрирует, какибразом они определены в разных модулях. Существующий класс Product – это всегишь деталь реализации, и я мог бы с легкостью сделать его внутренним, чтобы выразитго более явно.
Рисунок 2-18: И библиотека доменной модели, и библиотека доступа к данныпределяют класс под названием Product. Доменный класс Product – это важный классоторый инкапсулирует доменную сущность – товар. Класс Product библиотеки доступа анным – это всего лишь искусственный объект мастера Entity Framework. Его можнегко переименовать или сделать внутренним.
67
Примечание
Вы можете поспорить, что то, что Entity Framework не поддерживает неграмотныущности, является его определенным дефектом (по крайней мере, не в версии .NET 3.5
SP1). Тем не менее, это вид ограничения, с которым вы обязательно столкнетесь еальных проектах программного обеспечения.
Существующий Product задает конвертацию в доменный тип Product. Эта конвертацивляется обычным преобразованием соответствующих значений. Несмотря на то, чтакая конвертация не относится конкретно к механизму внедрения зависимостей, спользую ее для более удобных измерений:
Domain.Product p = new Domain.Product();
p.Name = this.Name;
p.UnitPrice = this.UnitPrice;
return p;
После реализации SqlProductRepository я теперь могу настроить ASP.NET MVC длого, чтобы внедрить экземпляр SqlProductRepository в экземпляры HomeController.
Поскольку я более подробно буду рассматривать это в главе 7, я не буду демонстрироватто здесь.
Рисунок 2-19 демонстрирует текущее состояние архитектуры приложенияродемонстрированной на рисунке 2-2.
Рисунок 2-19: Все три уровня приложения на данный момент реализованы так, как этродемонстрировано на рисунке 2-2. Этот рисунок идентичен рисунку 2-2, но повторяетсдесь для иллюстрации текущего состояния приложения. Рисунок также идентичеисунку 2-8, который демонстрирует завершенное приложение Мэри.
68
Теперь, когда все корректно соединено вместе, я могу перейти к домашней страницриложения и получить такую же страницу, как продемонстрированная на рисунке 2-3.
Анализ слабо связанной реализации
Предыдущий раздел содержал множество подробной информации, поэтому вряд ли вадивит то, что вы потеряли общее представление о происходящем. В этом разделе опытаюсь объяснить то, что произошло, с помощью более ясных терминов.
Взаимодействие
Классы каждого уровня взаимодейству ют друг с другом напрямую или в абстрактноорме. Таким образом, они работают за пределами модулей, поэтому трудно будероследить процесс их взаимодействия. Рисунок 2-20 иллюстрирует, как соединяютсависимости.
Рисунок 2-20: Взаимодействие между элементами, включенными в механизм внедрениависимостей в коммерческом приложении. Заметьте, что экземпляр
SqlProductRepository внедряется в HomeController, а затем спустя некоторое времерез HomeController внедряется в ProductService, который, в конечном счетеспользует его.
69
При запуске приложения код файла Global.asax создает новую пользовательску абрику контроллеров. Приложение сохраняет ссылку на фабрику контроллеров, поэтомуогда выполняется запрос страницы, приложение вызывает CreateController длабрики. Фабрика ищет строку соединения в файле web.config и передает ее в новыкземпляр SqlProductRepository. Фабрика внедряет экземпляр SqlProductRepository овый экземпляр HomeController, а затем возвращает этот экземпляр.
Затем приложение вызывает метод Index для экземпляра HomeController, заставляя егоздать новый экземпляр ProductService, передавая экземпляр SqlProductRepository го конструктор. ProductService вызвает метод GetFeaturedProducts для экземпляра
SqlProductRepository.
В конце концов, возвращается ViewResult с заполненным FeaturedProductsViewModel, а
ASP.NET MVC фреймворк находит и отображает корректную страницу.
Диаграмма зависимосте й
В разделе "Анализ" мы увидели, как диаграмма зависимостей может помочь нароанализировать и понять степень гибкости, которую обеспечивает архитектурнаеализация. Изменил ли механизм внедрения зависимостей диаграмму зависимостериложения?
Рисунок 2-21 демонстрирует, что диаграмма зависимостей действительно изменилась.
Доменная модель больше не имеет зависимостей и может выступать в роли автономногодуля. С другой стороны, у библиотеки доступа к данным теперь есть зависимость; риложение Мэри у нее не было зависимостей.
Рисунок 2-21: Диаграмма зависимостей, которая демонстрирует пример коммерческогриложения при использовании механизма внедрения зависимостей. Самое
70
примечательное отличие – это то, что у доменной библиотеки больше нет зависимостей.
Серые блоки внутри черных блоков демонстрируют примерные классы каждоиблиотеки для того, чтобы дать вам представление о том, где какие классы должны быть.
В каждой библиотеке присутствует больше классов, чем продемонстрировано на этоисунке.
Это пробуждает наши надежды на то, что мы более плодотворно сможем ответить нервоначальные вопросы о композиции:
? Можем ли мы заменить пользовательский веб-интерфейс пользовательскинтерфейсом WPF? Такая замена была возможна до этого и остается возможной амках нового проектирования. Ни библиотека доменной модели, ни библиотекоступа к данным не зависят от пользовательского веб-интерфейса, поэтому можем с легкостью поместить на его место что-то другое.
? Можем ли мы заменить реляционную библиотеку доступа к данным библиотекойоторая работает с сервисом Azure Table Service? В главе 3 я буду описывать, кариложение размещает и создает экземпляры корректного ProductRepositoryоэтому на данный момент примите следующее как данность: библиотека доступ данным загружается с помощью позднего связывания, а имя типа определяется иде настройки приложения в файле web.config. Можно удалить текущуиблиотеку доступа к данным и внедрить новую библиотеку, поскольку она такжредоставляет реализацию ProductRepository.
Нельзя больше использовать текущую библиотеку доступа к данным изолированнооскольку она теперь зависит от доменной модели. Во многих видах приложений это нвляется проблемой, но если заинтересованные стороны захотят, чтобы такаозможность была реализована, я могу решить эту проблему путем добавления ещдного уровня абстракции: с помощью извлечения интерфейса из Product (скажем,
IProduct) и изменения ProductRepository для того, чтобы он работал с IProduct, а не с
Product. Эти абстракции потом можно переместить в отдельную библиотеку, котораспользуется совместно библиотекой доступа к данным и доменной моделью. Этотребовало бы больших затрат времени, поскольку мне понадобилось бы писать код длреобразования Product в IProduct, но это все-таки возможно.
71
Благодаря проектированию на основании механизма внедрения зависимостеервоначальное веб-приложение может постепенно быть преобразовано в приложение
Software + Services (доступ к программному обеспечению предоставляется заказчикерез интернет) с богатым WPF интерфейсом и облачным движком хранилища данных.
Единственное, что осталось от первоначальной работы – это доменная модель, но этелесообразно, поскольку доменная модель инкапсулирует все важные бизнес-правила, о существу, нам следует ожидать, что она будет самым существенным модулем.
При разработке приложений мы, вероятно, не можем предугадать каждое будущеаправление, которое может нам понадобиться для того, чтобы получить товар, но это нроблема, поскольку мы можем хранить наши варианты открытыми для доступа.
Механизм внедрения зависимостей помогает нам создавать слабо связанные приложениля того, чтобы мы могли заново использовать или заменять различные модулеобходимыми модулями.
72
2.3. Расширение шаблонного приложения
Чтобы поддержать оставшуюся часть книги и полностью продемонстрировать различныспекты механизма внедрения зависимостей, мне понадобится расширить шаблоннооммерческое приложение. До настоящего момента я сохранял приложение настолькростым и небольшим по размеру, насколько это было возможно, чтобы осторожнвести некоторые центральные сущности и принципы. Поскольку одной из главных целееханизма внедрения зависимостей является управление сложностью, нам нужно сложнориложение, чтобы полностью оценить его силу.
Я буду расширять приложение относительно двух аспектов: архитектурный рефакторин добавленные возможности.
Архитектура
До настоящего времени шаблонное приложение было трехуровневым приложением, нейчас я хочу всунуть уровень презентационной модели между пользовательскинтерфейсом и доменной моделью, как это показано на рисунке 2-22.
Рисунок 2-22: Уровень презентационной модели вставляется в шаблонное приложениля того, чтобы отделить логику представления от центральной части приложения.
Я переместил все контроллеры и модели представлений из уровня пользовательскогнтерфейса в уровень презентационной модели, оставляя в уровне пользовательскогнтерфейса только представления (файлы .aspx и .ascx) и Composition Root.
Главная причина такого перемещения – отделить Composition Root от логикредставления; таким образом, я могу продемонстрировать вам различные вариантонфигурационных стилей, оставляя при этом неизменной настолько большую частриложения, насколько это возможно.
73
"Скромный" объект
Я разделяю приложение на уровень пользовательского интерфейса и уровенрезентационной модели не только для образовательных целей; я регулярно проделывато для всех разрабатываемых мной приложений, если они имеют пользовательскинтерфейс.
Такое разделение обеспечивает понятную концепцию разделения логики представления
(как ведут себя пользовательские интерфейсы) и логики отображения (как выглядяользовательские интерфейсы). Благодаря такой концепции разделения вся логикомещается в уровень, где ее можно тестировать модульно, а вся разметка помещается ровень, где может работать графический дизайнер, не боясь при этом что-то легказрушить.
Цель – получить настолько небольшой по размеру императивный код, насколько этозможно на уровне пользовательского интерфейса, поскольку я не собираюсь писатикаких модульных тестов для этого уровня.
Ядро приложения, которое содержит только достаточный минимум кода для начальноагрузки самого себя, после чего оно делегирует всю остальную часть работестируемым модулям, называется скромным объектом (Humble object). В данном случан содержит только представления и код начальной загрузки: Composition Root.
Помимо этой архитектурной модификации я также хочу добавить более расширеннуозможность, нежели та, что мы рассматривали до настоящего момента.
Возможность добавления в корзину
Список рекомендуемых товаров знакомит нас только с ограниченным уровнем сложности:
в сценарий, доступный только для чтения, вовлечен единственный репозиторий.
Следующий логичный шаг – ввести возможность добавления покупок в корзину. Рисунок
2-23 демонстрирует скриншот использования корзины покупок.
Рисунок 2-23: Впечатляюще скудная по возможностям корзина покупок еорганизованном коммерческом шаблонном приложении.
74
Чтобы обеспечить корзину покупок для каждого пользователя, мне понадобятся Basket,
BasketRepository и хост поддерживаемых классов. Если вы похожи на меня, то вахотите сначала увидеть класс Basket: рисунок 2-24 демонстрирует корзину и список елементов.
Рисунок 2-24: Корзина и ее содержимое, которое представляет собой список
Extent<Evaluated-Product>. Extent представляет количество данного товара.
С точки зрения механизма внедрения зависимостей классы Extent и Basket не особенннтересны: они оба являются POCO-классами без зависимостей. Больший интерередставляют классы BasketService и поддерживаемые классы, продемонстрированныа рисунке 2-25.
Рисунок 2-25: BasketService и поддерживаемые классы. BasketService может извлекат вычислять Basket для данного пользователя. BasketService использует
BasketRepository для извлечения Basket и BasketDiscountPolicy с целью примененикидки (при необходимости)
BasketService может использоваться для извлечения пользовательского Basket рименения скидок. Он использует абстрактный BasketRepository, чтобы получитодержимое Basket и абстрактного BasketDiscountPolicy для дальнейшего примененикидок. Обе эти абстракции внедряются в BasketService посредством технологинедрения через конструктор.
75
public BasketService(BasketRepository repository,
BasketDiscountPolicy discountPolicy)
BasketDiscountPolicy может быть простой реализацией с жестко-закодиро ваннотратегией, например, предоставление привилегированным покупателям пятипроцентнокидки, как мы уже видели в этой главе. Данная стратегия реализуется с помощью
DefaultProductDiscountPolicy, в то время как более сложная реализация через данныбеспечивается RepositoryBasketDiscountPolicy, который уже использует абстрактный
DiscountRepository для получения списка уцененных товаров. Эта абстракция еще ранедряется в RepositoryBasketDiscountPolicy посредством внедрения череонструктор:
public RepositoryBasketDiscountPolicy(DiscountRepository repository)
Для управления всем этим я могу воспользоваться BasketService, чтобы распределитперации над Basket: добавление элементов, а также отображение и очистка Basket. Длыполнения этого BasketService необходимы как BasketRepository, так и
BasketDiscountPolicy, которые (как вы догадались) передаются в него через егонструктор:
public BasketService(BasketRepository repository,
BasketDiscountPolicy discountPolicy)
Для дальнейшего усложнения мне необходим ASP.NET MVC контроллер с названием
BasketController, содержащий интерфейс IBasketService, который я снова внедряерез конструктор:
public BasketController(IBasketService basketService)
Как показывает рисунок 2-25, класс BasketService реализует IBasketService, это и естспользуемая нами реализация.
BasketController, в конечном счете, создается при помощи пользовательского
IControllerFactory, поэтому ей также потребуются эти абстракции.
Если по пути вы потеряли направление наших мыслей, то рисунок 2-26 демонстрируеиаграмму, которая иллюстрирует то, как зависимости компонуются в окончательнориложении.
Рисунок 2-26: Композиция шаблонного коммерческого приложения с добавленноозможностью отправки товаров в корзину, а также первоначальным спискоекомендуемых товаров на титульной странице. Каждый класс инкапсулирует своодержание, и только Composition Root знает обо всех зависимостях.
76
Пользовательский IControllerFactory создает экземпляры BasketController и
HomeController, предоставляя их вместе с соответствующими зависимостями.
BasketService, например, использует переданный экземпляр BasketDiscountPolicyтобы применить стратегию скидок к корзине товаров:
var discountedBasket = this.discountPolicy.Apply(b);
Я не намекаю на то, что в данном случае переданный BasketDiscountPolicy – эткземпляр RepositoryBasketDiscountPolicy, который сам по себе является контейнероля DiscountRepository.
Это расширенное шаблонное приложение служит основой для большинства примероода оставшейся части книги.
77
2.4. Резюме
Поразительно легко писать сильно связанный код. Даже когда Мэри намереваласаписать трехуровневое приложение, это вылилось большей частью в монолитнырагмент "спагетти-кода" (говоря о многоуровневом представлении, мы называем его
"лазанья").
Одной из множества причин того, что писать сильно связанный код так легко, является тото и возможности языка, и наши инструменты уже ведут нас в этом направлении. Еслам нужен новый экземпляр объекта, мы можем воспользоваться ключевым словом new, сли у нас отсутствует ссылка на требуемую сборку, Visual Studio облегчает процесс еобавления.
Как бы то ни было, каждый раз при использовании ключевого слова new мы вводиильное связывание.
Самый лучший способ минимизации использования ключевого слова new – использованиаттерна проектирования Внедрение через конструктор всюду, где нам нужен экземпляависимости. Второй пример главы продемонстрировал, как заново реализоватриложение Мэри, программируя на основании интерфейсов, а не конкретных классов.
Внедрение через конструктор – это пример инверсии управления, поскольку мнвертируем управление зависимостями. Вместо того чтобы создавать экземпляры промощи ключевого слова new, мы делегируем эту ответственность стороннемомпоненту. Как мы увидим из следующей главы, мы называем это место Composition
Root. Это то место, в котором мы компонуем все слабо связанные классы приложения.
78
3. DI-контейнеры
Меню:
? XML конфигурация
? Использование кода в качестве конфигурации
? Автоматическая регистрация
? Com position Root
? Паттерн Register Resolve Release
Когда я был еще совсем ребенком, мы с мамой изредка готовили мороженое. Мы нелали это слишком часто, поскольку приготовление мороженого было трудоемкироцессом, и очень сложно было получить в итоге настоящее мороженое. В случае еслы никогда не пробовали делать мороженое, рисунок 3-1 иллюстрирует процесс егриготовления.
Рисунок 3-1: Приготовление мороженого – трудоемкий процесс, включающий множествозможностей для совершения ошибок
79
Настоящее мороженое делается на кремовой основе, которая представляет собой легкиаварной крем, приготовленный из сахара, яичных желтков и молока или крема. Еслерегреть эту смесь, то она будет сворачиваться. Если даже вам удалось этого избежатьледующая фаза приготовления несет за собой еще больше проблем. Если оставитремовую смесь в морозилке и не трогать ее, то она будет кристаллизоваться, поэтому варидется регулярно ее помешивать до тех пор, пока она не станет максимально густой.
Только после этого вы получите хорошее, приготовленное в домашних условияороженое.
Несмотря на то, что приготовление мороженого – это медленный и трудоемкий процесссли вы все же хотите его приготовить, и у вас есть все необходимые ингредиенты борудование, то вы можете воспользоваться выведенной мной технологиериготовления мороженого.
Сегодня, около 30 лет спустя, моя тёща делает мороженое с периодичностьюесравнимой с той, с которой мы с мамой делали мороженое в более юные годы – нотому что она любит делать мороженое, но потому что она пользуется технологиейоторая ей помогает. Техника остается все той же, но вместо того, чтобы постоянноставать мороженое из морозилки и перемешивать его, она пользуется электрическоороженицей, которая выполняет это за нее (см. рисунок 3-2).
Рисунок 3-2: Итальянская мороженица моей тещи
80
Механизм внедрения зависимостей – это первая и самая главная технология, но вы можетоспользоваться техническими средствами для облегчения процесса. В части 3 я будписывать DI как технологию. Затем в части 4 мы рассмотрим технические средстваоторые могут использоваться для поддержания технологии DI. Мы называем этредства DI-контейнерами.
В этой главе мы рассмотрим DI-контейнеры как сущность: как они вписываются всеобщую картину механизма внедрения зависимостей, рассмотрим некоторые паттерн технологии, предусматривающие их использование, а также рассмотрим некоторысторические факты, касающиеся DI. Попутно мы рассмотрим некоторые примеры.
Основной план-конспект главы проиллюстрирован на рисунке 3-3. Глава начинается бщего введения к DI-контейнерам, включая описание сущности под названиевтоматическая интеграция, за которым следует раздел с описанием различных опционфигурации. Вы можете читать о каждой из этих опций в отдельности, но думаю, былы выгоднее, по крайней мере, прочитать о такой опции, как использование кода ачестве конфигурации, прежде чем читать об автоматической регистрации.
Рисунок 3-3: Структура этой главы. Раздел "Перспектива DI-контейнеров" не являетсбязательным для прочтения
81
Центральный раздел этой главы – это мини-каталог паттернов проектированияазываемых DI-контейнеры. Несмотря на то, что этот раздел руководствуется форматоаталога, описание паттерна Register Resolve Release (RRR) опирается на описаниаттерна Composition Root, поэтому имеет смысл читать их последовательно. Вы можетропустить раздел об опциях конфигурации и перейти прямо к описанию паттернов, нти разделы лучше читать по порядку.
Последний раздел отличается от предыдущих. Он намного менее технический окусируется на том, как DI-контейнеры вписываются в экосистему .NET. Вы можетропустить этот раздел, если вам не важен этот аспект.
Цель главы – предоставить вам хорошее понимание того, что такое DI-контейнер, и как оочетается со всеми остальными паттернами и принципами данной книги; в некоторомысле, вы можете рассматривать эту главу как введение к части 4 данной книги. В неы будем говорить о DI-контейнерах в широком смысле, тогда как в части 4 мы будеоворить о конкретных контейнерах и их API.
Может показаться несколько странным то, что мы ведем разговор о DI-контейнерах здесь главе 3, а потом более или менее забываем о них на протяжении следующих шести главо для этого есть причина. В этой части книги я хочу обрисовать огромную картинеханизма внедрения зависимостей, и важно, чтобы вы понимали, как DI-контейнеры
82
вписываются в эту схему. В части 2 и 3 я изредка буду демонстрировать вам некоторыримеры, в которые входит DI-контейнер, но в большинстве случаев я, в основном, будридерживаться рассуждений. Принципы и паттерны, описанные в середине книги, могуыть применимы ко всем DI-контейнерам.
3.1. Знакомство с DI-контейнерами
3.2. Конфигурирование DI-контейнеров
3.3. Паттерны DI-контейнеров
3.4. Перспектива DI-контейнеров
3.5. Резюме
83
3.1. Знакомство с DI-контейнерами
DI-контейнер – это библиотека программных средств, которая может автоматизироватножество задач, включая компоновку объектов и управление их жизненным циклом.
Несмотря на то, что можно написать весь необходимый код инфраструктуры с помощью
Poor man's DI, такой способ не добавляет большой значимости приложению. С друготороны, задача компоновки объектов является всеобщей по своей натуре и может бытешена в один момент и сразу для всех; это так называемый видовой субдомен.
О пределение
DI-контейнер – это библиотека, которая обеспечивает функциональность механизмнедрения зависимостей.
Примечание
DI-контейнеры также называют IoC-контейнерами или (намного реже) Легковеснымонт ейнерами.
Несмотря на то, что вам нужно обращаться к инфраструктуре приложения, выполненитого само по себе не добавляет никакой бизнес-значимости, поэтому лучше всегспользовать общецелевую библиотеку. Она не отличается от реализации входа в системли доступа к данным. Регистрация данных приложения – это проблема, к которой чащсего обращается общецелевая библиотека управления логами. То же самое верно и длиаграмм компоновки объектов.
Предупреждение
Не ждите, что DI-контейнер волшебным образом превратит сильно связанный код в слабвязанный. DI-контейнер может сделать использование механизма внедрениависимостей более эффективным, но приложение, в первую очередь, должно бытпроектировано с учетом DI паттернов и технологий.
В данном разделе я буду обсуждать то, как DI-контейнеры формируют диаграммбъектов и продемонстрирую вам некоторые примеры, чтобы дать вам общередставление того, на что должно быть похоже использование контейнера.
Контейнер "Hello"
DI-контейнер – это библиотека программных средств, похожая на любую другуиблиотеку программных средств. Он предоставляет API, которое вы можетспользовать для компоновки объектов. Формирование диаграммы объектов – это вызодиничного метода. Все DI-контейнеры необходимо конфигурировать переспользованием их для компоновки объектов, но я заново пересмотрю этот вопрос азделе "Конфигурирование DI-контейнеров".
В этом разделе я продемонстрирую вам несколько примеров того, как DI-контейнерогут преобразовывать диаграммы объектов для расширенного шаблонного приложениз раздела "Расширение шаблонного приложения". Для каждого запроса ASP.NET MVC
фреймворк будет запрашивать экземпляр соответствующего типа IController, поэтому
84
вы должны реализовать метод, который использует DI-контейнер для формированиоответствующей диаграммы объектов.
Подсказка
Раздел "Построение ASP.NET MVC приложений" содержит подробную информацию ом, как формировать ASP.NET MVC приложения.
MVC фреймворк будет вызывать метод для экземпляра Type, который определяет нужныму тип IController (например, HomeController или BasketController), а вы должнозвращать экземпляр этого типа.
Эта функциональнос ть может быть реализована для всех DI-контейнеровассматриваемых в части 4, но в данном разделе я продемонстрирую только несколькримеров.
Преобразование контроллеров для различных DI-конте йнеров
Unity – это DI-контейнер с явно соответствующим паттерну API. Предполагая, что у важе есть экземпляр класса UnityContainer контейнера Unity, вы можете преобразоваткземпляр IController из аргумента controllerType типа Type:
var controller = (IController)this.container.Resolve(controllerType);
Вы будете передавать параметр controllerType в метод Resolve и получать экземпляребуемого типа, полностью заполненный всеми подходящими зависимостями. Поскольклабо-типизированный метод Resolve возвращает экземпляр System.Object, он должеыть отправлен в IController.
Для таких случаев, когда вы уже на этапе проектирования знаете, какой тип необходимуществует также общая версия метода Resolve.
Многие DI-контейнеры обладают API, которое похоже на API контейнера Unity.
Соответствующий код для Castle Windsor выглядит идентично коду Unity, несмотря на тото экземпляр container будет уже экземпляром класса WindsorContainer. Остальныонтейнеры имеют несколько другие названия – для StructureMap, например, предыдущиод будет выглядеть следующим образом:
var controller = (IController)this.container.GetInstance(controllerType);
Единственное реальное отличие – метод Resolve называется GetInstance. Вы можетзвлечь из этих примеров общий вид DI-контейнера.
Диаграммы преобразования объектов для DI-конте йнеров
DI-контейнер – это движок, который преобразует и управляет диаграммами объектов.
Несмотря на то, что DI-контейнер выполняет множество других функций, помимреобразования объектов, преобразование объектов является центральной частью API
любого контейнера. Предыду щие примеры демонстрируют, что у контейнеров для этиелей есть слабо-типизированный метод. Варьируясь в названиях и сигнатурах, в общелучае он выглядит следующим образом:
85
object Resolve(Type service);
Как демонстрируют предыдущие примеры, поскольку возвращаемый экземпляр являетсипизированным, как, например, System.Object, то вам часто приходитсреобразовывать возвращаемо е значение к необходимому типу перед тем, как егспользовать.
Многие DI-контейнеры также для этих случаев предлагают общую версию, когда мнаем, какой тип запрашивается во время компиляции. Они часто выглядят следующибразом:
T Resolve<T>();
Вместо применения аргумента Type метода такая перегрузка принимает типизированныараметр (T), который указывает на необходимый тип. Метод возвращает экземпляр T.
Большинство контейнеров выдают исключения, если не могут преобразоватеобходимый тип.
Предупреждение
Сигнатура метода Resolve чрезвычайно влиятельная и универсальная. Вы можетапросить экземпляр любого типа, и ваш код все еще будет компилируемым. В
действительности, метод Resolve устанавливает сигнатуру анти-паттерна Service Locator вам нужно действовать осторожно, чтобы не использовать свой DI-контейнер в качестве
Service Locator.
Если мы рассмотрим метод Resolve изолированно, то он выглядит почти волшебным. С
точки зрения компилятора, можно попросить его преобразовать экземплярроизвольных типов. Каким образом контейнер узнает, как формировать необходимыипы, включая все зависимости?
Он не знает этого, и вам придется сначала ему это разъяснить. Вы делаете этосредством регистрации или конфигурирования, и именно здесь вы преобразуетбстракции в конкретные типы – я вернусь к этому вопросу в разделе "Конфигурирование
DI-контейнеров". Если у контейнера не будет подходящей конфигурации для того, чтоболноценно сформировать необходимый тип, он будет выдавать описательносключение. Например, Castle Windsor имеет следующие примерные сообщения-
исключения:
? Невозможно создать компонент "Ploeh.Samples.MenuModel.Mayonnaise"оскольку у него есть зависимости, кот орые необходимо выделить.
? Для Ploeh.Samples.MenuModel.Mayonnaise нужны следующ ие зависимости:
? Сервисы:
? – Ploeh.Sam ples.MenuModel.EggYolk, кот орый не был зарегистрирован.
В данном примере вы можете увидеть, что Castle Windsor не может преобразовать
Mayonnaise, поскольку он не был настроен для работы с классом EggYolk.
Если контейнер корректно сконфигурирован, то он может преобразовывать даже сложныиаграммы объектов из требуемых типов. Если в конфигурации что-то упущено, то
86
контейнер может предоставить детальную информацию о том, что пропущено. В
следующем разделе мы подробнее рассмотрим, как это делается.
Автоматическая интеграция
DI-контейнеры бурно развиваются на основе статической информации, собранной во вселассах, использующих технологию внедрения через конструктор. Используя рефлексиюни могут анализировать запрашиваемые классы и предугадывать, какие зависимости иужны.
Некоторые DI-контейнеры понимают и паттерн Property Injection (внедрениависимостей через свойства), но все они, по своему существу, понимают паттерн
Constructor Injection и формируют диаграммы объектов путем сочетания их собственноонфигурации с информацией, извлеченной из конструкторов классов. Данный процесазывается автоматической интеграцией.
Определение
Автоматическая интеграция – это способность автоматически формировать диаграммбъектов из таблицы преобразований между абстракциями и конкретными типами.
Рисунок 3-4 описывает общий алгоритм, которому следует большинство DI-контейнеровтобы автоматически интегрировать диаграмму объектов. DI-контейнер будеспользовать эту конфигурацию для того, чтобы найти соответствующий конкретныласс, совпадающий с запрашиваемым типом. Затем DI-контейнер использует рефлексиля изучения конструктора класса. Если существует конструктор по умолчанию, то DI-
контейнер будет вызывать конструктор и возвращать созданный экземпляр.
Рисунок 3-4: Упрощенная последовательность действий для автоматической интеграции.
DI-контейнер будет рекурсивно находить конкретные типы и изучать их конструкторы дех пор, пока он не сможет создать целостное дерево объектов.
87
Если для конструктора нужны аргументы, то начинается рекурсивный процесс, во времоторого DI-контейнер будет повторять этот процесс для каждого типа аргумента до теор, пока все конструкторы не будут просмотрены.
В разделе "Конфигурирование DI-контейнеров" мы подробнее рассмотрим то, как можнонфигурировать контейнеры, а сейчас самое главное – это понять, что центральноастью конфигурации является то, как различные абстракции преобразуются онкретные классы. Все это звучит слегка теоретически (думаю, что слово "абстракция"
не поможет), поэтому я думаю, что пример будет очень полезным.
Пример: Автоматическая интеграция BasketController
В этом примере я буду объяснять, как, в принципе, работает автоматическая интеграция.
Пример не опирается ни на какой конкретный DI-контейнер, но вместо этогредоставляет обзор того, как контейнеры формируют диаграммы объектов.
Представьте себе, что вам нужно преобразовать экземпляр класса BasketController. Велаете это путем вызова метода Resolve для typeof(BasketController). В итоге ваотелось бы получить экземпляр BasketController, сформированный так, как этоказано на рисунке 2-26. Чтобы достичь этого, вы должны сначала убедиться, чтонтейнер имеет корректную конфигурацию. Таблица 3-1 демонстрирует, как этонфигурация преобразует абстракции в конкретные типы. Кроме того, я добавитолбец, который показывает, является ли абстракция интерфейсом или абстрактныазовым классом – с точки зрения DI-контейнера это очень важно, но я думал, что этоможет прояснить то, что происходит.
Таблица 3-1: Преобразование типов для обеспечения автоматической интеграции
BasketController
Тип абстракции Абстракция Конкретный тип
Явный BasketController BasketController
Интерфейс IBasketService BasketService
Абстрактный класс BasketRepository SqlBasketRepository
Абстрактный класс BasketDiscountPolicy RepositoryBasketDiscountPolicy
Абстрактный класс DiscountRepository SqlDiscountRepository
Строка connString "metadata=res://*/CommerceModel.csdl| […]"
Когда DI-контейнер получит запрос BasketController, первое, что он сделает – будескать тип в его конфигурации. BasketController – это конкретный класс, поэтому ореобразуется в самого себя. Затем контейнер использует рефлексию для осмотронструктора BasketController. Из раздела "Возможность добавления в корзину" вожете помнить, что BasketController обладает единственным конструктором следующей сигнатурой:
public BasketController(IBasketService basketService)
Поскольку этот конструктор не является конструктором по умолчанию, нам необходимовторить этот процесс для аргумента конструктора IBasketService, если муководствуемся общей блок-схемой, изображенной на рисунке 3-4.
88
Контейнер ищет IBasketService в своей конфигурации и обнаруживает, что
IBasketService преобразуется в конкретный класс BasketService. Единственныткрытый конструктор BasketService имеет следующу ю сигнатуру:
public BasketService(BasketRepository repository,
BasketDiscountPolicy discountPolicy)
Это все еще не конструктор по умолчанию, и теперь вы работаете с аргументами двуонструкторов. Контейнер осматривает каждый из аргументов по порядку, поэтому оачинает с класса BasketRepository, который согласно конфигурации преобразуется в
SqlBasketRepository.
SqlBasketRepository обладает открытым конструктором со следующей сигнатурой:
public SqlBasketRepository(string connString)
Единственный аргумент конструктора – это строковый параметр под названиеonnString, который сконфигурирован таким образом, что обладает конкретныначением. Теперь, когда у контейнера есть подходящее значение, он может вызватонструктор SqlBasketRepository. На данный момент контейнер успешно обрабатываараметр repository конструктора BasketService, но ему понадобится придержать этначение ненадолго, поскольку ему также нужно позаботиться и о параметрiscountPolicy.
Согласно конфигурации BasketDiscountPolicy преобразуется в конкретный класс
RepositoryBasketDiscountPolicy, который обладает следующим открытыонструктором:
public RepositoryBasketDiscountPolicy(DiscountRepository repository)
Выполняя поиск DiscountRepository в своей конфигурации, контейнер обнаруживаетто он DiscountRepository преобразуется в SqlDiscountRepository, который обладаеледующим конструктором:
public SqlDiscountRepository(string connString)
Ситуация совпадает с той, когда вы сталкивались с SqlBasketRepository. АргуменonnString преобразуется в конкретную строку соединения, которую контейнер можеередать в конструктор.
На данный момент контейнер передает новый экземпляр SqlDiscountRepository онструктор RepositoryBasketDiscountPolicy. Наряду с SqlBasketRepository, оеперь выполняет конструктор BasketService и вызывает его посредством рефлексии. В
конце концов, он передает вновь созданный экземпляр BasketService в конструктор
BasketController и возвращает экземпляр BasketController.
По существу это и есть то, как работает автоматическая интеграция, несмотря на то, чтна является более сложной, чем описанный процесс. DI-контейнерам также необходимаботиться об управлении жизненным циклом и, возможно, обращаться к технологинедрения через свойства, а также к другим более специфичным необходимым условияоздания зависимостей. Основной момент – это то, что технология внедрения череонструктор статически объявляет требования зависимости о наличии класса, а DI89
контейнер использует эту информацию для того, чтобы автоматически интегрироватиаграммы сложных объектов.
Как показывает пример, контейнер нужно сконфигурировать перед тем, как он сможеормировать диаграммы объектов. Регистрация компонентов может быть выполненазличными способами.
90
3.2. Конфигурирование DI-контейнеров
Несмотря на то, что метод Resolve – это место, где выполняются все действия, вы должнонимать, что потратите больше времени на конфигурацию API DI-контейнера.
Преобразование диаграмм объектов, в конечном счете, – это вызов единственного метода.
DI-контейнеры поддерживают две или три общие опции конфигурацииродемонстрированные на рисунке 3-5. Некоторые из них не поддерживаювтоматическую регистрацию, один из контейнеров не поддерживает технологиспользования кода в качестве конфигурации, в то время как XML конфигурациспользуется повсюду. Большинство контейнеров позволяют вам сочетать несколькодходов в одном приложении.
Рисунок 3-5: Наиболее универсальные способы конфигурирования DI-контейнераоказанные относительно таких параметров, как ясность и степень связывания.
Эти три опции конфигурации имеют разные характеристики, которые делают иолезными в различных ситуациях. И XML конфигурация, и использование кода ачестве конфигурации являются явно определенными, поскольку они требуют, чтобы мегистрировали каждый компонент в индивидуальном порядке. Автоматическаегистрация, с другой стороны, является более неявной, поскольку при этом подходспользуются условные обозначения для регистрации набора компонентов с помощьдиного правила.
При использовании кода в качестве конфигурации мы компилируем конфигурационтейнера в сборку, тогда как XML конфигурация позволяет нам поддерживать поздневязывание, при котором мы можем изменять конфигурацию без необходимости зановомпилировать приложение. В данном измерении автоматическая регистрация ниспадаеде-то до середины, поскольку мы можем попросить просмотреть единственную сборку,
91
которая известна во время компиляции или, в противном случае, просмотреть все сборк предопределенной папке.
В таблице 3-2 перечисляются преимущества и недостатки каждой опции.
Таблица 3-2: Опции конфигурации
Стиль Описание Преимущества Недостатки
XML
Настройконфигурации (часто в
.config файлах)
определяюреобразования.
Обеспечивает возможностамены без повторноомпиляции. Высокатепень контроля.
Отсутствуюроверки времомпиляции.
Оченодробный.
Использованиода в качествонфигурации
Код явно определяереоразования.
Проверки во времомпиляции. Высокатепень контроля.
Не поддерживаеозможностамены беовторноомпиляции.
Автоматическаегистрация
Для определениестоположениодходящиомпонентов остроениреобразованиспользуются правила.
Обеспечивает возможностамены без повторноомпиляции. Необходиминимальные усилия.
Помогает принудительныоглашениям сделать базода более логичной.
Частичныроверки времомпиляции.
Наименьшионтроль.
Традиционно DI-контейнеры начались с XML конфигурации, что также объясняет тоакт, что все контейнеры поддерживают данную опцию. Тем не менее, тенденциеастоящего времени является то, что эта возможность приуменьшается в пользу болесловных подходов. Несмотря на то, что автоматическая регистрация – это самаовременная опция, это не самое очевидное место для старта. Из-за своей неявности этозможность может казаться более абстрактной, нежели другие более явные опцииоэтому я буду рассматривать каждую опцию в историческом порядке, начиная с XML
конфигурации.
Конфигурирование контейнеров при помощи XML
Когда DI-контейнеры впервые появились в ранние 2000-е годы, все они использовали
XML в качестве механизма конфигурации – с тех пор многое изменилось. Более частоспользование XML в качестве механизма конфигурации в дальнейшем раскрыло тоакт, что такой подход изредка является самым лучшим.
XML является довольно подробным и хрупким. При конфигурировании DI-контейнера в
XML вы идентифициру ете различные классы и интерфейсы, но ваш компилятор ноддерживает возможность предупреждения вас о том, что вы что-то пропустили. Дажсли имена классов корректны, нет никакой гарантии, что необходимая сборка будеаходиться в исследуемом пути приложения.
Преимущество XML конфигурации – вы можете изменять поведение приложения беовторной компиляции. Это важно, если вы разрабатываете программное средство,
92
которое поставляется тысячам покупателей, потому что это дает им возможностамостоятельно настроить приложение. Как бы то ни было, если вы пишите внутреннериложение или веб-сайт, в котором вы управляете средой развертывания, чаще всегывает легче просто перекомпилировать и развернуть заново приложение в тех случаяхогда вам нужно изменить поведение.
Подсказка
Используйте XML конфигурацию только в тех случаях, когда вам очень хочетсбеспечить позднее связывание. Во всех остальных случаях отдайте предпочтение стилю
"код в качестве конфигурации" или автоматической регистрации.
DI-контейнер часто конфигурируется с помощью XML посредством направления его онкретный XML-файл, но иногда он также может подхватить конфигурацию и ионфигурационного файла приложения. В следующих примерах используется последняказанная опция.
Пример: Конфигурирова ние шаблонного коммерческого приложения с помощью
XML
Поскольку контейнер Unity является одним из самых XML-центрированных DI-
контейнеров, рассматриваемых в данной книге, имеет смысл использовать его длримера XML конфигурации.
В этом примере вы будете конфигурировать шаблонное коммерческое приложение иаздела "Расширение шаблонного приложения". Самая большая составляющая задачи –
применить конфигурацию, которая законспектирована в таблице 3-1, но кроме того волжны применить похожую конфигурацию для того, чтобы обеспечить композициласса HomeController. Следующий листинг демонстрирует конфигурациюеобходимую для поднятия и запуска приложения.
Листинг 3-1: Конфигурирование Unity при помощи XML
1. <register type="IBasketService" mapTo="BasketService" />
2. <register type="BasketDiscountPolicy"
mapTo="RepositoryBasketDiscountPolicy" />
3. <register type="BasketRepository" mapTo="SqlBasketRepository">
4. <constructor>
5. <param name="connString">
6. <value value="CommerceObjectContext"
7. typeConverter="ConnectionStringConverter" />
8. </param>
9. </constructor>
10. </register>
11. <register type="DiscountRepository" mapTo="SqlDiscountRepository">
12. <constructor>
13. <param name="connString">
14. <value value="CommerceObjectContext"
15. typeConverter="ConnectionStringConverter" />
16. </param>
17. </constructor>
18. </register>
19. <register type="ProductRepository" mapTo="SqlProductRepository">
20. <constructor>
21. <param name="connString">
22. <value value="CommerceObjectContext"
23. typeConverter="ConnectionStringConverter" />
93
24. </param>
25. </constructor>
26. </register>
27. <register type="CurrencyProvider" mapTo="SqlCurrencyProvider">
28. <constructor>
29. <param name="connString">
30. <value value="CommerceObjectContext"
31. typeConverter="ConnectionStringConverter" />
32. </param>
33. </constructor>
34. </register>
Строка 4-9: Определяет строку соединения
Строка 1: Простое преобразование
Как вы можете видеть даже из этого простого листинга кода, XML конфигурациостаточно подробна. Простые преобразования, подобные преобразованию интерфейса
IBasketService в класс BasketService, легко выражаются с помощью простого элементegister.
Тем не менее, как вы, возможно, помните, некоторые конкретные классы принимаютроку соединения в качестве входных данных, поэтому вам необходимо определитьаким образом находится значение этой строки. Что касается Unity, вы можете сделатто, указав, что вы используете пользовательский тип конвертера под названием
ConnectionStringConverter. Этот конвертер будет искать значение
CommerceObjectContext среди стандартных строк соединения web.config и возвращаттроку соединения с этим именем.
Оставшиеся элементы повторяют эти два паттерна.
Поскольку Unity может автоматически преобразовывать запросы в конкретные типы, дажсли отсутствуют явные регистрации, вам не нужно применять XML элементы для
HomeController и BasketController.
Загрузка конфигурации в контейнер выполняется при помощи вызова единственногетода:
container.LoadConfiguration();
Метод LoadConfiguration загружает XML конфигурацию из листинга 3-1 в контейнер.
После размещения конфигурации контейнер теперь может преобразовывать запросы в
HomeController и в другие.
Остальные DI-контейнеры также поддерживают XML конфигурацию. Точная XML-схемтличается для каждого контейнера, но всеобщая структура остается аналогичной.
Предупреждение
Как только ваше приложение будет вырастать в размерах и усложняться, тоже самоудет происходить и с вашим конфигурационным файлом, если вы используетонфигурационную композицию. Он может стать настоящим камнем преткновенияоскольку этот файл моделирует такие сущности кода, как классы, параметры и томодобное, но без преимуществ компилятора, опций отладки и т.д. Конфигурационные
94
файлы будут становиться хрупкими и непрозрачными с точки зрения наличия ошибокоэтому используйте данный подход только, если вам необходимо позднее связывание.
Из-за таких недостатков, как подробность и хрупкость, вам следует воспользоватьсругими альтернативами для конфигурирования контейнеров. Технология использованиода в качестве конфигурации схожа с XML конфигурацией по глубине детализации и понцепции, но очевидно использует код вместо XML.
Конфигурирование контейнеров с помощью кода
Возможно, самый легкий способ компоновки приложения – написать код, которыыполняет компоновку. Может показаться, что такой подход идет в разрез со всеущностью механизма внедрения зависимостей, потому что он жестко кодирует то, какионкретные реализации должны использоваться для всех абстракций. Тем не менее, еслто выполняется в Composition Root, то оно изменяет только одно из преимуществеречисленных в таблице 1-1.
Преимущество позднего связывания теряется, если зависимости жестко закодированы, ноак я уже упоминал в главе "Дегустационное меню" механизма внедрения зависимостей"то может и не иметь отношения ко всем типам приложений. Если ваше приложениазворачивается в ограниченное количество экземпляров в контролируемой среде, былы проще заново скомпилировать и развернуть приложение, когда вам нужно заменитодули.
Я часто думаю, чт о люди чересчур ревност но относятся к определенионфигурационных файлов. Част о язык программирования является прямолинейным ощным механизмом конфигурирования.
Март ин Фаулер
При использовании кода в качестве конфигурации мы явно устанавливаем такие же самыискретные преобразования, которые мы устанавливали при использовании XML
конфигурации – только мы используем код вместо XML.
За единственным исключением в виде Spring.NET, все DI-контейнеры полностьоддерживают технологию использования кода в качестве конфигурации кальтернативы XML конфигурации – в действительности, в большинстве из них этехнология присутствует в виде используемого по умолчанию механизма, а XML
конфигурация используется в качестве необязательной возможности.
API, открытый для поддержки технологии использования кода в качестве конфигурациитличается для каждого DI-контейнера, но всеобщей целью все еще остается определениискретных преобразований между абстракциями и конкретными типами.
Подсказка
Используйте код в качестве конфигурации вместо XML конфигурации, за исключениеех моментов, когда вам нужно позднее связывание. Компилятор может быть полезным, а
Visual Studio, которая формирует систему, будет автоматически копировать всеобходимые зависимости в выходную папку.
95
Многие конфигурационные API используют дженерики и Fluent Builders для регистрациомпонентов; StructureMap – не исключение.
Пример: Конфигурирова ние шаблонного коммерческого приложения с помощьода
В разделе "Конфигурирование контейнеров при помощи XML" вы увидели, каконфигурировать шаблонное коммерческое приложение с помощью XML, используя
Unity. Я также мог бы продемонстрировать использование кода в качестве конфигурациа примере Unity, но в этом примере я буду использовать StructureMap; так как обладает более выразительным API, он лучше подходит для страниц этой книги.
Используя конфигурационное API StructureMap, вы можете выразить конфигурацию иистинга 3-1 более компактно, как это продемонстрировано в следующем листинге.
Листинг 3-2: Конфигурирование StructureMap с помощью код.For<IBasketService>()
.Use<BasketService>();
c.For<BasketDiscountPolicy>()
.Use<RepositoryBasketDiscountPolicy>();
string connectionString = ConfigurationManager
.ConnectionStrings["CommerceObjectContext"].ConnectionString;
c.For<BasketRepository>().Use<SqlBasketRepository>()
.Ctor<string>().Is(connectionString);
c.For<DiscountRepository>().Use<SqlDiscountRepository>()
.Ctor<string>().Is(connectionString);
c.For<ProductRepository>().Use<SqlProductRepository>()
.Ctor<string>().Is(connectionString);
c.For<CurrencyProvider>().Use<SqlCurrencyProvider>()
.Ctor<string>().Is(connectionString);
Сравните этот код с кодом из листинга 3-1 и заметьте, насколько он более компактен –
несмотря на то, что выполняет он тоже самое. Такое простое преобразование, кареобразование IBasketService в BasketService, выражается с помощью видовыетодов For и Use. Переменная c фактически является так называемым
ConfigurationExpression, но воспринимайте ее как контейнер.
Для того чтобы поддержать те классы, для которых нужна строка соединения, вродолжаете последовательность For/Use путем вызова метода Ctor и передачи строкоединения. Метод Ctor выполняет поиск строкового параметра в конструкторонкретного класса и использует переданное значение для этого параметра.
Остальная часть кода повторяет эти два паттерна.
Использование кода в качестве конфигурации не только компактнее XML конфигурациио также поддерживается компилятором. Типы аргументов, используемые в листинге 3-2редставляют собой реальные типы, которые проверяет компилятор. Переменное API
StructureMap поставляется даже с некоторыми видовыми ограничителями, которыообщают компилятору о проверке того, совпадает ли тип, определяемый методом Use бстракциями, обозначенными с помощью метода For. Если преобразование невозможноо код не компилируется.
Несмотря на то, что технология использования кода в качестве конфигурации безопасна роста в применении, ее нужно больше сопровождать, нежели вам того хотелось. Каждый
96
раз при добавлении в приложение нового типа вы также должны помнить и о егегистрации – а многие регистрации похожи друг на друга. Автоматическая регистрацитносится к этой теме.
Конфигурирование контейнеров с помощью соглашений
Обратили ли вы в листинге 3-2 внимание на то, насколько схожи большинствегистраций? В частности все компоненты доступа к данным, базирующиеся на SQL
Server, руководствуются универсальным паттерном в тех случаях, когда вонфигурируете компонент подходящей строкой соединения.
Неоднократное написание такого кода регистрации нарушает принцип DRY (Don't Repeat
Yourself – Не повторяйся). К тому же он выглядит как непродуктивный фрагмент коднфраструктуры, который не добавляет особую значимость в приложение. Вы можетэкономить время и допустить меньшее количество ошибок, если сможетвтоматизировать процесс регистрации компонентов.
Все более популярной становится архитектурная модель – "соглашения по конфигурации"
(Convention over Configuration). Вместо того чтобы писать и поддерживать большибъемы конфигурационного кода, вы можете принять соглашения, которые влияют назу кода.
Способ, при помощи которого ASP.NET MVC находит контроллеры по их именам, – эттличный пример простого соглашения.
1. Поступает запрос контроллера с именем Home.
2. Используемая по умолчанию фабрика контроллеров ищет в списке известныространств имен класс с названием HomeController. Если она находит таколасс и этот класс реализует IController, то это как раз то, что нужно.
3. Используемая по умолчанию фабрика контроллеров использует конструктор пмолчанию найденного класса для того, чтобы создать экземпляр контроллера.
Здесь используются, по крайней мере, два соглашения: контроллер должен иметь название
[Имя контроллера]Controller и должен обладать конструктором по умолчанию.
Вы можете отступить от этих соглашений посредством реализации своей собственной
IControllerFactory, а это как раз то, что я и делал до настоящего времени, чтободдержать технологию внедрения через конструктор – более подробно я будассуждать об этом в главе "Построение объектов".
Было бы здорово, если бы вам удалось использовать несколько соглашений для тоготобы избавиться от всех этих приводящих к ошибкам и трудоемким конфигурацияонтейнеров. Для DefaultControllerFactory добавлять новые контроллеры такжросто, как и добавлять соответствующе названный класс в корректное пространствмен. Нам бы хотелось сохранить это соглашение даже при использовании технологинедрения через конструктор.
Многие DI-контейнеры предоставляют возможности автоматической регистрацииоторые позволяют нам вводить свои собственные соглашения.
О пределение
97
Автоматическая регистрация – это возможность автоматически регистрироватомпоненты в контейнере путем поиска реализаций необходимых абстракций в одной илолее одной сборке.
Соглашения можно применять не только к контроллерам ASP.NET MVC. Чем большоглашений вы добавляете, тем больше вы сможете автоматизировать различныоставляющие конфигурации контейнеров.
Подсказка
Принцип "Соглашения по конфигурации" имеет больше преимуществ, нежели простоддержка DI конфигурации. Он делает ваш код более последовательным, поскольку коудет автоматически работать, пока вы будете следовать вашим соглашениям.
В действительности вам может понадобиться комбинировать автоматическуегистрацию с технологией использования кода в качестве конфигурации или XML
конфигурацией, поскольку у вас может не получиться приспособить каждый единичныомпонент к значимому соглашению. Тем не менее чем больше вы сможете приспособиташу базу кода к соглашениям, тем более поддерживаемым он будет.
Пример: Конфигурирова ние шаблонного коммерческого приложения с помощьеханизма автоматической регистрации
StructureMap поддерживает автоматическую регистрацию, но думаю, было бы болентереснее использовать все-таки другой DI-контейнер для конфигурированиаблонного коммерческого приложения при помощи соглашений. Я выбрал Autofacоскольку он обладает достаточно читабельным API автоматической регистрации.
Если вы рассмотрите листинги 3-1 и 3-2, то надеюсь, что вы согласитесь с тем, чтегистрирование различных компонентов доступа к данным – это наиболеовторяющиеся части кода. Можем ли мы выразить для них соглашение некоторого рода?
Все четыре конкретных типа обладают следующими общими характеристиками:
? Все они определены в одной и той же сборке.
? Каждый из них является конкретным классом, унаследованным от абстрактногазового класса.
? Имя каждого из них начинается с Sql.
? Каждый из них обладает единственным открытым конструктором, которыринимает строковый параметр с названием connString.
Кажется, будто соответствующее соглашение будет выражать эти сходства путеросмотра соответствующей сборки и регистрирования всех классов, которыоответствуют соглашению. Для Autofac это выглядело бы следующим образом:
string connectionString = ConfigurationManager
.ConnectionStrings["CommerceObjectContext"]
.ConnectionString;
var a = typeof(SqlProductRepository).Assembly;
builder.RegisterAssemblyTypes(a)
.Where(t => t.Name.StartsWith("Sql"))
.As(t => t.BaseType)
.WithParameter("connString", connectionString);
98
Это отдельное соглашение должно просматривать сборку, которая содержит компонентоступа к данным. Существует несколько способов получения ссылки на эту сборку, намый простой способ – подобрать характерный тип, например SqlProductRepository, олучить сборку из него. Вы могли бы выбрать и другой класс или найти сборку пмени.
Теперь, когда у вас есть сборка, вы можете сообщить контейнеру о том, что вы хотитросмотреть ее. Метод RegisterAssemblyTypes указывает на намерение регистрироватсе типы сборки, которые соответствуют критерию, согласно которому имя класса должначинаться Sql. Переменная builder – это экземпляр класса ContainerBuilder, но вожете считать, что он является контейнером.
Каждый из классов, которые выполняют это с помощью фильтра Where, должны бытарегистрированы относительно их базового класса. Например, базовым классом
SqlProductRepository является ProductRepository, его можно получить путереобразования ProductRepository в SqlProductRepository.
В конце концов, вы утверждаете, что каждый конструктор обладает параметроonnString и что его значение необходимо определить по строке соединения, считанноз конфигурационного файла.
Сравнения этого соглашения с четырьмя регистрациями листинга 3-2 может бытедостаточно, поскольку мы также поддерживаем два других DI-контейнера. Вы все ещожете думать, что это преимущество выглядит незначительным. Тем не менееоглашение масштабирует намного лучше.
Поскольку в текущем примере присутствует только четыре компонента доступа к даннымы сохраняете всего несколько операторов с помощью соглашений. Несмотря на это, каолько соглашение записано, оно управляет сотнями компонентов без особых усилий.
Вы также можете обратиться к другим преобразованиям из листингов 3-1 и 3-2
посредством соглашений, но на данный момент от этого не будет никакой пользы. В
качестве примера вы можете зарегистрировать все сервисы с помощью следующегоглашения:
builder.RegisterAssemblyTypes(typeof(BasketService).Assembly)
.Where(t => t.Name.EndsWith("Service"))
.AsImplementedInterfaces();
Это соглашение просматривает определенну ю сборку на факт наличия типов, названиоторых заканчиваются на Service, и регистрирует каждый тип относительннтерфейса, который он реализует. Фактически это соглашение регистрирует
BasketService относительно интерфейса IBasketService, но поскольку в настоящеремя у вас нет никаких других совпадений с этим соглашением, вы ничего из этого нолучаете. Однако возможно имеет смысл сформулировать соглашение заранее для тоготобы вдохновить разработчиков на следование этому соглашению.
Автоматическая регистрация – это мощная технология, которая имеет все необходимоетобы сделать DI-контейнер невидимым. После размещения соглашений вам, возможноонадобится изменять конфигурацию контейнера только в редких случаях.
99
До настоящего момента вы видели три разных подхода к конфигурированию DI-
контейнера:
? XML
? Использование кода в качестве конфигурации
? Автоматическая регистрация
Ни один из них не является взаимно исключающим. Вы можете выбрать варианмешивания автоматической регистрации с определенными преобразованиями абстракци конкретные типы, и даже смешать все три подхода, чтобы немножко выполнятвтоматическую регистрацию, немножко использовать код в качестве конфигурации, акже иметь немного конфигурации в XML для целей позднего связывания.
В качестве эмпирического правила вам следует использовать автоматическуегистрацию как стартовую точку, дополненную технологией использования кода ачестве конфигурации для управления более особыми случаями. Вам следует сохранить
XML для тех случаев, когда вам нужно уметь изменять реализацию без повторноомпиляции приложения (что намного реже, нежели вы думаете).
Теперь, когда мы узнали, как сконфигурировать DI-контейнер и как с помощью негреобразовывать диаграммы объектов, вы должны представлять, как это использовать.
Использование DI-контейнера – это одно, а вот корректное его использование – этругое.
100
3.3. Паттерны DI-контейнеров
DI-контейнеры – это мощные инструменты, но, как и для всех инструментов, существуюорректные и некорректные способы их использования. Так же, как и повара знают, чтужно бережно относиться к своим ножам, так и вы должны знать, что следует правильнбращаться с вашим DI-контейнером – он не может отрубить вам пальцы, но вы можете получить те преимущества, которыми он обладает.
Самое важное, что вам нужно понять – в каком месте архитектуры приложения следуеспользовать DI-контейнер. После того, как вы это поймете, вам еще нужно будет знатьаким образом его использовать. Следующие два мини-паттерна предоставляют ответы нти вопросы.
Composition Root
В каком месте нам следует формировать диаграммы объект ов?
Как можно ближе к точке входа в приложение.
DI-контейнер – это библиотека, которую вы можете использовать в тех местах, в которыолько пожелаете – но это не означает, что вы должны его использовать. Несмотря на тото вы можете расширить использование контейнера таким образом, чтобы оаспространился на огромное количество ваших классов, вместо этого сосредоточьте его динственной области своего приложения. Это место называется Composition Root, и валедует использовать DI-контейнер только из этого места.
Сущность Composition Root особо не связана с DI-контейнерами. Composition Root такжрименяется в тех случаях, когда вы используете Poor man's DI, но я думаю, что важнбсудить Composition Root именно в этом контексте, поскольку понимание этого паттернозволяет вам использовать ваш DI-контейнер корректно и эффективно. Перед тем, как риступлю к обсуждению роли Composition Root при использовании DI-контейнеров, ратко, в общих чертах, рассмотрю его.
Рисунок 3-6: При формировании приложения из множества слабо связанных классоомпозиция должна осуществляться как можно ближе к точке входа в приложение.
Composition Root формирует диаграмму объектов, которая затем выполняет фактическуаботу приложения.
101
Composition Root как основная сущность
При написании слабо связанного кода вы создаете множество классов, которые волжны скомпоновать для того, чтобы создать приложение. Компоновать незначительнооличество этих классов в единицу времени может быть довольно заманчивой идеей длоздания небольших подсистем, но такой подход ограничивает вашу способностерехватывать эти системы с целью модификации их поведения. Вместо этого вы должномпоновать все классы одновременно.
Определение
Com position Root – это (предпочтительно) уникальное местоположение в приложении, гдодули соединяются друг с другом.
Подсказка
Com position Root может разворачиваться в рамках составных классов, пока онасполагаются в единственном модуле.
При изолированном рассмотрении Constructor Injection вас может заинтересовать такоопрос: "не перемещает ли он решение о выборе зависимости всего лишь в другоесто?". Да, это именно так, и это хорошо; это означает, что вы получаете центральноесто, в котором можете соединять классы. Composition Root играет роль стороннегомпонента, который связывает покупателей с их сервисами. В действительности, Нэт
Прайс предпочитает термин "Стороннее соединение" вместо "механизм внедрениависимостей" именно по этой причине.
Чем дольше вы будете откладывать принятие решения о том, как соединять классы, теольше вы будете сохранять ваши опции открытыми. Таким образом, Composition Rooеобходимо размещать как можно ближе к точке входа в приложение.
Примечание
Мне нравится думать о Composition Root как об архитектурном эквиваленте понятия
Бережливой разработки программного обеспечения (Lean Software Development):
Последний ответственный момент. Смысл в том, чтобы откладывать все решениастолько долго, насколько это позволяют правила приличия (но не дольше), потому что
102
нам хотелось бы сохранять наши опции открытыми и основывать наши решения на каожно большем объеме информации. Когда дело доходит до компоновки приложений, можем таким же образом отложить принятие решения о передаче зависимостей снование приложения.
Даже у модульного приложения, которое для своего формирования использует слабовязывание и позднее связывание, есть основание, которое содержит точку входа риложение. Ниже приведены примеры:
? Консольное приложение – исполняемый файл (.exe) с методом Main.
? ASP.NET веб-приложение – это библиотека (.dll) с обработчиком событий
Application_Start в файле Global.asax.
? WPF приложение – исполняемый файл (.exe) с файлом App.xaml.
? WCF сервис – это библиотека (.dll) с классом, который наследуется от интерфейсервиса, несмотря на то, что вы можете заполучить более низкоуровневую точкхода путем создания пользовательско й ServiceHostFactory.
Существует множество других технологий, но общим для всех этих технологий являетсо, что один модуль содержит точку входа в приложение: это основание приложения, чтроиллюстрировано на рисунке 3-7. Composition Root приложения должно располагатьс основании приложения таким образом, чтобы оно могло правильно формироватриложение.
Рисунок 3-7: Точка входа в приложение – это основание модульного приложения. Либапрямую, либо не напрямую основание использует остальные модули. Composition Rooолжно размещаться в основании приложения – как можно ближе к точке входа
Вы не должны пытаться компоновать классы в любом модуле, потому что такой подхограничивает ваши возможности. Все классы модулей приложения должны использовать
Constructor Injection (или, в редких случаях, один из других паттернов, описанный в главе
"DI-паттерны") и оставлять задачу формирования диаграммы объектов приложения за
103
Com position Root. Любой используемый DI-контейнер должен быть ограничен
Com position Root.
Использование DI-контейнера в Composition Root
DI-контейнер может ошибочно использоваться в качестве Service Locator, но его можнспользовать только как движок, который формирует диаграммы объектов. Прассмотрении DI-контейнера с этой точки зрения имеет смысл ограничить его Composition
Root. Такой подход также имеет большое преимущество, заключающееся в удалениюбого связывания между DI-контейнером и остальной частью базы кода.
Подсказка
К DI-контейнеру следует обращаться из Composition Root. Все остальные модули нолжны ссылаться на контейнер.
На рисунке 3-8 вы можете увидеть, что только Composition Root ссылается на DI-
контейнер. Остальная часть приложения не имеет ссылок на контейнер и вместо неголагается на паттерны, описанные в главе "DI-паттерны". DI-контейнеры понимают этаттерны и используют их для того, чтобы формировать диаграмму объектов приложения.
Рисунок 3-8: Только Composition Root, содержащееся в основании приложения, должнметь ссылку на DI-контейнер. Все остальные модули приложения должны целикоолагаться на DI-контейнеры и не ссылаться на контейнер
Com position Root может быть реализован с DI-контейнером. Это означает, что вспользуете контейнер для формирования полноценной диаграммы объектов приложени вызове единственного метода Resolve. Всякий раз, когда я говорю разработчикам о том,
104
чтобы они поступали именно так, я всегда могу сказать, что это доставляет им неудобстваоскольку они боятся, что это ужасно неэффективно и неудобно для выполнения. Вам нридется об этом беспокоиться, потому что это почти никогда не случается, и в теемногих ситуациях, когда это происходит, существуют способы решения этой проблемы.
Подсказка
Не беспокойтесь об издержках выполнения, возникающих в ситуациях, когда DI-
контейнер используется для формирования большой диаграммы объектов. Это почтикогда не является проблемой.
Когда дело касается приложений, в основе которых лежат запросы, например веб-сайтоли сервисов, вы можете сконфигурировать контейнер всего один раз, нреобразовывать диаграмму объектов для каждого входящего запроса. Шаблоннооммерческое приложение является примером такой ситуации.
Пример: Реализация Composition Root
Шаблонное коммерческое приложение из раздела "Расширение шаблонного приложения"
должно обладать Composition Root для того, чтобы формировать диаграммы объектов длходящих HTTP-запросов. Что касается всех остальных .NET веб-приложений, то для ниочкой входа является метод Application_Start файла Global.asax.
В этом примере я использую DI-контейнер Castle Windsor, но код может быть таким же ля любого другого контейнера. Для Castle Windsor метод Application_Start мог быглядеть следующим образом:
protected void Application_Start()
{
MvcApplication.RegisterRoutes(RouteTable.Routes);
var container = new WindsorContainer();
container.Install(new CommerceWindsorInstaller());
var controllerFactory = new WindsorControllerFactory(container);
ControllerBuilder.Current.SetControllerFactory(controllerFactory);
}
Перед тем как вы сможете сконфигурировать контейнер, вы должны создать новыкземпляр. Поскольку полноценная установка приложения инкапсулирована в классе поазванием CommerceWindsorInstaller, вы инсталлируете его в контейнер для того, чтобастроить этот контейнер. Код CommerceWindsorInstaller, очевидно, реализован омощью API Castle Windsor, но концептуально он идентичен примеру из раздела
"Конфигурирование DI-контейнеров".
Для того чтобы позволить контейнеру подключать контроллеры в приложение, волжны применить соответствующий шов ASP.NET MVC, который называется
IControllerFactory (подробно рассматривается в разделе "Построение ASP.NET MVC
приложений"). На данный момент достаточно понимать, что для интеграции с ASP.NET
MVC вы должны создать адаптер в рамках контейнера и сообщить об этом фреймворку.
Поскольку метод Application_Start выполняется всего лишь раз, контейнер являетсдинственным экземпляро м, который инициализируется всего один раз. При получении
105
запросов этот экземпляр контейнера должен обрабатывать все запросы одновременно – носкольку все контейнеры реализованы с помощью методов Resolve, корректнсполняемых в многопоточной среде, это не является проблемой.
Поскольку вы устанавливаете ASP.NET MVC с пользовательско й
WindsorControllerFactory, он будет вызывать ее метод GetControllerInstance длаждого входящего HTTP-запроса (подробнее об этом вы можете прочитать в разделе
"Построение ASP.NET MVC приложений"). Реализация делегирует работу контейнеру:
protected override IController GetControllerInstance(
RequestContext requestContext, Type controllerType)
{
return (IController)this.container.Resolve(controllerType);
}
Обратите внимание на то, что вы более или менее вернулись к вводным примерам иаздела "Контейнер "Hello"". Метод Resolve формирует окончательную диаграммуоторая должна использоваться для этого конкретного запроса, и возвращает этиаграмму. Это единственное место в приложении, где вы вызываете метод Resolve.
Подсказка
База кода приложения должна содержать единственный вызов метода Resolve.
В этом примере Composition Root развернут в рамках нескольких классов, чтродемонстрировано на рисунке 3-9. Это предсказуемо – важно, что все классодержатся в одном и том же модуле, которым в данном случае является основанириложения.
Рисунок 3-9: Com position Root развернут в рамках трех классов, но все они определены ределах одного и того же модуля
Самое важное, на что здесь нужно обратить внимание, – это то, что эти три классвляются единственными классами во всем шаблонном приложении, которые ссылаютса DI-контейнер. Вся остальная часть кода приложения использует только паттерн
Construction Injection; вернитесь назад и перечитайте главу "Комплексный пример", еслы мне не верите.
Подсказка
Мне хотелось бы обобщить все правила, содержащиеся в данном разделе, перефразироваолливудский принцип: не вызывайте контейнер; он сам вызовет вас.
106
Comm on Service Locator
Существует проект с открытым исходным кодом под названием Common Service Locator
(http://commonservicelocator.codeplex.com/), целью которого является отсоединение кодриложения от конкретного DI-контейнера путем скрытия каждого контейнера зниверсальным интерфейсом IServiceLocator.
Надеюсь, что такое объяснение того, как Composition Root эффективно отделяестальную часть кода приложения от DI-контейнеров, теперь позволит вам понятьочему вам не нужен Comm on Service Locator. Как я буду объяснять в разделе "Service
Locator", в связи с тем, что Service Locator является анти-паттерном, будет лучше нспользовать его – тем более с Com position Root он вам и не нужен.
Более подробно о том, как реализовывать Composition Roots в различных фреймворках
(включая ASP.NET MVC), вы можете прочитать в главе "Построение объектов". В данноонтексте то, как вы это делаете, более важно, чем то, где вы это делаете. Как одразумевает его название, Composition Root – это составляющая основания приложения которой вы компонуете все слабо связанные классы. Это справедливо и прспользовании DI-контейнера, и при использовании Poor Man's DI. Т ем не менее, прспользовании DI-контейнера вам следует руководствоваться паттерном Register Resolve
Release.
Register Resolve Release
Как нам следует использовать DI-контейнер?
Следуя строгой последовательности вызовов методов Register Resolve Release
Паттерн Composition Root описывает то, где вам следует использовать DI-контейнер. Тее менее, он не сообщает о том, как его использовать. Паттерн Register Resolve Releasтвечает на этот вопрос.
DI-контейнер следует использовать в трех, следующих друг за другом фазах называемых
Register, Resolve и Release. В таблице 3-3 более подробно описана каждая из этих фаз.
Определение
Паттерн Register Resolve Release указывает на то, что методы DI-контейнера должнызываться в этой строгой последовательности: Регистрация (Register), Решение (Resolve)
и Освобождение (Release) (см. рисунок 3-10).
Рисунок 3-10: Методы DI-контейнера должны вызываться в продемонстрированнотрогой последовательности: сначала метод Register, затем метод Resolve и в завершениетод Release
107
Таблица 3-3: Фазы контейнера
Фаза Что происходит на данной фазе? Что прочитать дальше
Register
Регистрация компонентов контейнера.
Вы конфигурируете контейнер, сообщая ему ом, какие классы он может использовать, каму следует преобразовывать абстракции онкретные типы и о том (необязательнанформация), как определенные классолжны соединяться вместе.
В разделе "Конфигурирование
DI-контейнеров" я уже обсуждао, как сконфигурировать DI-
контейнер.
В части "DI-контейнеры" я будодробно обсуждатонфигурацию шестндивидуальных DI-
контейнеров.
Resolve
Преобразует компоненты основания.
Запрос одного типа преобразуется в одниаграмму объектов.
В разделе "Знакомство с DI-
контейнерами" мы увидели, кареобразовывать диаграммбъектов с помощью DI-
контейнера.
В части "DI-контейнеры" вожете более подробно почитатб API конкретных контейнеров.
Release
Освобождает компоненты из контейнера.
Все диаграммы объектов, образованные нредыдущей фазе, должны быть освобожден тот момент, когда в них уже нет нужды. Этигнализирует о том, что контейнер можечистить диаграмму объектов, что определеннажно в тех случаях, когда некоторыомпоненты являются лишними.
В главе "Жизненный цикбъектов" я обсуждаю вопроправления жизненным циклобъектов, включая важностроцесса очистки объекта.
Кроме того в части "DI-
контейнеры" я рассматриваю API
управления жизненным циклондивидуальных DI-
контейнеров.
Вы должны использовать эти три фазы в правильном порядке и вам не разрешается волей-
неволей двигаться назад или вперед. К примеру, вам не следует возвращаться и зановонфигурировать контейнер, как только вы приступили к преобразованию диаграммбъектов. Иногда люди спрашивают о том, как добавить в контейнер дополнительныомпоненты уже после того, как они приступили к преобразованию компонентов. Нелайте этого – это принесет вам одни огорчения.
Примечание
Некоторые DI-контейнеры не поддерживают явный Release диаграмм объектов и вместтого полагаются на .NET сборщика мусора (garbage collector). При использовании такионтейнеров вы должны применять модифицированный паттерн Register Resolve бращаться к потенциальным утечкам ресурсов в ваших реализациях объекта. Болеодробно читайте об этом в главе "Жизненный цикл объектов".
В следующем разделе я буду говорить о методах Register, Resolve и Release, а также азах. Castle Windsor действительно обладает тремя методами с точно такими же
108
названиями, а фазы названы в честь этих методов. Другие DI-контейнеры могуспользовать другие названия, но их основополагающая сущность идентична. Я
использую названия только Castle Windsor, поскольку они обеспечивают логичнуерминологию – а также приятную аллитерацию.
С татическая структура
В своем истинном представлении паттерн Register Resolve Release утверждает, что валедует выполнять вызов только одного метода в каждой фазе. Кшиштоф Козмиазывает это паттерном трех вызовов (T hree Calls Pattern) – вам разрешено сделать толькри вызова методов в контейнере.
Методы Resolve и Release упрощают это. В разделе "Composition Root" я уже утверждал ом, что в приложении должен содержаться единственный вызов метода Resolve. Каледствие вы должны всегда выпускать то, что вы преобразовываете.
Подсказка
Любая диаграмма объектов, сформированная с помощью метода Resolve, должна бытписана при помощи метода Release.
Конфигурирование DI-контейнера в единственном вызове метода требует болеодробных разъяснений. Причиной того, что регистрация компонентов должнроисходить в рамках единственного вызова метода, является то, что вы должнасценивать конфигурацию DI-контейнера как единичное, элементарное действие. Пославершения конфигурации контейнер должен расцениваться как доступный только длтения.
Autofac даже делает это представление явным при помощи выделения конфигурационтейнера в отдельный ContainerBuilder: вы регистрируете компоненты с помощью
ContainerBuilder, и когда вы делаете это, вы просите ContainerBuilder создаткземпляр контейнера из конфигурации. В Autofac вы не конфигурируете контейнеапрямую.
При рассмотрении конфигурации в виде элементарного действия становится прощправлять кодом конфигурации, поскольку становится очевидным, в каком месте онолжна выполняться. Многие DI-контейнеры также используют эту концепцию для тоготобы замораживать конфигурацию, как только вы приступаете к преобразованииаграмм объектов из него. Т акой подход заставляет их выполняться лучшим образом.
Если вы вспомните листинг 3-2, то можете заявить, что он содержит более одного вызоветода. Регистрация всегда включает в себя множество операторов, но большинство DI-
контейнеров обладают механизмом пакетирования, который позволяет инкапсулироватсе эти конфигурационные операторы в единственном классе (возможно состоящим иругих классов). Autofac называет их модулями (Modules), StructureMap называет иеестрами (Registries), а Castle Windsor – инсталляторами (Installers). Общим для всех нивляется тот факт, что все они могут использоваться для конфигурации контейнера омощью единственного вызова метода. В разделе "Composition Root" вы уже видели, как
Castle Windsor использует инсталлятор:
container.Install(new CommerceWindsorInstaller());
109
Для DI-контейнеров, не обладающих механизмом пакетирования, вы всегда можетоздать пользовательский класс, который инкапсулирует конфигурацию в единичноетоде.
К совету, заключающемус я в том, что для Resolve и Release необходимо использоватолько по одной единственной строке кода, следует отнестись серьезно – но для фазы
Register данный факт должен восприниматься более концептуально. Важным вопросовляется тот факт, что регистрация должна быть завершена до вызова метода Resolve.
Рисунок 3-11 иллюстрирует то, как выглядит последовательность, включая инкапсуляциножества вызовов метода Register.
Рисунок 3-11: На фазе Register может иметь место любое количество вызовов метода
Register, но вы все еще должны расценивать его как элементарное действие. На фазах
Resolve и Release вам, буквально, нужно только по одному вызову каждого метода.
Универсальным источником заблуждений является то, что паттерн трех вызовов создаевердое убеждение о том, как часто каждый метод должен появляться в базе кода, но оичего не говорит о том, сколько раз он должен вызываться.
Динамическое взаимодействие
Название паттерна Three Calls Pattern может привести вас к мысли о том, что каждыетод должен вызываться всего лишь раз. Источник этого заблуждения находится в самоазвании, и это одна из нескольких причин того, почему я предпочитаю название Register
Resolve Release.
Паттерн Three Calls утверждает, что для вызова каждого метода должна существоватдинственная строка кода. Тем не менее, в зависимости от обстоятельств, некоторыетоды могут вызываться более одного раза.
В однопоточном приложении таком, как настольное приложение, утилита команднотроки или пакетное задание, каждый метод обычно вызывается только один раз, чтроиллюстрировано на рисунке 3-12.
Рисунок 3-12: В однопоточном приложении каждый метод будет вызываться только одиаз. За конфигурацией контейнера непосредственно следует формирование диаграммбъектов приложения, которая выполняет реальную работу. После окончания работеред выходом из приложения вызывается метод Release.
110
В приложениях, основанных на запросах, таких, как веб-сайт, веб-сервис или получателсинхронного сообщения, Composition Root формирует диаграмму объектов для каждогходящего запроса. В этом типе приложения, как это проиллюстрировано на рисунке 3-13етод Register вызывается только один раз, тогда как методы Resolve и Releasызываются попарно для каждого запроса – потенциально большее число раз.
Рисунок 3-13: В приложениях, основанных на запросах, метод Register вызывается толькдин раз, тогда как методы Resolve и Release вызываются много раз – по одному наждый запрос
Важно отметить, что вам нужно сконфигурировать контейнер только один раз. Контейнер
– это совместно используемый экземпляр, применяемый для преобразования составныапросов, но конфигурация должна оставаться стабильной и завершенной.
Динамическая картина Register Resolve Release – это почти инверсия статическогредставления – сравните рисунок 3-11 и рисунок 3-13. В статическом представлении мопускаем составные строки кода, которые вызывают метод Register, а в динамическо редставлении этот блок кода должен вызываться строго один раз. С другой сторонытатическим правилом является то, что вы должны иметь только одну строку кодаоторая вызывает Resolve и Release, но во время выполнения они могут вызываться многаз.
Это может казаться сложным и трудным, но как демонстрирует следующий пример, этогсего лишь вызовы трех методов.
Пример: использование Register Resolve Release
В данном примере вы будете реализовывать Composition Root шаблонного приложения иаздела "Расширение шаблонного приложения" с помощью DI-контейнера Castle Windsor.
Это тот же самый контейнер, который вы использовали в примере раздела "Composition
Root", поэтому этот пример нужно читать как продолжение предыдущего.
Точкой входа в приложение является метод Application_Start, и поскольку этриложение является веб-сайтом, фаза Register изолирована от фаз Resolve и Releaseотому что вы должны сконфигурировать контейнер всего лишь раз. Код остается такие, как и в предыдущем примере, но я хочу немного сместить фокус:
111
protected void Application_Start()
{
MvcApplication.RegisterRoutes(RouteTable.Routes);
var container = new WindsorContainer();
container.Install(new CommerceWindsorInstaller());
var controllerFactory = new WindsorControllerFactory(container);
ControllerBuilder.Current.SetControllerFactory(controllerFactory);
}
Согласно паттерну Register Resolve Release вызов первого метода, который вы совершаетля экземпляра container, должен быть вызовом элементарного Register. В даннолучае метод называется Install и CommerceWindsorInstaller инкапсулируендивидуальные регистрации в единственном классе. Следующий листинг демонстрируееализацию CommerceWindsorInstaller.
Листинг 3-3: Инкапсуляция составных регистраций
1. public class CommerceWindsorInstaller : IWindsorInstaller
2. {
3. public void Install(IWindsorContainer container,
IConfigurationStore store)
4. {
5. container.Register(AllTypes
6. .FromAssemblyContaining<HomeController>()
7. .BasedOn<IController>()
8. .Configure(r => r.LifeStyle.PerWebRequest));
9.
10. container.Register(AllTypes
11. .FromAssemblyContaining<BasketService>()
12. .Where(t => t.Name.EndsWith("Service"))
13. .WithService
14. .FirstInterface());
15.
16. container.Register(AllTypes
17. .FromAssemblyContaining<BasketDiscountPolicy>()
18. .Where(t => t.Name.EndsWith("Policy"))
19. .WithService
20. .Select((t, b) => new[] { t.BaseType }));
21.
22. string connectionString = ConfigurationManager
23. .ConnectionStrings["CommerceObjectContext"]
24. .ConnectionString;
25.
26. container.Register(AllTypes
27. .FromAssemblyContaining<SqlProductRepository>()
28. .Where(t => t.Name.StartsWith("Sql"))
29. .WithService
30. .Select((t, b) => new[] { t.BaseType })
31. .Configure(r => r.LifeStyle.PerWebRequest
32. .DependsOn((new
33. {
34. connString = connectionString
35. }))));
36. }
37. }
Строка 5, 10, 16, 26: Вызовы Register
112
CommerceWindsorInstaller кажется сложным, но важно отметить, что он инкапсулируеетыре вызова метода Register и что это единственный способ, с помощью которого озаимодействует с контейнером. Остальная часть кода сейчас не важна. В неспользуются соглашения для конфигурации контейнера. Более подробно об API
механизма автоматической регистрации Castle Windsor вы можете прочитать в разделе
"Конфигурирование контейнера" (глава "Castle Windsor").
Поскольку шаблонное приложение является веб-сайтом, Resolve и Release должны бытеализованы в единой паре. Для каждого HTTP-запроса вы должны преобразоватиаграмму объектов, которая будет обрабатывать этот запрос, а когда это закончится, волжны выпустить его снова. Вы делаете это из класса под названием
WindsorControllerFactory, который наследуется от DefaultControllerFactoryтносящегося к ASP.NET MVC – более подробно о шве ASP.NET MVC вы можетрочитать в разделе "Построение ASP.NET MVC приложений".
ASP.NET MVC фреймворк вызывает метод GetControllerInstance для того, чтобреобразовать IControllers и метод ReleaseController при обработке запроса. Нижриведены подходящие для нас методы вызова методов Resolve и Release:
protected override IController GetControllerInstance(
RequestContext requestContext, Type controllerType)
{
var controller = this.container.Resolve(controllerType);
return (IController)controller;
}
public override void ReleaseController(IController controller)
{
this.container.Release(controller);
}
В методе GetControllerInstance вы передаете аргумент controllerType в метод
Resolve и возвращаете результирующую диаграмму объектов. При обработке запроса
ASP.NET MVC фреймворк вызывает метод ReleaseController с экземпляром
IController, созданным до этого с помощью метода GetControllerInstance, и вожете передать этот экземпляр controller в метод Release.
Обратите внимание на то, что это единственное появление методов Resolve и Release всей базе кода приложения.
Этот пример погружается несколько глубже предыдущего примера, которыемонстрировал паттерн Composition Root, но в сущности это тот же самый код. Паттерн
Composition Root указывает, где вам следует формировать диаграммы объектов, тогда как
Register Resolve Release имеет дело с тем, как использовать DI-контейнер в пределах
Composition Root.
В следующей главе я сделаю обзор большего количества DI-паттернов, но перед тем, като сделать, я хочу сделать небольшой крюк и обсудить то, как DI-контейнерриспосабливаются к всеобщей .NET экосистеме.
113
3.4. Перспектива DI-контейнеров
Теперь, когда я описал, что такое DI-контейнер и как применить его в Composition Root, очу слегка сменить темп и предоставить вам обзор текущего состояния DI-контейнеров в
.NET экосистеме. Это такие самые устойчивые аспекты DI-контейнеров, как историческороисхождение, и то, почему доступно так много контейнеров с открытым исходныодом.
Поскольку для выбора предлагается большое изобилие DI-контейнеров, я также хочредоставить вам некоторое руководство по тому, как выбрать контейнер.
Выбор DI-контейнера
Решение использовать механизм внедрения зависимостей в качестве технологии нолжно зависеть от выбора конкретного DI-контейнера. Механизм внедрениависимостей в первую очередь является технологией, и я буду использовать Poor man's
DI на протяжении почти всех частей "Каталог DI" и "DI самостоятельно" для того, чтободчеркнуть этот вопрос.
Однако DI-контейнер упростит вашу жизнь, поэтому используйте его там, где толькожете. Если использовать контейнеры согласно выделенным в этой книге паттернам, тожно столкнуться с несколькими недостатками, но нужно рассмотреть еще кое-что.
Процесс принятия решения
DI-контейнер – это стабильная зависимость, поэтому с точки зрения DI использование DI-
контейнера не является проблемой, но существуют другие, второстепенные проблемыоторые нужно рассмотреть:
? Добавление другой библиотеки всегда добавляет некоторую сложность риложение – не в терминах удобства сопровождения, а в терминах кривобучения. Новым разработчикам нужно будет не только понять код приложенияо также понять API выбранного DI-контейнера. Надеюсь, что в этой главе я сумеать вам понять, что с помощью изолированного использования контейнера в
Composition Root вы сможете защитить контейнер от начинающих разработчиков.
Если вы используете механизм автоматической регистрации, то контейнер можеаже взять на себя заботу об инфраструктуре, не привлекая при этом к себнимание.
? За исключением платформы Managed Extensibility Framework (MEF), вам нужназворачивать сборки DI-контейнера вместе со своим приложением. Это могло ботенциально иметь легальные последствия, хотя это и не правдоподобно. Всниверсальные DI-контейнеры с открытым исходным кодом имеют разрешающиицензии, но я не судья, поэтому не делайте ставку на мои слова:
проконсультируйтесь со своим собственным консультантом.
? И еще раз за исключением MEF все остальные DI-контейнеры являютсиблиотеками с открытым исходным кодом. Для каждого из этих контейнеров вариходится оценивать, насколько вы доверяете людям или организацииоздавшим эти контейнеры.
? Существуют технические различия между различными DI-контейнерами. Введении к части "DI-контейнеры" я предоставил вам таблицу, в котороеречисляются преимущества и недостатки каждого контейнера, рассматриваемого
114
в этой книге. Вы можете использовать эту таблицу как стартовую точку, а пототение глав о каждом из контейнеров станет для вас интересным.
Выбор DI-контейнера не должен быть сложным. Возьмите один для раскрутки, а потоосмотрите, подходит ли он вашим нуждам – если не подходит, то замените его другим.
Когда вы заключите DI-контейнер в Com position Root, вы сможете заменять контейнертносительно свободно.
Выбранные DI-контейнеры
Я не хочу рассказывать вам о том, какой DI-контейнер выбрать. Выбор DI-контейнерключает в себя больше чем просто техническую оценку. Вы также должны оценитьодходит ли вам лицензионная модель, доверяете ли вы людям и организации, котораазрабатывает и поддерживает в работоспособном состоянии DI-контейнер, насколько оодходит IT -стратегии вашей организации и т.д.
Большинство .NET DI-контейнеров являются проектами с открытым исходным кодом –
это также следует иметь ввиду, поскольку для них может и не быть официальнооддержки, а документация часто ограничена.
В таблице 3-4 перечисляются DI-контейнеры, рассматриваемые в части "DI-контейнеры".
Выбор основывается на таких критериях, как релевантность, доля на рынке, характерныерты, но этот список является субъективным и неокончательным. Несколько популярныонтейнеров (например, Ninject) не включены в этот список, главным образом, из-зграничений во времени и пространстве.
Таблица 3-4: Выбранные DI-контейнеры. Доступно больше контейнеров, но эти выбранибо потому что они широко используются, либо они представляют собой интересныспект DI или потому что они станут важными в будущем
Название Организация Комментарии
Castle Windsor Open Source Состоявшийся и широко используемый
StructureMap Open Source Состоявшийся и широко используемый
Spring.NET SpringSource Состоявшийся и широко используемый порт
Java Spring DI-контейнера
Autofac Open Source
Наиболее современный DI-контейнерозданный на основании характеристизыка C# 3.0
Unity Microsofatterns&practices
Первая роль компании Microsoft ространстве DI, но не продукт по существу
Managed Extensibility
Framework (MEF) Microsoft
Поставляется вместе с .NET 4, но ействительности не является DI-
контейнером
Часть "DI-контейнеры" посвящена этим DI-контейнерам, причем для каждого из ниыделена отдельная глава.
Обратите внимание на то, как в этой области доминируют проекты с открытым исходныодом и другие некоммерческие проекты, причем компания Microsoft играеезначительную роль в этом деле.
115
Microsoft и DI
Несмотря на то, что платформа .NET является продуктом компании Microsoft, другирганизации (часто отдельные лица) становятся более известными, когда дело доходит деханизма внедрения зависимостей в .NET. Вкратце это может относиться к тому фактуто компания Microsoft не предлагает ни одного DI-контейнера в стандартной библиотеклассов (BCL). Хотя как предложение единственным DI-контейнером компании Microsofвляется появившийся относительно недавно Unity.
Думаю, справедливо будет сказать, что за множество первых лет жизни .NET Frameworомпания Microsoft блаженно игнорировала любую сущность DI. Не просто точнбъяснить, почему так происходило, и я сомневаюсь, что это когда-либо было явнотратегией.
Краткая история DI в .NET
Ниже приведена моя субъективная попытка сделать обзор истории DI в .NET для тоготобы объяснить, почему компания Microsoft столь долго игнорировала механизнедрения зависимостей (см. рисунок 3-14). Насколько я осведомлен, на этот вопрос невторитетного ответа.
Рисунок 3-14: Временные рамки релизов выбранных платформ и DI-контейнеров.
Обратите внимание на то, насколько состоявшейся оказалась Java в 2004 году правнению с .NET.
Кажется, что до того, как попасть в .NET, DI выросла из сообщества Java с открытысходным кодом. Мартин Фаулер опубликовал свою статью о DI в начале 2004 года ачестве реакции на непрерывную работу. В это время текущей версией .NET была версия
1.1, и компания Microsoft работала над версией .NET 2.0, в то время как Java быстрымемпами достигала своего десятилетия. Я верю, что компания Microsoft в то время простаправила свои усилия в другом направлении. Даже если бы они в то время были хорошсведомлены насчет DI, думаю, для них все равно были бы приоритетны другиозможности, например, дженерики.
В июне 2004 года был выпущен DI-контейнер StructureMap, обогнав Castle Windsor всега полгода.
116
В конце 2005 года компания Microsoft выпустила .NET 2.0, главной новой возможностьоторой стали дженерики, а затем Microsoft решила сфокусироваться на WCF, WPF, озднее LINQ для своего следующего крупного релиза (Visual Studio 2008).
Тем временем DI медленно приобретал популярность. В 2006 году появился Spring.NET.
В начале 2008 Microsoft patterns&practices выпустили Unity, которая для большинствоследователей школы Microsoft казалась приближением к DI. Этот четырехгодовалыромежуток времени дал опытным личностям хороший старт, а популярность DI-
контейнеров, подобных StructureMap и Castle Windsor, возросла.
О снова DI
Интересным наблюдением из рисунка 3-14 является то, как быстро члены сообщества
.NET разработчиков подхватили идею DI. Согласно домашней странице Castle Windsoонятия зарождались даже до статьи Фаулера:
Castle вырос из проект а Apache Avalon в середине 2003 года в виде попытки созданиамой прост ой инверсии управления контейнером.
Веб-страничка Castle от 01.08.2008
На протяжении длительного времени для .NET DI-контейнеры оставались источниковижения, а многие ведущие члены симпатизировали разработке Agile. В
действительности даже если архитектура модульного приложения имеет множествазличных преимуществ, все равно кажется, что в первую очередь именно вопроестируемости мотивировал людей на разработку и использование DI-контейнеров (чтакже является справедливым и в моем случае).
В это время официальной методологией разработки в компании Microsoft была Microsoft
Solutions Framework (MSF) 3.0 – каскадный процесс, который оставляет небольшоространство для таких приемов разработки Agile, как разработка через тестирование
(T DD). Короче говоря, это было совершенно другим образом мышления.
С течением времени разработка Agile, TDD и DI доказали свою эффективнос ть риобрели популярность, а Microsoft, казалось, также медленно продвигалась к поддержктого стиля. В противоположность ситуации 2004 года команды разработки теперткрыто обсуждают DI, TDD и другие вопросы, относящиеся к разработке Agile.
DI-конте йнеры компании Microsoft
С течением времени команда patterns&practices компании Microsoft разработалножество корректур для различных областей, относящихся к .NET. Большая часть опытариобретенного из этих проектов, использовалас ь для определения рамок дальнейшеазработки самого .NET Framework. В качестве примера Updater Application Blocредоставил богатый опыт, который в дальнейшем использовался при разработке
ClickOnce.
В начале 2008 года команда patterns&practices выпустила свою первую Community
Technical Preview (CTP) (небольшая ознакомительная версия) версию Unity, их новый DI-
контейнер, а в апреле 2008 года вышел релиз 1.0. Unity – это развитый DI-контейнероторый поддерживает композицию объектов, механизм управления жизненным циклом и
117
механизм перехвата. Это не продукт компании Microsoft, но скорее проект с открытысходным кодом, который возможно разработан Microsoft.
O bject Builder
Кажется, существует некоторая путаница в вопросе о том, когда точно patterns&practiceредставили миру DI-контейнер. При введении в начале 2006 года Enterprise Library для
.NET 2.0 команды patterns&practices она содержала модуль с названием Object Builderоторый использовался для создания сложных объектов из составных элементов.
Она была атрибутно-управляемой и работала только для классов, которые были сильннтегрированы с самим Object Builder. Его никогда не представляли как DI-контейнеротя было общепризнано, что на его основе можно было бы создать DI-контейнер.
Многие люди ошибочно верят, что Object Builder был первым DI-контейнером компании
Microsoft, но это не правда: этот титул получил Unity.
Вместе с .NET 4.0 компания Microsoft предоставила Managed Extensibility Framework
(MEF), который отмечает, что к первым DI сущностям явно обращались в рамках самой
.NET. При первом выпуске MEF не был полноценным контейнером, которыоддерживал все три аспекта DI, но скорее был движком, который фокусировался номпозиции объектов.
Команда MEF хорошо осведомлена о таких аспектах, как управление жизненным цикло механизм перехвата, поэтому не маловероятно, что мы будем свидетелями того, что
MEF будет включен в полноценный DI-контейнер в следующие несколько лет (как я пишдесь, технические обзоры указывают на то, что это будет именно так).
118
3.5. Резюме
DI-контейнер может стать чрезвычайно полезным инструментом, если вы правильно егспользуете. Самое важное – понять, что использование механизма внедрениависимостей никоим образом не зависит от использования DI-контейнера. Приложениожет состоять из множества слабо связанных классов и модулей, и ни один из этиодулей не должен ничего знать о контейнере. Наиболее эффективный способ убедиться ом, что код приложения не осведомлен ни об одном DI-контейнере, – жестко реализовататтерн Register Resolve Release в Composition Root. Это эффективно предостережет вас олучайного применения анти-паттерна Service Locator, потому что он заключаеонтейнер в небольшую изолированную область кода.
Если использовать DI-контейнер таким образом, то он станет движком, который берет небя заботу о большей части инфраструктуры приложения. Он формирует диаграммбъектов на основании его конфигурации. Это может быть особенно существенно, еслы применяете конфигурацию, базирующуюся на соглашениях – при соответствующееализации он может заботиться о формировании диаграммы объектов, и вы можетконцентрировать ваши усилия на добавлении новых классов, реализующих новыозможности. Контейнер будет автоматически обнаруживать новые классы, которыоответствуют установленным соглашениям, и делать их доступными для пользователей.
В некоторых случаях вам нужно больше явного контроля над конфигурацией контейнера.
Наиболее эффективно использовать код в качестве конфигурации, но если вам нужноддерживать позднее связывание, вы также можете использовать XML длонфигурации DI-контейнеров.
Эта глава подытоживает первую часть книги. Целью первой части было знакомство с DI.
Предыду щие главы в общих чертах знакомили с механизмом внедрения зависимостейогда как данная глава объясняет то, как DI-контейнеры относятся к DI, а также в общиертах объясняет процесс проектирования приложения. Я подумал, что историческибзор DI-контейнеров в .NET экосистеме как раз подходит для завершения главы, чтобействительно ввести в игру различные контейнеры.
Глава представляет Composition Root и Register Resolve Release как два мини-паттернаоторые относятся к DI-контейнерам. В следующей главе мы сосредоточимся наттернах проектирования.
119
Каталог DI
В части 1 представлен обзор DI, с обсуждением целей и преимуществ DI и объяснениемак DI конт ейнеры вписываются в общую картину. Хотя в главе 2 содержитсазвернутый пример, я уверен, что после первых глав у вас остались еще некоторыерешенные вопросы. В части 2 мы копнем немного глубже, чтобы ответить на некоторыз этих вопросов.
Как следует из названия части 2, это каталог паттернов, анти-паттернов и рефакторинга.
Некоторые люди не любят паттерны проектирования, потому что считают их сухими иллишком абстрактными. Лично я люблю паттерны, потому что они обеспечивают назыком высокого уровня, который делает нас более эффективными и краткими, когда мбсуждаем программное обеспечение. Это мое намерение – использовать данный каталогтобы показать язык паттернов для DI. Хотя описание паттерна должно содержатекоторые обобщения, я попытался сделать каждый шаблон конкретным, спользованием примеров.
Вы можете прочитать все три главы в последовательно сти, но каждый элемент в каталоакже описан так, что вы можете прочитать о нем отдельно.
Глава 4 содержит мини-каталог паттернов проектирования DI. В некотором смысле, этаттерны представляют собой нормативное руководство о том, как реализовать DI, но волжны знать, что я не считаю, что все они имеют одинаковое значение. Constructor
Injection на сегодняшний день является наиболее важным паттерном проектированияогда как все остальные паттерны должны рассматриваться как крайние случаи, которыогут применяться в определенных условиях. Паттерн Am bient Context, в частностиолжен быть использован настолько редко, что я серьезно задумывался не включать его нигу (я оставил его только потому, что те, кто читают книги перед публикациейопросили меня оставить его).
В то время как глава 4 дает вам набор обобщенных решений, глава 5 содержит каталоитуаций, которых необходимо избегать. Эти анти-паттерны описывают общие, неправильные пути решения типичных проблем DI. В каждом случае анти-паттерассказывает, как выявить проблему и как ее решить. Важно знать и понимать эти анти-
паттерны, чтобы избегать ловушек, которые они расставляют, и поскольку в главе 4
представлен наиболее важный паттерн, наиболее важным анти-паттерном является Service
Locator.
Когда вы начнете применять DI в реальных задачах программирования, вы столкнетесь екоторыми проблемами. Я думаю, у нас всех были моменты сомнений, когда мувствовали, что мы понимаем инструмент или технику, и все же мы думали: «В теорито может сработ ат ь, но мой случай особенный ..." Всякий раз, когда я ловлю себя накой мысли, я понимаю, что мне многому еще предстоит научиться.
Во время моей карьеры я видел определенный набор проблем, которые появляются внов вновь. Каждая из этих проблем имеет общее решение, которое можно применить длеремещения вашего кода к одному из паттернов DI из главы 4. В духе рефакт орингатт ернов я решил назвать эту главу DI рефакторингом, потому что она содержиаталог проблем и соответствующих решений.
120
Часть 2 представляет полный каталог паттернов, анти-антипаттерно в и рефакторинга. Я
думаю, что это будет самая полезная часть книги, потому что она наиболее «устойчивая».
Будем надеяться, что вы вернетесь к этим главам через месяцы или даже годы послервого прочтения.
4. DI паттерны
5. DI анти-паттерны
6. DI рефакторинг
121
4. DI паттерны
Меню
? Constructor Injection
? Property Injection
? Method Injection
? Ambient Context
Как и все профессионалы, повара имеют свой жаргон, который позволяет им общаться ложных процессах приготовления пищи на своем языке, что часто звучит оченепонятно для остальных из нас. Не помогает даже то, что по большей части онспользуют термины, основанные на французском языке (даже если вы и говорите по-
французски, такая проблема есть).
Соусы являются отличным примером того, как повара используют сворофессиональну ю терминологию. В главе 1 мы кратко обсудили sauce bearnaise, но я нточнил таксономию, которая его окружает (см. рисунок 4-1).
Рисунок 4-1: Некоторые соусы основаны на sauce hollandaise. В sauce bearnaise лимоаменяется уменьшенным количеством уксуса и определенными травами, в то время катличительной чертой sauce mousseline является то, что в него вымеш ивают ся взбитыливки: эта технология также используется для изготовления m ousse au chocolat.
sauce bearnaise – это в действительности sauce hollandaise, где лимонный сок заменяетсменьшенным количеством уксуса, луком-шалото м, кервелем и эстрагоном. Другие соусснованы на sauce hollandaise, в том числе мой любимый, sauce m ousseline, которыделан с вымешиванием взбитых сливок в hollandaise.
Вы заметили жаргон? Вместо того чтобы сказать "тщательно вбивая сливки в соустарайтесь не свернуть его," я использовал термин вымешайт е. Когда вы знаете, что этначит, это намного легче сказать и понять.
Термин вымешат ь не ограничивается соусами: это общий способ совместить что-тзбитое с другими ингредиентами. При создании классического шоколадного мусса
(mousse au chocolat), например, я вымешиваю взбитые яичные белки в смесь взбитыичных желтков и растопленного шоколада.
При разработке программного обеспечения у нас самих есть сложный и непроходимыаргон. Хотя вы можете и не знать, что относится к поварскому термину bain-m arie, я
122
уверен, что большинство поваров будут совершенно потеряны, если вы скажете им, что
"строки являются неизменными классами, представляющими последовательности Unicodимволов".
Когда дело доходит до разговоров о том, как структурировать код для решенионкретного типа задач, у нас есть пат терны проектирования, которые дают именбщим решениям. Таким же образом, как термины sauce hollandaise и вымеш иватомогают нам поговорить о том, как сделать sauce m ousseline, паттерны помогают наоворить о том, как структурирован код. Система событий в .NET основана на паттернроектирования Наблюдатель (Observer), а циклы foreach на Итератор (Iterator).
В этой главе я расскажу о четырех основных DI паттернах, перечисленных на рисунке 4-2.
Поскольку глава построена так, чтобы показать каталог паттернов, каждый паттерписан так, чтобы его можно было прочитать отдельно. Тем не менее, Внедрение онструктор (Constructor Injection) на сегодняшний день является наиболее важным иетырех паттернов.
Рисунок 4-2: Структура этой главы принимает форму каталога паттернов. Каждыаттерн описан так, что вы можете прочитать о нем отдельно от других паттернов.
Не беспокойтесь, если вы обладаете ограниченными знаниями паттернов проектировани целом. Основная цель паттерна проектирования заключается в создании подробного втономного описания конкретного способа достижения цели – рецепта, если угодно.
Для каждого шаблона я приведу краткое описание, пример кода, преимущества едостатки и так далее. Вы можете прочитать обо всех четырех паттернах илграничиться только теми, которые вас интересуют. Наиболее важным паттерновляется Внедрение в конструктор (Constructor Injection), который вы должнспользовать в большинстве ситуаций; вы увидите другие все более и болепециализированные паттерны по мере продвижения по главе.
4.1. Внедрение в конструктор (Constructor Injection)
4.2. Внедрение в свойство (Property Injection)
4.3. Внедрение в метод (Method Injection)
4.4. Окружающий контекст (Ambient Context)
4.5. Резюме
123
4.1. Внедрение в конструктор (Constructor
Injection)
Как мы можем гарантировать, чт о необходимая зависимост ь всегда доступна длласса, который мы в наст оящ ее время разрабатываем?
Запрашивая все вызывающие элементы, чтобы доставить зависимость в качествараметра конструктору класса.
Рисунок 4-3: NeedyClass нуждается в экземпляре зависимости, чтобы работать, поэтомн требует любого клиента, чтобы предоставить экземпляр через свой конструктор. Этарантирует, что экземпляр доступен NeedyClass всякий раз, когда он необходим.
Когда класс требует экземпляр зависимости, чтобы работать вообще, мы можередоставить эту зависимость через конструктор класса, включая ее, чтобы сохранитсылку для будущего (или немедленного) использования.
Как это работает
Класс, которому нужна зависимость, должен предоставить открытый конструктороторый принимает экземпляр необходимой зависимости в качестве аргументонструктора. В большинстве случаев, это должен быть только доступный конструктор.
Если необходима более чем одна зависимость, могут быть использованы дополнительныргументы конструктора.
Листинг 4-1: Внедрение в конструктор
1. private readonly DiscountRepository repository;
2. public RepositoryBasketDiscountPolicy(
3. DiscountRepository repository)
4. {
5. if (repository == null)
6. {
7. throw new ArgumentNullException("repository");
8. }
9. this.repository = repository;
10. }
124
Строки 2-3: Внедрить зависимость как аргумент конструктора
Строки 5-8: Ограждающее условие (Guard Clause)
Строка 9: Сохранение зависимости для дальнейшего использования
Строка 1: Поле зависимости только для чтения
Зависимость (в предыду щем листинге это абстрактный класс DiscountRepository)
является требуемым аргументом конструктора. Любой клиентский код, который нредоставляет экземпляра зависимости, не может скомпилироваться. Однако так кантерфейсы и абстрактные классы являются ссылочными типами, вызывающий элеменожет передать null в качестве аргумента, чтобы вызывающий код мог быткомпилирован, и мы должны защитить класс против таких злоупотреблений при помощграждающего условия (Guard Clause).
Поскольку объединенные усилия компилятора и ограждающего условия гарантируют, чтргумент конструктора является действительным, если не выбрасывается исключениеогда конструктор может сохранить зависимость для будущего использования, ничего нная о реальной реализации.
Хорошей практикой является то, чтобы отметить поле, содержащее зависимость, каeadonly: это гарантирует, что как только инициализационная логика конструктора будеыполнена, поле не может быть изменено. Это не является обязательным с точки зрения
DI, но это защитит вас от случайного изменения поля (например, установка его на null)
где-то в другом месте зависимого от класса кода.
Примечание
Не загружайте конструктор любой другой логикой. Принцип единственной обязанности
(Single Responsibility Principle) предполагает, что члены должны делать только одну вещь теперь, когда мы используем конструктор для внедрения зависимостей, мы предпочлы держать его свободным от других вещей.
Примечание
Подумайте о внедрении в конструктор как о ст ат ическом объявлении зависимост еласса. Сигнатура конструктора компилируется при помощи типа и доступна длсеобщего обозрения. Она четко говорит, что класс требует зависимости, которые оапрашивает через свой конструктор.
После возвращения конструктора новый экземпляр класса находится в согласованноостоянии с соответствующим экземпляром зависимости, внедренном в него. Посколькн содержит ссылку на эту зависимость, он может использовать ее так часто, каеобходимо. Тут не нужна проверка на null, поскольку гарантировано, что экземпляудет иметься в наличие.
125
Когда это использовать
Внедрение в конструктор должно быть вашим выбором по умолчанию для DI. Оно решаеаиболее распространенную задачу, где класс требует одну или несколько зависимосте не имеется никаких приемлемых Local Default.
Внедрение в конструктор хорошо решает эту задачу, потому что оно гарантирует, чтависимость присутствует. Если класс абсолютно не может функционировать беависимости, эта гарантия является ценной.
С овет
Если это вообще возможно, ограничивайтесь одним конструктором. Перегруженныонструкторы приводят к неоднозначности: какой конструктор должен использовать DI
контейнер?
В случаях, когда локальная библиотека можем предоставить хорошую реализацимолчанию, внедрение в свойство (Property Injection) может подойти лучше, но этечастный случай. В предыдущих главах я показал много примеров хранилищ в качествависимостей. Это хорошие примеры зависимостей, когда локальная библиотека не можередоставить подходящую реализацию по умолчанию, так как надлежащая реализациринадлежит специализированным библиотекам доступа к данным (Data Access).
Таблица 4-1: Преимущества и недостатки внедрения в конструктор
Преимущества Недостатки
Внедрение точнсть
Некоторые фреймворки усложняют использование внедрения онструктор
Легко реализовать
Помимо гарантированного внедрения, о чем уже говорилось, этот паттерн также легкеализовать с помощью четырех шагов, показанных в листинге 4-1.
Основным недостатком внедрения в конструтор является то, что вам нужно изменитекущую платформу приложения для его поддержки. Большинство фреймворкоредполагают, что у ваших классов будет конструктор по умолчанию, и что им можеотребоваться специальная помощь для создания экземпляров, когда конструктор пмолчанию отсутствует. В главе 7 я объясню, как включить внедрение в конструктор длбщих фреймворков.
Очевидным недостатком внедрения в конструктор является то, что он требует, чтобы весраф зависимости инициализирова лся немедленно, часто при запуске приложения.
Однако, хотя это звучит не очень приятно, это редко является проблемой. В конце концоваже для сложного графа объекта мы обычно говорим о создании десятков новыкземпляров объектов, а создание экземпляра объекта это то, что .NET Framework делаечень быстро. Любые узкие места, которые может иметь ваше приложение, появятся и ругих местах, так что не беспокойтесь об этом.
В очень редких случаях это может все же быть реальной проблемой, но в главе 8 я опишпцию Delayed, которая является одним из возможных средств решения этой проблемы.
126
На данный момент я просто скажу, что могут (в крайнем случае) быть потенциальныроблемы с начальной загрузкой, и давайте двигаться дальше.
Использование
Хотя внедрение в конструктор, как правило, повсеместно в приложениях, использующих
DI, оно не очень часто присутствует в .NET Base Class Library (BCL). Главным образото потому, что BCL представляет собой набор библиотек, а не полноценное приложение.
Два взаимосвязанных примера, когда мы видим своего рода внедрение конструктора в
BCL, это с System.IO.StreamReader и System.IO.StreamWriter. Оба принимают в своонструкторы экземпляр System.IO.Stream. У них также есть много перегруженныонструкторов, которые принимают путь к файлу, а не экземпляр Stream, но есть методыоторые внутренне создают FileStream на основе указанного пути к файлу: далеоказаны все конструкторы StreamWriter, но конструкторы StreamReader схожи:
public StreamWriter(Stream stream);
public StreamWriter(string path);
public StreamWriter(Stream stream, Encoding encoding);
public StreamWriter(string path, bool append);
public StreamWriter(Stream stream, Encoding encoding, int bufferSize);
public StreamWriter(string path, bool append, Encoding encoding);
public StreamWriter(string path, bool append, Encoding encoding, inufferSize);
Класс Stream является абстрактным классом, который служит в качестве абстракции, наоторой работают StreamWriter и StreamReader для выполнения своих обязанностей. Вожете указать любой реализацию Stream в их конструкторах, и они будут еспользовать, но они выбросят ArgumentNullExceptions, если вы попытаетесь присвоить
Stream null.
Хотя BCL может предоставить нам примеры, когда мы видим, как используетснедрение конструктора, но всегда более поучительно увидеть пример. Следующиаздел проведет вас через полный пример реализации.
Пример: Добавление выбора валюты для корзины покупок
Я хотел бы добавить новую функцию к примеру коммерческого приложения, который редставил в главе 2, а именно, способность выполнять конвертацию валют. Я расширример в данной главе, чтобы продемонстрировать различные DI паттерны в деле, и когд все сделаю главная страница должно быть как на рисунке 4-4.
127
Рисунок 4-4: Пример коммерческого приложения с реализованной конвертацией валюты.
Теперь пользователь может выбрать три разные валюта, и цена товара и общая стоимость
(на странице корзины) будут отображаться в этой валюте.
Одна из первых вещей, которая вам нужна, это CurrencyProvider – зависимостьредоставляющая вам валюты, которые вы запрашиваете. Вы определяете это следующибразом:
public abstract class CurrencyProvider
{
public abstract Currency GetCurrency(string currencyCode);
}
Класс Currency является другим абстрактным классом, который обеспечивает конверсиежду собой и другими валютами:
public abstract class Currency
{
public abstract string Code { get; }
public abstract decimal GetExchangeRateFor(string currencyCode);
}
Вы хотите, чтобы функция конвертации валюты была на всех страницах, гдтображаются цены, так что вам нужна она в обоих HomeController и BasketController.
Поскольку обе реализации очень похожи, я покажу только BasketController.
CurrencyProvider, скорее всего, представляют собой ресурс «вне процесса», напримереб-сервис или базу данных, которые предоставляют курсы конверсии. Это означает, чтаиболее подходящим была бы реализация конкретного CurrencyProvider в отдельнороекте (например, в библиотеке Data Access). Следовательно, здесь нет никакоодходящей Local Default. В то же время, классу BasketController понадобится наличие
CurrencyProvider; внедрение в конструктор – это то, что надо. Следующий листиноказывает, как зависимость CurrencyProvider внедряется в BasketController.
128
Листинг 4-2: Внедрение CurrencyProvider в BasketController
1. private readonly IBasketService basketService;
2. private readonly CurrencyProvider currencyProvider;
3. public BasketController(IBasketService basketService,
4. CurrencyProvider currencyProvider)
5. {
6. if (basketService == null)
7. {
8. throw new
9. ArgumentNullException("basketService");
10. }
11. if (currencyProvider == null)
12. {
13. throw new
14. ArgumentNullException("currencyProvider");
15. }
16. this.basketService = basketService;
17. this.currencyProvider = currencyProvider;
18. }
Строки 3-4: Внедрить зависимость как аргумент конструктора
Строки 6-15: Ограждающее условие (Guard Clause)
Строки 16-17: Сохранение зависимости для дальнейшего использования
Строки 1-2: Поле зависимости только для чтения
Поскольку класс BasketController уже имеет зависимость в IBasketService, вобавляете новую зависимость CurrencyProvider в качестве второго аргументонструктора, а затем следуете той же последовательно сти, что изложена в листинге 4-1:
ограждающее условие гарантирует, что зависимости не являются null, что означает, чтранить их для последующего использования в readonly полях безопасно.
Теперь, когда CurrencyProvider гарантированно присутствует в BasketController, оожет быть использован в любом месте, например, в методе Index:
public ViewResult Index()
{
var currencyCode = this.CurrencyProfileService.GetCurrencyCode();
var currency = this.currencyProvider.GetCurrency(currencyCode);
// …
}
Я еще не обсуждал CurrencyProfileService, так что теперь знайте, что он предоставляередпочтительный код валюты текущего пользователя. Далее мы будем обсуждать
CurrencyProfileService более подробно.
С имеющимся кодом валюты может быть вызван CurrencyProvider, чтобы предоставить
Currency, который представляет этот код. Заметьте, что вы можете использовать полurrencyProvider без необходимости проверять его заранее, потому что онарантированно присутствует.
Теперь, когда у вас есть Currency, вы можете продолжить, чтобы выполнить остальнуаботу в методе Index; обратите внимание, что я еще не показал эту реализацию. По мере
129
продвижения по этой главе я буду достраивать этот метод и попутно добавлю большункционала по конвертации валюты.
Связанные паттерны
Внедрение в конструкт ор является наиболее применимым DI паттерном, а также егегче всего реализовать правильно. Он применяется, когда зависимость являетсбязательной.
Если нам нужно сделать зависимость опциональной, мы можем перейти ко внедрению войство (Property Injection), если у нас есть подходящая Local Default.
Когда зависимость представляет Cross-Cutting Concern (CCC), который должен бытотенциально доступен для любого модуля в приложении, мы можем использовать
Ambient Context.
Следующим паттерном в этой главе является внедрение в свойство, которое тесно связан внедрением в конструктор; единственный решающий параметр заключается в томвляется ли зависимость обязательной или нет.
130
4.2. Внедрение в свойство (Property
Injection)
Как мы можем включит ь DI в качестве опции в классе, когда у нас есть хорошая Local
Default?
Раскрывая записываемое свойство, которое позволяет вызывающим элементаредоставить зависимость, если они хотят переопределить поведе ние по умолчанию.
Рисунок 4-5: SomeClass имеет опциональную зависимость для ISomeInterface; вместого, чтобы требовать от вызывающих элементов предоставить экземпляр, он даеызывающим элементам возможность определить его через свойство.
Когда класс имеет хорошую Local Default, но мы все еще хотим оставить его открытой дласширения, мы можем раскрыть доступное для записи свойство, что позволяет клиентказать другую реализацию зависимости класса, чем по умолчанию.
Примечание
Внедрение в свойство также известно как внедрение в сетт ер.
В соответствии с рисунком 4-5, клиенты, желающие воспользоваться SomeClass как естьогут создать новый экземпляр класса и использовать его, в то время как клиентыелающие изменить поведение класса могут это сделать путем установки свойства
Dependency для другой реализации ISomeInterface.
Как это работает
Класс, который использует зависимость, должен предоставить открытое, доступное длаписи свойство типа зависимости. В каркасной реализации это может быть таким жростым, как следующий листинг.
Листинг 4-3: Внедрение в свойствublic partial class SomeClass
{
public ISomeInterface Dependency { get; set; }
}
SomeClass зависит от ISomeInterface. Клиенты могут поставлять реализации
ISomeInterface, устанавливая свойство Dependency. Обратите внимание, что в отличие онедрения в конструктор, вы не можете отметить поле свойства Dependency как readonlyотому что вы разрешаете вызывающим элементам менять это свойство в любой моменизненного цикла SomeClass.
131
Другие члены класса могут использовать внедренную зависимость, чтобы выполнять свобязанности, например:
public string DoSomething(string message)
{
return this.Dependency.DoStuff(message);
}
Однако такая реализация является хрупкой, потому что нет гарантии, что свойство
Dependency возвращает экземпляр ISomeInterface. Код, как этот, выбросит
NullReferenceException, так как значение свойства Dependency равно null:
var mc = new SomeClass();
mc.DoSomething("Ploeh");
Эта проблема может быть решена, если позволить конструктору установить экземпляр пмолчанию для свойства в сочетании с ограждающим условием в сеттере свойства.
Другая проблема возникает, если вы позволяете клиентам переключать зависимость ередине времени жизни класса. Эту проблему можно решить путем введенинутреннего флага, который позволяет клиенту установить зависимость один раз.
Пример далее показывает, как можно справиться с этими сложностями, но прежде, чем оберусь до этого, я хотел бы объяснить, когда уместно пользоваться внедрением войство.
Когда это использовать
Внедрение в свойство следует использовать только тогда, когда класс, который вазрабатываете, имеет хорошую Local Default, и вы все еще хотите разрешитызывающим элементам предоставлять различные реализации зависимости класса.
Внедрение в свойство лучше использовать, когда зависимость не являет ся обязат ельной.
Примечание
Существует полемика вокруг вопроса о том, показывает ли внедрение в свойствеобязательную зависимость. В качестве общего принципа API дизайна я считаю, чтвойства необязательны, потому что вы можете легко забыть назначить их, и компилятое жалуется. Если вы согласны с этим принципом в общем, вы также должны принять ег частном случае с DI.
Local Default
Когда вы разрабатываете класс, у которого есть зависимость, вы, возможно, думаете онкретной реализации этой зависимости. Если вы пишете доменный сервис, которыбращается к хранилищу, вы, скорее всего, планируете разработать реализацию этогранилища, которая использует реляционную базу данных.
Заманчиво было бы сделать так, чтобы эта реализация использовалась по умолчанилассом на стадии разработки. Однако когда такой предполагаемый элемент пмолчанию реализован в другой сборке, использование его как дефолтного означало бы
132
создание жесткой ссылки на эту другую сборку, что нарушает многие преимуществлабой связанности, описанной в главе 1.
И наоборот, если предполагаемая реализация по умолчанию определяется в той жиблиотеке как класс, у вас не будет этой проблемы. К сожалению, это не случай ранилищами, но такие Local Default чаще всего встречаются как стратегии.
Пример в этом разделе содержит Local Default.
Рисунок 4-6: Даже в пределах одного модуля мы можем ввести абстракции
(представлены вертикальным прямоугольником), которые помогают снизить связанностлассов в этом модуле. Основным мотивом для этого является повышение поддержкодуля, что достигается тогда, когда классы варьируют независимо друг от друга.
В главе 1 мы обсуждали много веских причин для написания кода со слабовязанностью, когда модули изолированы друг от друга. Тем не менее, слабая связанностожет с большим успехом также применяться к классам в одном модуле. Часто этелается путем введения абстракции в пределах одного модуля, когда классы «общаются»
через абстракции, вместо того чтобы быть тесно связанными друг с другом.
Рисунок 4-6 иллюстрирует, что абстракции могут быть определены, реализованы спользованы внутри одного модуля с основной целью открытия классов для расширения.
Примечание
Концепция открытия класса для расширения охватывается принципоткрытости/закрытости (Open/Closed Principle), который, если вкратце, утверждает, чтласс должен быть открытым для расширения, но закрытым для изменений.
Когда мы реализуем классы, следуя принципу открытости/закр ыто сти, мы можем иметь иду Local Default, но мы по-прежнему даем клиентам способ расширить класс, замениависимость чем-то еще.
Примечание
Внедрение в свойство является лишь одним из многих способов применения принципткрытости/закрытости.
133
С овет
Иногда вы только хотите дать точку расширения, но оставить Local Default как пуступерацию. В таких случаях вы можете использовать паттерн Null Object для реализации
Local Default.
С овет
Иногда вы хотите оставить Local Default на месте, но иметь возможность добавить большеализаций. Вы можете добиться этого путем моделирования зависимости вокруаттернов Наблюдатель (Observer) или Компоновщик (Composite).
До сих пор я не показал вам ни одного примера внедрения в свойство, потому чтрименимость этого паттерна является более ограниченной.
Таблица 4-2: Преимущества и недостатки внедрения в свойство
Преимущества Недостатки
Легко понять Ограниченная применимость
Не совсем просто реализовать надежно
Основным преимуществом внедрения в свойство является то, что его легко понять. Я
часто видел, как этот паттерн используется в качестве первой попытки, когда людешают применять DI.
Представление может быть обманчивым, и внедрение в свойство сопряжено рудностями. Его сложно реализовать надежным образом. Клиенты могут забыть (или нахотеть) предоставить зависимость, или по ошибке присвоить null в качестве значения.
Кроме того: что должно произойти, если клиент попытается изменить зависимость ередине жизненного цикла класса? Это может привести к противоречивому илеожиданному поведению, поэтому вы можете захотеть защитить себя от этого события.
С внедрением в конструктор вы можете защитить класс против таких инцидентоврименяя ключевое слово readonly к полю, но это невозможно, когда вы раскрываетависимость как записываемое свойство. Во многих случаях внедрение в конструктоораздо проще и более надежно, но бывают ситуации, когда внедрение в свойстввляется правильным выбором. Это в том случае, когда предоставление зависимоствляется необязательным, потому что у вас есть хорошая Local Default.
Существование хорошей Local Default частично зависит от степени детализации модулей.
.NET Base Class Library (BCL) поставляется как довольно большой пакет; до тех пор, покefault остается в пределах BCL, можно утверждать, что она также и local. В следующеазделе я кратко остановлюсь на этой теме.
Использование
В .NET BCL, внедрение в свойство является немного более используемым, чем внедрени конструктор, вероятно, потому что много хороших Local Default определяются в разныестах.
134
System.ComponentModel.IComponent имеет доступное для записи свойство Site, котороозволяет определить экземпляр ISite. Это главным образом используется в разработкценариев (например, Visual Studio), чтобы изменить или усилить компонент, когда оаходится в дизайнере.
Другой пример, который сильнее отражает то, как мы привыкли думать о DI, можно найт Windows Workflow Foundation. Класс WorkflowRuntime дает вам возможность добавлятьолучать и удалять сервисы. Это не совсем внедрение в свойство, потому что API
позволяет добавлять ноль или несколько нетипизированных сервисов посредством одного
API общего назначения:
public void AddService(object service)
public T GetService<T>()
public object GetService(Type serviceType)
public void RemoveService(object service)
Хотя AddService выбросит ArgumentNullException если значение сервиса является nullет никакой гарантии, что вы можете получить сервис заданного типа, потому что онозможно, никогда не будет добавлен к текущему экземпляру WorkflowRuntime (на самоеле, это потому что метод GetService является Service Locator).
С другой стороны, WorkflowRuntime поставляется с большим количеством Local Defaulля каждого из требуемых сервисов, которые ему нужны, и они даже имеют префикс
Default, например DefaultWorkflowSchedulerService и DefaultWorkflowLoaderService.
Если, например, не добавлен альтернативный WorkflowSchedulerService либо омощью метода AddService, либо конфигурационного файла приложения, используетсласс DefaultWorkflowSchedulerService.
После этих BCL примеров давайте перейдем к более существенным примераспользования и реализации внедрения в свойство.
Пример: Определение сервиса профиля валюты для BasketController
В разделе 4.1.4 я начал добавлять функционал по конверсии валюты в примеоммерческого приложения и вкратце показал вам некоторую реализацию метода Index в
BasketController, но умолчал о появлении CurrencyProfileService. Дело вот в чем:
Приложению нужно знать, какую валюту пользователь желает видеть. Если обратиться исунку 4-4, вы заметите некоторые ссылки на валюту в нижней части экрана. Когдользователь нажимает одну из этих ссылок, вы должны сохранить где-то выбраннуалюту и связать этот выбор с пользователем. CurrencyProfileService облегчаеранение и загрузку выбранной пользователем валюты:
public abstract class CurrencyProfileService
{
public abstract string GetCurrencyCode();
public abstract void UpdateCurrencyCode(string currencyCode);
}
Это абстракция, которая кодирует действия применения и извлечения текущегользовательского выбора валюты.
135
В ASP.NET MVC (и ASP.NET в целом) у вас есть известная часть инфраструктурыоторая занимается таким сценарием: сервис Profile. Отличная реализация Local Defaulля CurrencyProfileService это то, что оборачивает ASP.NET сервис Profile беспечивает необходимую функциональнос ть, определенную методами
GetCurrencyCode и UpdateCurrencyCode. BasketController будет использовать этот
DefaultCurrencyProfileService по умолчанию, когда раскрывает свойство, котороозволит вызывающему элементу заменить его чем-то другим.
Листинг 4-4: Раскрытие свойства CurrencyProfileService
1. private CurrencyProfileService currencyProfileService;
2. public CurrencyProfileService CurrencyProfileService
3. {
4. get
5. {
6. if (this.currencyProfileService == null)
7. {
8. this.CurrencyProfileService =
9. new DefaultCurrencyProfileService(
10. this.HttpContext);
11. }
12. return this.currencyProfileService;
13. }
14. set
15. {
16. if (value == null)
17. {
18. throw new ArgumentNullException("value");
19. }
20. if (this.currencyProfileService != null)
21. {
22. throw new InvalidOperationException();
23. }
24. this.currencyProfileService = value;
25. }
26. }
Строки 6-12: Отложенная инициализация Local Default
Строки 20-23: Зависимость определяется только один раз
DefaultCurrencyProfileService сам использует внедрение в конструктор, потому чтму нужен доступ к HttpContext и потому что HttpContext не доступен для
BasketController во время создания; он должен отложить создание
DefaultCurrencyProfileService, пока свойство не будет запрошено впервые. В этолучае требуется отложенная инициализация, но в других случаях Local Default можеыть назначена в конструкторе. Обратите внимание, что Local Default назначается череткрытый сеттер, который гарантирует, что все ограничивающие условия были оценены.
Первое ограждающее условие гарантирует, что зависимость не имеет значение null.
Следующее ограждающее условие гарантирует, что зависимость может быть назначенолько один раз. В данном случае я предпочитаю, чтобы CurrencyProfileService не моыть изменен после того, как был назначен, поскольку в противном случае это можеривести к противоречивому поведению, где выбор валюты сначала сохраняется промощи одного CurrencyProfileService, а затем извлекается из другого места, чтокорее всего, дает другое значение.
136
Вы можете также заметить, что поскольку вы используете сеттер для отложеннонициализации, зависимость будет также заблокирована, как только свойство будерочтено. Еще раз, это является защитой клиентов от случая, когда зависимостпоследствии меняется без уведомления.
Если вы прошли через все ограждающие условия, вы можете сохранить экземпляр длальнейшего использования.
По сравнению с внедрением в конструктор, это гораздо более сложно. Внедрение войство может выглядеть простым в сыром виде, как показано в листинге 4-3, но прравильном применении это, как правило, гораздо более сложно: и в этом примере я дажроигнорировал проблему безопасности потока.
Когда CurrencyProfileService на месте, метод Index в BasketController теперь можеспользовать его для получения предпочтительной валютой пользователя:
public ViewResult Index()
{
var currencyCode =
this.CurrencyProfileService.GetCurrencyCode();
var currency =
this.currencyProvider.GetCurrency(currencyCode);
// …
}
Это тот же фрагмент кода, что показан в разделе 4.1.4. CurrencyProfileServicспользуется для получения выбранной пользователем валюты, а CurrencyProvider альнейшем используется для извлечения этой валюты.
В разделе 4.3.4, я вернусь к методу Index, чтобы показать, что произойдет дальше.
Связанные паттерны
Вы используете внедрение в свойство, когда зависимость не является обязательнойотому что у вас есть хорошая Local Default. Если у вас нет Local Default, вы должнзменить реализацию на внедрение в конст руктор.
Когда зависимость представляет CROSS-CUTTING CONCERN, который должен бытоступен для всех модулей в приложении, вы можете реализовать его как Ambient Context.
Но прежде чем мы перейдем к этому, внедрение в мет од, описанное в следующем разделеребует несколько иного подхода, поскольку его чаще применяют в ситуациях, когда у наже есть зависимость, которую мы хотим передать отдельным операциям.
137
4.3. Внедрение в метод (Method Injection)
Как мы можем внедрит ь зависимост ь в класс, когда она различается для каждоперации?
Передавая ее как параметр метода.
Рисунок 4-7: Клиент создает экземпляр SomeClass, но сначала внедряет экземпляависимости ISomeInterface с каждым вызовом метода.
Когда зависимость может меняться с каждым вызовом метода, вы можете передать еерез параметр метода.
Как это работает
Вызывающий элемент внедряет зависимость в качестве параметра метода в каждый вызоетода. Это так же просто, как данная сигнатура метода:
public void DoStuff(ISomeInterface dependency)
Часто зависимость будет представлять некоторый контекст для операции, которыоставляется вместе с "правильным" значением:
public string DoStuff(SomeValue value, ISomeContext context)
В данном случае параметр value представляет собой значение, над которым должеаботать метод, тогда как context содержит информацию о текущем контексте операции.
Вызывающий элемент внедряет зависимость в метод, а метод использует или игнорируеависимость, в зависимости от того, нужно это или нет.
Если сервис использует зависимость, он должен проверить сначала ссылки на null, каоказано в следующем листинге.
Листинг 4-5: Проверка параметров метода на null перед использованиublic string DoStuff(SomeValue value, ISomeContext context)
{
if (context == null)
{
throw new ArgumentNullException("context");
}
return context.Name;
}
138
Ограждающее условие гарантирует, что контекст доступен для остальной части телетода. В данном примере метод использует имя контекста для возвращения значенияоэтому важно убедиться, что контекст доступен.
Если метод не использует внедренную зависимость, ему не нужно содержатграждающее условие. Это звучит странно, ведь если параметр не используется, то зачен вообще нужен? Тем не менее, вам может потребоваться сохранить его, если метовляется частью реализации интерфейса.
Когда это использовать
Внедрение в метод лучше использовать тогда, когда зависимость может меняться аждым вызовом метода. Это может быть в том случае, когда зависимость сама по себредставляет значение, но когда вызывающий элемент желает предоставить потребителнформацию о контексте, в котором вызывается операция.
Это часто бывает в сценариях надстройки, где надстройка предоставлена с информацией онтексте времени выполнения через параметр метода. В таких случаях требуется, чтобадстройка реализовывала интерфейс, который определяет метода (методы) с внедрением.
Представьте интерфейс надстройки с такой структурой:
public interface IAddIn
{
string DoStuff(SomeValue value, ISomeContext context);
}
Любой класс, реализующий этот интерфейс, может быть использован в качествадстройки. Некоторые классы могут вообще не заботиться о контексте, в то время каругие реализации должны. Клиент может использовать список надстроек, вызывааждую со значением и контекстом, возвращая суммарный результат. Это показано ледующем листинге.
Листинг 4-6: Пример клиента надстройки
1. public SomeValue DoStuff(SomeValue value)
2. {
3. if (value == null)
4. {
5. throw new ArgumentNullException("value");
6. }
7. var returnValue = new SomeValue();
8. returnValue.Message = value.Message;
9. foreach (var addIn in this.addIns)
10. {
11. returnValue.Message =
12. addIn.DoStuff(returnValue, this.context);
13. }
14. return returnValue;
15. }
Строки 11-12: Передача контекста надстройке
Закрытое поле AddIns является спискам экземпляров IAddIn, что позволяет клиентройти циклом по списку для вызова каждого метода надстройки DoStuff. Каждый раз,
139
когда метод DoStuff вызывается для надстройки, контекст операции, представленныолем context, передается в качестве параметра метода.
Примечание
Внедрение в метод тесно связано с использованием фабрик абст ракций, описанных азделе 6.1. Любая фабрика абстракций, которая принимает абстракцию в качествходных данных, может рассматриваться как вариант внедрения в метод.
Время от времени, значение и контекст операции инкапсулиру ются в одной абстракцииоторая работает как комбинация обоих.
Таблица 4-3: Преимущества и недостатки внедрения в метод
Преимущества Недостатки
Позволяет вызывающему элементу предоставить конкретныля операции контекст
Ограниченнарименяемость
Внедрение в метод отличается от других DI паттернов, которое мы видели до сих порем, что внедрение не происходит в Com position Root, а, скорее, динамически во времызова. Это позволяет вызывающему элементу предоставить конкретный для операционтекст, который является общим механизмом расширения, используемым в .NET BCL.
Использование
.NET BCL дает много примеров внедрения в метод, особенно в пространстве имен
System.ComponentModel.
System.ComponentModel.Design.IDesigner используется для реализациользовательского функционала времени разработки для компонентов. Он имеет метод
Initialize, который принимает экземпляр IComponent, поэтому он знает, какоомпонент он в настоящее время помогает разрабатывать. Дизайнеры создаютсеализациями IDesignerHost, которые также принимают экземпляры IComponent ачестве параметров для создания дизайнеров:
IDesigner GetDesigner(IComponent component);
Это хороший пример сценария, когда параметр сам несет в себе информацию: компоненожет нести информацию о том, какой IDesigner создать, но в то же время, это такжомпонент, над которым должен впоследствии работать дизайнер.
Другой пример в пространстве имен System.ComponentModel обеспечивается классом
TypeConverter. Некоторые из его методов принимают экземпляр
ITypeDescriptorContext, который, как следует из названия, передает информацию онтексте текущей операции. Поскольку таких методов много, я не хочу перечислять исе, но вот характерный пример:
public virtual object ConvertTo(ITypeDescriptorContext context,
CultureInfo culture, object value, Type destinationType)
В этом методе контекст операции передается явно параметром context, в то время каначение для преобразования и конечный тип передаются в виде отдельных параметров.
140
Исполнители могут использовать или игнорировать параметр context, как они посчитаюужным.
ASP.NET MVC также содержит несколько примеров внедрения в метод. Интерфейс
IModelBinder может быть использован для преобразования HTTP GET или POST данных трого типизированные объекты. Вот метод:
object BindModel(ControllerContext controllerContext,
ModelBindingContext bindingContext);
В методе BindModel параметр controllerContext содержит информацию о контекстперации (между прочим, HttpContext), тогда как BindingContext несет в себе большвной информации о значениях, полученных от браузера.
Когда я говорю, что внедрение в конструктор должно быть вашим предпочтительным DI
паттерном, я предполагаю, что вы создаете приложения на основе фреймворка. С друготороны, если вы строите фреймворк, внедрение в метод часто может быть полезнымоскольку оно позволяет передавать информацию о контексте для надстройкреймворку. Это одна из причин, почему внедрение в метод так плодотворнспользуется в BCL.
Пример: конвертация валюты в корзине
В предыдущих примерах мы видели, как BasketController в примере коммерческогриложения извлекает предпочтительну ю валюту пользователя. Я дополню примеонвертации валюты путем конвертирования Basket в валюту пользователя.
Currency – это абстракция, которая моделирует валюту.
Листинг 4-7: Currencublic abstract class Currency
{
public abstract string Code { get; }
public abstract decimal GetExchangeRateFor(
string currencyCode);
}
Свойство Code возвращает код валюты для экземпляра Currency. Ожидается, что коды
Currency – это междунаро дные коды валют. Например, код валюты для датской кроны –
это DKK, в то время как USD – это доллары США.
Метод GetExchangeRateFor возвращает обменный курс между экземпляром Currency ругой валютой. Заметим, что это абстрактный метод и обозначает, что я не делаикаких предположений о том, как обменный курс будет найден исполнителем.
В следующем разделе мы рассмотрим, как экземпляры Currency используются длреобразования цен, и как эта абстракция может быть реализована и проведена так, чтобы могли конвертировать некоторые цены в такие валюты как доллары США или евро.
141
Внедрение Currency
Вы будете использовать абстракцию Currency как несущую информацию зависимостьтобы выполнить конверсию валют для корзины, так что вы добавите метод ConvertTo лассу Basket:
public Basket ConvertTo(Currency currency)
Он пройдет циклом по всем элементам в корзине и сконвертирует их подсчитанные цен приведенную валюту, возвращая новый экземпляр Basket со сконвертированнымлементами. Через серию делегированных вызовов метода, реализация, наконецредоставляется классом Money, как показано в следующем листинге.
Листинг 4-8: Конвертация Money в другую валюту
1. public Money ConvertTo(Currency currency)
2. {
3. if (currency == null)
4. {
5. throw new ArgumentNullException("currency");
6. }
7. var exchangeRate =
8. currency.GetExchangeRateFor(this.CurrencyCode);
9. return new Money(this.Amount * exchangeRate,
10. currency.Code);
11. }
Строка 1: Внедрить Currency в качестве параметра метода
Currency внедряется в метод ConvertTo через параметр currency и проверяетсездесущим ограждающим условием, которое гарантирует, что экземпляр currencоступен для остальной части тела метода.
Обменный курс к текущей валюте (представленный this.CurrencyCode) извлекается иредоставленной currency, используется для расчета и возвращает новый экземпляр
Money.
С методами ConvertTo вы можете, наконец, реализовать метод Index для
BasketController, как показано в следующем листинге.
Листинг 4-9: Конвертация валюты в Basket
1. public ViewResult Index()
2. {
3. var currencyCode =
4. this.CurrencyProfileService.GetCurrencyCode();
5. var currency =
6. this.currencyProvider.GetCurrency(currencyCode);
7. var basket = this.basketService
8. .GetBasketFor(this.User)
9. .ConvertTo(currency);
10. if (basket.Contents.Count == 0)
11. {
12. return this.View("Empty");
13. }
14. var vm = new BasketViewModel(basket);
15. return this.View(vm);
16. }
142
Строки 7-9: Конвертация пользовательской корзины в выбранную валюту
BasketController использует экземпляр IBasketService для получениользовательской корзины. Вы можете вспомнить из главы 2, что зависимость
IBasketService предоставляется BasketController через внедрение в конструктор. Каолько у вас есть экземпляр Basket, вы можете конвертировать его в нужную валютуспользуя метод ConvertTo, переданный экземпляру currency.
В данном случае вы используете внедрение в метод, потому что абстракция Currencесет информацию, но будет варьировать по контексту (в зависимости от выборользователя). Вы могли бы реализовать тип Currency в качестве конкретного класса, нто ограничило бы вашу способность определять, как извлекаются валютные курсы.
Теперь, когда мы увидели, как используется класс Currency, пришло время измениташу точку зрения и посмотреть, как он может быть реализован.
Реализация Currency
Я еще не говорил о том, как реализован класс Currency, потому что это не столь важно очки зрения внедрения в метод. Как вы помните из раздела 4.1.4 и как вы можете видет листинге 4-9, экземпляр Currency обрабатывается экземпляром CurrencyProviderоторый мы внедрили в класс BasketController путем внедрения в конструктор.
Чтобы упростить пример, я показал, что произойдет, если вы решили реализовать
CurrencyProvider и Currency при помощи базы данных SQL Server и LINQ to Entities.
Это предполагает, что в базе данных имеется таблица с курсами валют, которая былаполнена заранее каким-то внешним механизмом. Вы также могли бы использовать веб-
сервис, чтобы запросить обменные курсы из внешнего источника.
Реализация CurrencyProvider передает строку подключения для реализации Currencyоторая использует эту информацию для создания ObjectContext. Суть дела заключаетс реализации метода GetExchangeRateFor, показанного в следующем листинге.
Листинг 4-10: Реализация Currency, поддерживаемая SQL Serveublic override decimal GetExchangeRateFor(string currencyCode)
{
var rates = (from r in this.context.ExchangeRatehere r.CurrencyCode == currencyCode
|| r.CurrencyCode == this.codelect r)
.ToDictionary(r => r.CurrencyCode);
return rates[currencyCode].Rate / rates[this.code].Rate;
}
Первое, что нужно сделать, это получить курсы из базы данных. В таблице приведенены, определенные против одной, единой валюты (DKK), так что вам нужны оба курсатобы иметь возможность выполнить надлежащую конверсию между любыми двумалютами. Вы будет индексировать извлекаемые валюты кодом валюты, так что вы легкх найдете на заключительном этапе расчета.
Эта реализация потенциально выполняет много коммуникаций «вне процесса» с базоанных. Метод ConvertTo в Basket в конечном итоге вызывает этот метод в цикле, и
143
обращение к базе данных при каждом вызове, скорее всего, будет иметь пагубныоследствия для производительно сти. Я вернусь к этой проблеме в следующем разделе.
Связанные паттерны
В отличие от других DI паттернов из этой главы, в основном мы используем внедрение етод тогда, когда в нас уже есть экземпляр зависимости, который мы хотим передать длазных операций, но мы не знаем конкретные типы операций во время разработки
(например, в случае с надстройками).
С внедрением в метод мы находимся по другую сторону дороги по сравнению с другими
DI паттернами: мы не потребляем зависимости, а даем ее. У типов, которым моставляем зависимость, нет выбора в том, как моделировать DI или нуждаются ли они ависимости вообще. Они могут потреблять ее или игнорировать, как они посчитаюужным.
144
4.4. Окружающий контекст (Ambient
Context)
Как мы можем сделать зависимость доступной для каждого модуля, не загрязняаждый API Cross-Cutting Concerns?
Делая ее пригодной для использования через статический доступ.
Рисунок 4-8: Каждый модуль при надобности может получить доступ к Ambient Context
По-настоящему универсальный Cross-Cutting Concern потенциально может загрязнитольшую часть API для приложения, если вам нужно передать экземпляр каждомлементу. В качестве альтернативы можно определить контекст, доступный всем, кто ем нуждается, и который может быть проигнорирован всеми остальными.
Как это работает
Am bient Context (окружающий контекст) доступен любому потребителю через статическовойство или метод. Потребляющий класс может использовать его так:
public string GetMessage()
{
return SomeContext.Current.SomeValue;
}
В данном случае контекст имеет статическое свойство Current, к которому потребителожет получить доступ. Это свойство может быть по-настоящему статическим или можеыть связано с выполняемым в данный момент потоком.
Чтобы быть полезным в DI сценариях, контекст сам по себе должен быть абстракцией олжна иметься возможность менять контекст извне: для предыдущего примера этбозначает, что свойство Current должно быть доступно для записи. Контекст сам по себожет быть реализован так, как показано в следующем листинге.
145
Листинг 4-11: Ambient Context
1. public abstract class SomeContext
2. {
3. public static SomeContext Current
4. {
5. get
6. {
7. var ctx =
8. Thread.GetData(
9. Thread.GetNamedDataSlot("SomeContext"))
10. as SomeContext;
11. if (ctx == null)
12. {
13. ctx = SomeContext.Default;
14. Thread.SetData(
15. Thread.GetNamedDataSlot("SomeContext"),
16. ctx);
17. }
18. return ctx;
19. }
20. set
21. {
22. Thread.SetData(
23. Thread.GetNamedDataSlot("SomeContext"),
24. value);
25. }
26. }
27. public static SomeContext Default =
28. new DefaultContext();
29. public abstract string SomeValue { get; }
30. }
Строки 7-10: Получить текущий контекст из TLS
Строки 22-24: Сохранить текущий контекст в TLS
Строка 29: Значение, переносимое контекстом
Контекст является абстрактным классом, который позволяет заменить один контексругой реализацией во время выполнения.
В данном примере свойство Current сохраняет текущий контекст в Локальном
Хранилище Потока (Thread Local Storage (TLS)), что обозначает, что каждый поток имеевой собственный контекст, который независим от контекста любого другого потока. В
случаях, когда для TLS не был присвоен контекст, возвращается реализация пмолчанию. Важно иметь возможность гарантировать, что ни один потребитель нолучит NullReferenceException, когда он попытается получить доступ к свойству
Current, поэтому нужно иметь хорошую Local Default. Отметим, что в этом случавойство Default распределяется по всем потокам. Это работает, потому что в данноримере DefaultContext (класс, который наследуется от SomeContext) являетсеизменным. Если контекст по умолчанию изменяемый, вам нужно будет назначиттдельный экземпляр для каждого потока, чтобы предотвратить перекрестное загрязнениотоков.
Внешние клиенты могут назначить новый контекст для TLS. Обратите внимание, чтозможно присвоить null, но если это произойдет, то следующая операция чтенивтоматически переназначит контекст по умолчанию.
146
Весь смысл использования Am bient Context заключается во взаимодействии с ним. В
данном примере это взаимодействие представлено одиночным абстрактным строковывойством, но контекстный класс может быть и простым, и сложным, когда этеобходимо.
Внимание
Для простоты я слегка пропустил безопасность потоков в коде в листинге 4-11. Если вешили реализовать основанный на TLS Am bient Context, убедитесь, что вы знаете, чтелаете.
С овет
Пример в листинге 4-11 использует TLS, но вы также можете использовать CallContexля получения подобного результата.
Примечание
Ambient Context не обязательно должен быть связан с потоком или вызываемыонтекстом. Иногда имеет больше смысла сделать так, чтобы он применялся ко всему
AppDom ain, указав его как static.
Если вы хотите заменить контекст по умолчанию пользовательским контекстом, вожете создать пользовательскую реализацию, которая наследуется от контекста, азначить ее в нужное время:
SomeContext.Current = new MyContext();
Для контекста на основе TLS вы должны присвоить пользовательский экземпляр, когды создаете новый поток, в то время как по-настоящему универсальный контекст можназначить в Com position Root.
Когда это использовать
Ambient Context должен быть использован только в редчайших случаях. Для большинствлучаев больше подходят внедрение в конструктор или внедрение в свойство, но у ваожет быть реальный Cross-Cutting Concern, который загрязняет каждый API в вашериложении, если вам нужно передать его всем сервисам.
Внимание
Ambient Context сходный по структуре с анти-паттерном Service Locator, который я опиш главе 5. Разница состоит в том, что Ambient Context предоставляет экземпляр толькдной, строго типизированной зависимости, в то время как Service Locatoредположительно должен обеспечить экземпляры для каждой зависимости, которую вожете запросить. Различия являются тонкими, так что убедитесь, что вы полностьонимаете, когда следует применять Ambient Context, прежде чем сделать это. Если вомневаетесь, выберите другой DI паттерн.
В разделе 4.4.4, что я реализую TimeProvider, который может быть использован, чтоболучить текущее время, и я также объясню, почему я предпочитаю его статическиленам DateTime. Т екущее время является настоящим Cross-Cutting Concern, потому что
147
вы не можете предсказать, каким классам в каких слоях оно может понадобиться.
Большинство классов, вероятно, могут использовать текущее время, но лишь небольшаасть из них собираются это сделать.
Потенциально это может заставить вас писать много кода с дополнительным параметром
TimeProvider, потому что вы не знаете, когда он сможет вам понадобиться:
public string GetSomething(SomeService service,
TimeProvider timeProvider)
{
return service.GetStuff("Foo", timeProvider);
}
Предыду щий метод передает параметр TimeProvider для этого сервиса. Это можеыглядеть безобидно, но когда мы затем просмотрим метод GetStuff, мы обнаружим, чтто никогда не используется:
public string GetStuff(string s, TimeProvider timeProvider)
{
return this.Stuff(s);
}
В данном случае параметр TimeProvider передается в качестве дополнительного багажолько потому, что он может однажды понадобиться. Это загрязняет API ненужными
CCC, и код становится дурнопахнущим.
Ambient Context может быть решением этой проблемы, если встретятся условияписанные в таблице 4-4.
Таблица 4-4: Условия для реализации Ambient Context
Условие Описание
Вам нужно, чтобонтекст быапрашиваемым.
Если вам нужно только записать некоторые данные (все методы длонтекста возвращают void), перехват (Interception) являетсучшим решением. Может показаться, что это редкий случай, но оовольно частый: создать лог, что что-то случилось, записатетрики производительности, доказать, что контекст безопасносте подвержен риску – все подобные действия являются чистымтверждениями (Assertion), которые лучше моделируются промощи перехвата. Вы должны только рассмотреть возможностспользования Ambient Context, если необходимо запросить его длекоторого значения (например, текущего времени).
Существует хорошая
Local Default.
Существование Ambient Context является неявным (подробнее отом далее), поэтому очень важно, чтобы контекст просто работалаже в тех случаях, когда он не назначен явно.
Он должен бытарантированноступен.
Даже при надлежащей Local Default, важно сделать так, чтобы ныло возможности присвоить null, что сделает контекседоступным и все клиенты выбросят NullReferenceExceptions.
Листинг 4-11 показывает некоторые из шагов, которые можнредпринять, чтобы обеспечить это.
148
В большинстве случаев, преимущества Ambient Context не оправдывают недостаткиоэтому убедитесь, что вы можете удовлетворить всем этим условиям, а если не можетеассмотрите другие альтернативы.
Таблица 4-5: Преимущества и недостатки Ambient Context
Преимущества Недостатки
Не засоряет API Неявный
Всегда доступен Тяжело корректно реализовать
Может неправильно работать в конкретных рантаймах
Фактически самым большим недостатком Ambient Context является его имплицитностьо, как видно из листинга 4-11, может также быть трудно реализовать его правильно огут возникнуть проблемы с некоторыми средами исполнения (ASP.NET).
В следующих разделах мы более детально рассмотрим каждый из недостатков, которыписаны в таблице 4-5.
Неявность
Рассмотрим класс, показанный на рисунке 4-9: он не проявляет никаких внешниризнаков использования Ambient Context, а метод GetMessage реализуется следующибразом:
public string GetMessage()
{
return SomeContext.Current.SomeValue;
}
Рисунок 4-9: Класс и его метод GetMessage не проявляют внешних признакоспользования Ambient Context, но это вполне может быть так.
Когда Ambient Context правильно реализован, вы можете, по крайней мере, ожидать, чте будет выброшено никаких исключений, но в этом примере контекст влияет новедение метода, поскольку он определяет возвращаемое значение. Если контексзменится, может поведение измениться, и вы сразу и не поймете, почему это произошло.
149
Примечание
В Domain-Driven Design, Эрик Эванс обсуждает Intention-Revealing Interfaces (Evans,
Domain-Driven Design, 246), где речь идет о том, что API должен коммуницировать, что оелает только при помощи своего открытого интерфейса. Когда класс использует Ambient
Context, он делает с точностью до наоборот: ваш шанс узнать, что имеет место быть тоамый случай, заключается только в чтении документации или просмотре кода.
Помимо потенциальных тонких ошибок это неявность также затрудняет обнаружениочки расширяемости класса. Ambient Context позволяет внедрить пользовательскооведение в любой класс, который использует его, но не очевидно, что это может бытак. Вы можете обнаружить это, читая документацию или понимания реализацию гораздолее подробно, чем вы могли бы хотеть.
Запутанная реализация
Правильная реализация Ambient Context может оказаться непростой задачей. По крайнеере, вы должны гарантировать, что контекст находится всегда в последовательно остоянии, то есть он не должен выбрасывать любые NullReferenceExceptions толькотому, что одна реализация контекста была удалена без замены на другую.
Чтобы убедиться в этом, вам необходимо иметь подходящую Local Default, которая можеыть использована, если никакая другая реализация не была явно определена. В листинге
4-11 я использовал отложенную инициализацию свойства Current, потому что C# нключает потоко-статические инициализатор ы.
Когда Ambient Context представляет собой поистине универсальную концепцию, вожете получить это при помощи простого записываемого Одиночка (Singleton): одикземпляр, который распространяется по всему AppDomain. Я покажу вам пример этогалее.
Ambient Context может также представлять контекст, который варьируется в зависимостт контекста в стеке вызовов, например от того, кто инициировал запрос. Мы видим этасто в веб-приложениях и веб-сервисах, где тот же самый код выполняется в контекстескольких пользователей – и каждый на своем собственном потоке. В этом случае
Ambient Context может иметь сходство с выполняемым в данный момент потоком раниться в TLS, как мы видели в листинге 4-11, но это приводит к другим вопросам, астности для ASP.NET.
Проблемы с ASP.NET
Когда Ambient Context использует TLS, могут возникать проблемы с ASP.NET, потомто он может менять потоки в определенные моменты жизненного цикла страницы, и неикакой гарантии, что все, что хранится в TLS, будет скопировано из старого потока овый.
Если такое случается, то вместо TLS вы должны использовать текущий HttpContext длранения специфичных для запроса данных.
Это поведение по переключению потоков не является проблемой, если Ambient Context –
это универсально распространяющийся экземпляр, потому что Singleton является общиля всех потоков в AppDomain.
150
Использование
.NET BCL содержит несколько реализаций Ambient Context.
Безопасность решается при помощи интерфейса
System.Security.Principal.IPrincipal, который связан с каждым потоком. Вы можетолучить или установить текущей принципал для потока при помощи аксессора
Thread.CurrentPrincipal.
Другой Ambient Context на основе TLS моделирует текущую культуру потока.
Thread.CurrentCulture и Thread.CurrentUICulture и позволяют получить доступ зменить язык и региональные параметры текущей операции. Многие форматирующие
API, такие как парсинг и преобразование типов значений, неявно используют текущиегиональные параметры и язык, если иное не предоставлено явно.
Трассировка является примером универсального Ambient Context. Класс Trace не связан онкретным потоком, но действительно является общим для всего AppDomain. Вы можетаписать сообщение трассировки отовсюду при помощи метода Trace.Write, и оно будеаписано для любого количества TraceListeners, которые конфигурируются свойством
Trace.Listeners.
Пример: кеширование Currency
Абстракция Currency в примере коммерческого приложения из предыду щих разделоримерно такая же «говорящая», как и интерфейс. Каждый раз, когда вы хотитонвертировать валюту, вы вызываете метод GetExchangeRateFor, который потенциальнщет обменный курс в какой-то внешней системе. Это гибкий API дизайн, потому что вожете посмотреть курс фактически в режиме реального времени, если вам это нужно, н большинстве случаев в этом не будет необходимости, и это, скорее всего, может статзким местом.
Реализация на основе SQL Server, которую я представил в листинге 4-10, конечноыполняет запрос к базе данных каждый раз, когда вы запрашиваете обменный курсе.
Когда приложение отображает покупательскую корзину, каждый элемент в корзинонвертируется, так что это приводит к запросам к базе данных для каждого элемента орзине, даже если курс не меняется от первого до последнего элемента. Было бы лучшэшировать обменный курс на некоторое время, чтобы приложению не нужно былтучаться к базе данных по поводу одного и того же обменного курса несколько раз ределах одной доли секунды.
В зависимости от того, насколько это важно – иметь текущие валюты, время кэша можеыть коротким или длинным: кэш для одной секунды или для нескольких часов. Тайм-ауолжен быть настраиваемым.
Чтобы определить, когда истекает кэш валюты, вам нужно знать, сколько времени прошл того момента, когда валюта была закеширована, так что вы должны иметь доступ екущему времени. DateTime.UtcNow кажется встроенным Ambient Context, но это не такотому что вы не можете назначить время, только запросить его.
Неспособность переопределить текущее время редко вызывает проблемы в реальнориложении, но может быть проблемой при модульном тестировании.
151
Моделирование времени
В то время как обычному веб-приложению вряд ли нужна возможность изменять текущеремя, другой тип приложений может извлечь большую пользу от этой способности.
Однажды я написал довольно сложный движок моделирования, который зависел оекущего времени. Поскольку я всегда использую Test-Driven Development (TDD), я ужспользовал абстракцию текущего времени, так что я мог внедрить экземпляры DateTimeоторые отличались от реального машинного времени. Это оказалось огромныреимуществом, когда мне позже понадобилось ускорить время в симуляции на несколькорядков. Все, что я должен был сделать, это зарегистрировать провайдер времениоторый ускорял время, и вся симуляция немедленно ускорялась.
Если вы хотите увидеть аналогичный функционал, вы можете посмотреть на клиентскориложение Всемирного телескопа (WorldWide Telescopettp://www.worldwidetelescope.org), которое позволяет моделировать ночное небо скоренном времени. На рисунке ниже показан скриншот элемента управления, которыозволяет запускать время вперед и назад с различной скоростью. Я понятия не имеюеализовали ли разработчики эту возможность при помощи провайдера времени с Ambient
Context, но это то, что сделал бы я.
Всемирный телескоп позволяет поставить время на паузу или промотать его назад перед с различной скоростью. Это симулирует вид ночного неба в разное время.
В случае с примером коммерческого приложения, я хочу иметь возможностонтролировать время, когда я пишу юнит тесты, чтобы я мог убедиться, что кэш валюстекает правильно.
152
TimeProvider
Время является довольно универсальной концепцией (даже если время движется с разнокоростью в разных частях Вселенной), поэтому я могу моделировать его как всеобщаспространенный ресурс. Поскольку нет никаких причин иметь отдельные провайдерремени для каждого потока, Ambient Context TimeProvider является записываемым
Singleton, как показано в следующем листинге.
Листинг 4-12:TimeProvider Ambient Context
1. public abstract class TimeProvider
2. {
3. private static TimeProvider current;
4. static TimeProvider()
5. {
6. TimeProvider.current =
7. new DefaultTimeProvider();
8. }
9. public static TimeProvider Current
10. {
11. get { return TimeProvider.current; }
12. set
13. {
14. if (value == null)
15. {
16. throw new ArgumentNullException("value");
17. }
18. TimeProvider.current = value;
19. }
20. }
21. public abstract DateTime UtcNow { get; }
22. public static void ResetToDefault()
23. {
24. TimeProvider.current =
25. new DefaultTimeProvider();
26. }
27. }
Строки 6-7: Инициализация TimeProvider по умолчанию
Строки 14-17: Ограждающее условие
Строка 21: Важная часть
Цель класса TimeProvider состоит в том, чтобы вы могли контролировать, как времоводится до клиентов. Как описано в таблице 4-4, Local Default важна, поэтому втатически инициализируете класс, чтобы использовать класс DefaultTimeProvider (окажу вам это в ближайшее время).
Еще одно условие из таблицы 4-4 заключается в том, что вы должны гарантировать, что
TimeProvider никогда не будет в нестабильном состоянии. Поле current никогда нолжно быть null, поэтому ограждающее условие гарантирует, что этого никогда нудет.
Все это основа, чтобы сделать TimeProvider доступным отовсюду. Смыслом егуществования является способность обрабатывать экземпляры DateTimeредставляющие текущее время. Я целенаправленно смоделировал имя и сигнатуру
153
абстрактного свойства после DateTime.UtcNow. При необходимости я могу такжобавили такие абстрактные свойства как Now и Today, но я не нуждаюсь в них для этогримера.
Наличие надлежащей и значимой Local Default является важным, и к счастью, для этогримера это не трудно сделать, потому что она должна просто вернуть текущее время.
Это означает, что пока вы явно не войдете и не назначите другой TimeProvider, люболиент, использующий TimeProvider.Current.UtcNow, получит реальное текущее время.
Реализация DefaultTimeProvider показана в следующем листинге.
Листинг 4-13: Провайдер времени по умолчаниublic class DefaultTimeProvider : TimeProvider
{
public override DateTime UtcNow
{
get { return DateTime.UtcNow; }
}
}
Класс DefaultTimeProvider наследуется от TimeProvider, чтобы предоставить реальноремя каждый раз, когда клиент читает свойство UtcNow.
Когда CachingCurrency использует Ambient Context TimeProvider для получениекущего времени, он получит реальное текущее время, пока вы напрямую не назначитриложению другой TimeProvider; и я планирую сделать это только в моих модульныестах.
Кэширование валют
Для реализации кэширования валют, нужно реализовать Декорат ор (Decorator), которыеняет "правильную" реализацию Currency.
Примечание
Паттерн проектирования Декорат ор является важной частью перехвата, я буду обсуждатто более подробно в главе 9.
Вместо изменения существующей, поддерживаемо й SQL Server реализации Currencyоказанной в листинге 4-10, вы просто обернете кэш вокруг нее и только вызоветеальную реализацию, если кэш истек или не содержит записи.
Как вы помните из раздела 4.1.4, CurrencyProvider – это абстрактный класс, которыозвращает экземпляры Currency. CachingCurrencyProvider реализует тот же базовыласс и оборачивает функционал содержащегося CurrencyProvider. Всякий раз, когда оапрашивает Currency, он возвращает Currency, созданный содержащимся
CurrencyProvider, но обернутый в CachingCurrency (см. рисунок 4-10).
154
Рисунок 4-10: CachingCurrencyProvider оборачивает "реальный" CurrencyProvider озвращает экземпляры CachingCurrency, которые оборачивают "реальные" экземпляр ы
Currency.
Такой паттерн позволяет мне кэшировать любую реализацию валюты, а не толькеализацию на основе SQL Server, которая есть у меня в настоящее время. Рисунок 4-11
показывает план класса CachingCurrency.
Рисунок 4-11: CachingCurrency принимает в свой конструктор внутреннюю валюту
(innerCurrency) и время действия кэша (cacheTimeout) и оборачивает функционанутренней валюты.
155
С овет
Паттерн Декоратор является одним из лучших способов реализации разделенитветственности (Separation of Concerns, SoC).
CachingCurrency использует внедрение в конструктор, чтобы получить "реальный"
экземпляр, чьи курсы валют он должен хранить в кэше. Например, CachingCurrencелегирует свое свойство Code свойству Code внутреннего Currency.
Интересной частью реализации CachingCurrency является его метод
GetExchangeRateFor, показанный в следующем листинге.
Листинг 4-14: Кэширование обменного курса
1. private readonly Dictionary<string, CurrencyCacheEntry> cache;
2. public override decimal GetExchangeRateFor(string currencyCode)
3. {
4. CurrencyCacheEntry cacheEntry;
5. if ((this.cache.TryGetValue(currencyCode,
6. out cacheEntry))
7. && (!cacheEntry.IsExpired))
8. {
9. return cacheEntry.ExchangeRate;
10. }
11. var exchangeRate =
12. this.innerCurrency
13. .GetExchangeRateFor(currencyCode);
14. var expiration =
15. TimeProvider.Current.UtcNow + this.CacheTimeout;
16. this.cache[currencyCode] =
17. new CurrencyCacheEntry(exchangeRate, expiration);
18. return exchangeRate;
19. }
Строки 4-10: Вернуть закэшированный обменный курс, если он подходит
Строки 16-17: Сохранить в кэше обменный курс
Когда клиент запрашивает обменный курс, вы сначала перехватываете вызов, чтобы найтод валюты в кэше. Если для запрошенного кода валюты есть действительная запись эше, вы возвращаете закэшированный обменный курс, и остальная часть методропускается. Я вернусь к оценке того, истекла ли запись чуть позже.
Только если действующего закэшированного обменного курса нет, вы вызываетнутренний Currency, чтобы получить обменный курс. Прежде чем вернуть егоеобходимо его кэшировать. Первый шаг состоит в вычислении срока истечения, и тут вспользуете TimeProvider Ambient Context, вместо более традиционного DateTime.Now. С
вычисленным сроком истечения вы можете кэшировать запись перед возвратоезультата.
Вычисление того, истек ли срок действия кэша, также делается при помощи TimeProvider
Ambient Context.
return TimeProvider.Current.UtcNow >= this.expiration;
156
Класс CachingCurrency использует TimeProvider Ambient Context во всех местах, где емужно текущее время, так что можно написать модульный тест, который точнонтролирует время.
Модификация времени
При модульном тестировании класса CachingCurrency, вы можете точно контролироватремя совершенно независимо от часов реальной системы. Это позволяет писатетерминистические модульные тесты, хотя тестируемая система (System Under Test,
SUT) зависит от концепции текущего времени. Следующий листинг показывает тестоторый проверяет, что хотя SUT запрашивает обменный курс четыре раза, внутренняалюта вызывается только дважды: при первом запросе и снова, когда истекает времействия кэша.
Листинг 4-15: Юнит тест на предмет того, что валюта корректно кэшируется и что сроействия корректно заканчивается
1. [Fact]
2. public void InnerCurrencyIsInvokedAgainWhenCacheExpires()
3. {
4. // Fixture setup
5. var currencyCode = "CHF";
6. var cacheTimeout = TimeSpan.FromHours(1);
7. var startTime = new DateTime(2009, 8, 29);
8. var timeProviderStub = new Mock<TimeProvider>();
9. timeProviderStub
10. .SetupGet(tp => tp.UtcNow)
11. .Returns(startTime);
12. TimeProvider.Current = timeProviderStub.Object;
13. var innerCurrencyMock = new Mock<Currency>();
14. innerCurrencyMock
15. .Setup(c => c.GetExchangeRateFor(currencyCode))
16. .Returns(4.911m)
17. .Verifiable();
18. var sut =
19. new CachingCurrency(innerCurrencyMock.Object,
20. cacheTimeout);
21. sut.GetExchangeRateFor(currencyCode);
22. sut.GetExchangeRateFor(currencyCode);
23. sut.GetExchangeRateFor(currencyCode);
24. timeProviderStub
25. .SetupGet(tp => tp.UtcNow)
26. .Returns(startTime + cacheTimeout);
27. // Exercise system
28. sut.GetExchangeRateFor(currencyCode);
29. // Verify outcome
30. innerCurrencyMock.Verify(
31. c => c.GetExchangeRateFor(currencyCode),
32. Times.Exactly(2));
33. // Teardown (implicit)
34. }
Строка 12: Установка TimeProvider Ambient Context
Строка 21: Должна быть вызвана внутренняя валюта
Строки 22-23: Должна быть закэширована
157
Строки 24-26: Время истечения срока действия
Строка 28: Должна быть вызвана внутренняя валюта
Строки 30-32: Проверка на то, что внутренняя валюта была вызвана правильно
Внимание, жаргон
Следующий текст содержит некоторую терминологию модульного тестирования: ыделил ее курсивом, а поскольку эта книга не о модульном тестировании, я отправляас к книге xUnit Test Patterns (Gerard Meszaros, xUnit Test Patterns: Refactoring Test Code
(New York: Addison-Wesley, 2007), которая является источником всех этих имеаттернов.
Одна из первых вещей, которую нужно сделать в этом тесте, заключается в создании
«дублера для т ест ирования» (Test Double) для TimeProvider, который будет возвращаткземпляры DateTime, как они определены, вместо того чтобы основываться на часаистемы. В этом тесте я использую динамический mock фреймворк, называемый Moq
(http://code.google.com/p/moq/), чтобы определить, что свойство UtcNow вернет тот же
DateTime, пока не указано иное. Когда все определено, эта заглушка (Stub) внедряется в
Ambient Context.
Первый вызов GetExchangeRateFor должен вызвать внутренний CachingCurrency
Currency, потому что еще ничего не находится в кэше, а два следующие вызова должнернуть кэшированное значение, потому что срок еще не истек, в соответствии аглушкой TimeProvider.
С парой кэшированных вызовов настала пора времени продвинуться вперед, вы меняетаглушку TimeProvider, чтобы вернуть экземпляр DateTime, для которого как раз истерок действия кэша, и снова вызываете метод GetExchangeRateFor, ожидая, что оызовет внутренний Currency во второй раз, потому что действительные записи кэшеперь уже истекли.
Поскольку вы ожидаете, что внутренний Currency вызывается дважды, вы, наконецбеждаетесь в этом, говоря внутреннему Currency Mock, что метод GetExchangeRateFoолжен быть вызван ровно два раза.
Одна из многих опасностей Ambient Context заключается в том, что как только оазначен, он остается одинаковым, пока не будут изменен снова, но в связи с его неявнориродой, об этом можно легко забыть. В модульном тесте, например, поведениепределенное с помощью теста в листинге 4-15, остается одинаковым, если не будевного сброса (что я делаю в Fixture Teardown). Это может привести к серьезнышибкам (на этот раз в моем тестовом коде), потому что это распространится и загрязниесты, которые выполняются после этого теста.
Ambient Context выглядит обманчиво простым в реализации и использовании и можеривести ко многим трудным для поиска ошибкам. Его можно использовать, но делайтто только тогда, когда не существует лучшей альтернативы. Это как хрен: отличнодходит для определенных вещей, но определенно не универсален.
158
Связанные паттерны
Ambient Context может быть использован для моделирования Cross-Cutting Concern, хотя ребует, чтобы у нас была подходящая Local Default.
Если окажется, что зависимость вообще не является Cross-Cutting Concern, вы должнзменить DI стратегию. Если у вас есть Local Default, вы можете переключиться ннедрение в свойство, а в противном случае вы должны использовать внедрение онструктор.
159
4.5. Резюме
Паттерны, представленные в этой главе, являются центральной частью DI. Вооружившись
Com position Root и соответствующим набором DI паттернов, вы можете реализоватсновы DI. При применении DI есть много нюансов и мелких деталей, которые нужныучить, но паттерны покрывают основную механику, которая отвечает на вопрос: как огу внедрит ь зависимости?
Эти паттерны не являются взаимозаменяемыми. В большинстве случаев вашим первыыбором должно быть внедрение в конструктор, но бывают ситуации, когда один иругих паттернов является лучшей альтернативой. Рисунок 4-12 показывает процесринятия решений, который может помочь вам принять решение о выборе нужногаттерна, но если есть сомнения, выберите внедрение в конструктор: вы никогда сильне ошибетесь в этом выборе.
Рисунок 4-12: В большинстве случаев вы должны выбирать внедрение в конструктор, нывают ситуации, когда один из других DI паттернов подходит лучше.
Первая вещь, которую нужно рассмотреть, заключается в понимании того, является лависимость тем, что вам нужно, или тем, что у вас уже есть, но вы хотите, чтобы ономмуницировала с другими сопредельными операциями. В большинстве случаев, вамероятно, нужна зависимость, но в сценариях надстройки вы можете захотеть передатадстройке текущий контекст. Каждый раз, когда зависимость может отличаться операции к операции, внедрение в метод является хорошим кандидатом для реализации.
Когда зависимость представляет Cross-Cutting Concern, выбор подходящего паттернависит от направления коммуникации. Если вам нужно только что-нибудь записать
160
(например, время, которое заняла операция, или то, какие значения передаются), лучшельтернативой является перехват (о котором я расскажу в главе 9). Он также хорошаботает, если ответ, который вам нужен от него, уже включен в определение интерфейса.
Кэширование является прекрасным примером этого использования перехвата.
Если вам необходимо запросить Cross-Cutting зависимость для ответа, который нключен в оригинальный интерфейс, вы можете использовать Ambient Context, тольксли у вас есть надлежащая Local Default, которая позволяет оформить сам контексазумным поведением по умолчанию, которое работает для всех клиентов без явноастройки.
Когда зависимость не представляет Cross-Cutting Concern, Local Default все еще являетсешающим фактором, поскольку она может сделать явное внедрение зависимостеобязательным – используется реализация по умолчанию, если не указанереопределяющая реализация. Этот сценарий может быть эффективно использован промощи внедрения в свойство.
В любых других случаях применяется паттерн внедрения в конструктор. Исходя иисунка 4-12, кажется, что внедрение в конструктор является последним оплотомоторый входит в игру только тогда, когда все остальное не дает результатов. Это вернишь отчасти, поскольку в большинстве случаев специализиро ванные паттерны нрименяются, и по умолчанию на поле остается внедрение в конструктор. Его легчонять и проще надежно реализовать, чем любой из других DI паттернов. Вы можетостроить целые приложения только с одним внедрением в конструктор, но пониманиругих паттернов может помочь вам в разумном выборе нужного в некоторых случаяхогда он не подходит.
В этой главе содержится систематический каталог, который объясняет, как вы должннедрять зависимости в ваши классы. В следующей главе DI рассматривается ротивоположной стороны, и в ней я расскажу, как не нужно обращаться с DI.
161
5. DI анти-паттерны
В гастрономическом плане Дания была одной из развивающихся стран в 1970х: я был тамо я никогда не страдал, потому что не знал ничего лучшего. В основном использовалисясо и картофель, но постепенно приходили и зарубежные идеи. Я думаю, что одна иричин заключалась в том, что это было на заре эры массового туризма.
Датчане массово отправлялись на юг, в другие части Европы, и самые смелые пробовалестную еду. После возвращения домой более молодое поколение все больше готовиласту, но ни один итальянец не распознал бы датскую версию соуса болоньезе.
Вот, что я думаю, произошло. Какому-то предприимчивому датскому туристонравилась тальятелла алла болоньезе (tagliatelle alla bolognese) так сильно, что онешила попытаться приготовить ее, когда вернулась домой. (Я предполагаю, что это быленщина, потому что мужчины в то время много не готовили). Она сделала все, чтобспомнить, что входит в соус, но это было не так просто из-за долгой поездки на автобусбратно в Данию.
Что касается ингредиентов, грудинка и красное вино были забыты, прежде чем онокинула Италию, мясной бульон и куриная печень были потеряны из памяти где-то в
Австрии или Швейцарии, а овощи один за другим выпадали из головы во время долгогути через (Западную) Германию. Когда она пересекла датскую границу, все, что осталост оригинального рецепта, – это нарезанный лук и мясной фарш, и их подают только дним типом пасты, которая легко доступна в Дании в то время - спагетти.
Мы ели блюдо, которое получилось в результате, в течение многих лет и любили его. В
какой-то момент в 1980-х годах, в рецепт были добавлены томатная паста и ореганотобы сделать его более похожим на исходный. Это был рецепт, который я использоваолее чем десять лет, пока кто-то не подсказал мне, что для улучшения вкусовых качестожно добавить еще морковь, сельдерей, куриную печень, красное вино и так далее.
Смысл истории заключается в том, что я думал, что делаю рагу алла болоньезе (ragu allolognese), тогда как в действительности я не был даже близок к этому. Мне никогда нриходило в голову ставить под сомнение подлинность рецепта, потому что я вырос им. Хотя подлинность не является конечным критерием, блюдо, приготовленное подлинному рецепту, намного вкуснее, и я не собираюсь возвращаться к моему старомецепту.
В предыдущей главе я кратко сравнил паттерны проектирования с рецептами. Паттербеспечивает общий язык, который мы можем использовать, чтобы сжато обсудитложное понятие, и рагу алла болоньезе – это такое понятие, потому что мы можебсудить, как оно согласуется с тальятелле или лазаньей. С другой стороны, когдонятие (или, скорее, реализация) искривлено, мы получаем анти-паттерн.
Примечание
Анти-паттерн представляет собой описание часто встречающихся решений проблемыоторые несомненно приводят к негативным последствиям (William J. Brown et al.,
AntiPatterns: Refactoring Software, Architectures, and Projects in Crisis (New York: W iley
Computer Publishing), 1998, 7).
162
Анти-паттерны часто бывают вызваны незнанием (как с моим соусом болоньезе), и иужно избегать, а знание этих общих ловушек может помочь вам избежать их. Онвляются более или менее формализованным способом описания распространеннышибок, которые люди совершают снова и снова, независимо друг от друга.
В этой главе я опишу некоторые общие анти-паттерны, связанные с DI. За время моеарьеры я видел, как все они используются в той или иной форме, и, каюсь, я сарименял более чем один из них. Во многих случаях они казались искренними попыткамрименить DI в приложении, но без полного понимания основ DI, реализация приносилольше вреда, чем пользы.
Изучение этих анти-паттернов должно дать вам представление о том, каких ловушеужно избегать в ваших первых DI проектах. Ваши ошибки не будут выглядеть точно тае, как мои или примеры, представленные здесь, но эта глава покажет вам, где кроютспасные признаки.
Анти-паттерны могут быть исправлены путем рефакторинга кода к одному из DI
паттернов, приведенных в главе 4. Сложность исправления в каждом отдельном случаависит от деталей реализации, но для каждого анти-паттерна я предоставлю некоторыбобщенные рекомендации, как провести рефакторинг по направлению к паттерну.
С овет
В этой главе я не уделяю слишком много места рефакторингу от DI анти-паттерна к DI
паттерну, потому что это не главная тема этой книги. Если вы заинтересованы олучении дополнительной информации о том, как вы можете перемеституществующее приложение в направлении DI, есть целая книга, где обсуждаетсефакторинг таких приложений: Working Effectively with Legacy Code (Michael Feathers,
Working Effectively with Legacy Code (New York: Prentice Hall, 2004)). Хотя в ней нассматривается исключительно DI, она охватывает многие из тех же понятий, что и я анной книге.
Анти-паттерны, описанные в этой главе, приведены в таблице 5-1. Рисунок 5-1
иллюстрирует структуру главы.
Таблица 5-1: DI анти-паттерны
Анти-паттерн Описание
Control Freak Зависимости управляются напрямую, в отличие от инверсиправления (Inversion of Control, IoC).
Bastard Injection Foreign Default используются как значения по умолчанию длависимостей.
Constrained
Construction
Предполагается, что конструкторы имеют особеннуюндивидуа льную сигнатуру.
Service Locator Неявный сервис может подавать зависимости потребителю, но неарантии, что он это сделает.
163
Рисунок 5-1: Структура этой главы принимает форму каталога анти-паттернов. Каждынти-паттерн описан так, что вы можете прочитать о нем отдельно от других анти-
паттернов.
Внимание
Эта глава отличается от других глав, потому что большая часть кода, который я покажам, дает примеры того, как не реализовывать DI. Не пытайтесь повторить это дома!
Так же, как внедрение в конструктор является наиболее важным DI паттерном, Control
Freak является самым доминирующим анти-паттерном. Он всеми силами предотвращаеас от применения любого надлежащего и нужного внедрения зависимостей, так что варидется сосредоточить свою энергию на этом анти-паттерне, прежде чем занятьсругими. С другой стороны, наиболее опасным является Service Locator, потому чтоздается впечатление, что он на самом деле решает проблему.
Остальная часть этой главы описывает каждый анти-паттерн более подробно. Вы можетрочитать ее от начала до конца или только о том, в чем вы заинтересованы: каждый анти-
паттерн занимает отдельный раздел. Тем не менее, если вы решили прочитать только одном анти-паттерне, вы должны сосредоточить свое внимание на Control Freak.
5.1. Control Freak
5.2. Bastard Injection
5.3. Constrained Construction
5.4. Service Locator
5.5. Резюме
164
5.1. Control Freak
Что является противоположнос тью инверсии управления? Первоначально терминверсия управления был придуман, чтобы определить противоположнос ть нормальномоложению дел, но мы не можем на самом деле говорить об анти-паттерне «Business as
Usual». Вместо этого, после долгих размышлений, я назвал его Control Freak, чтобписать класс, который никак не желает терять контроль над своими зависимостями.
Это происходит каждый раз, когда мы создаем новый экземпляр типа с помощьлючевого слова new. Когда мы делаем так, мы явно заявляем, что собираемсонтролировать жизненный цикл экземпляра и что никто не получит шанс на перехватого конкретного объекта.
С овет
Частота появления в коде ключевого слова new является очень грубым показателем тогоасколько код сильно связан.
Анти-паттерн Control Freak появляется всякий раз, когда мы получаем экземпляависимости, прямо или косвенно используя ключевое слово new в любом месте, кроме
Composition Root.
Примечание
Хотя ключевое слово new является запахом кода, когда дело доходит до меняющихсависимост ей, вам не нужно беспокоиться об использовании его для ст абильныависимост ей. В целом ключевое слово new не является "незаконными", но вы должноздерживаться от его использования, чтобы получить экземпляры меняющихсависимостей.
Наиболее вопиющим примером Control Freak является то, когда мы не делаем никакисилий, чтобы ввести абстракции в наш код. Вы видели несколько примеров в главе 2огда Мэри реализовала свое коммерческое приложение (раздел 2.1.1). В таком подходет попытки ввести DI, но даже там, где разработчики слышали о DI и компоновке, анти-
паттерн Control Freak часто может быть найден в различных вариациях.
В следующих разделах я покажу вам некоторые примеры, которые напоминают код, что идел в производственном использовании. В любом случае, у разработчиков были лучшиамерения программирования, используя интерфейсы (programm ing to interfaces), но оникогда не понимали движущие силы и мотивацию.
Пример: обновление зависимостей
Многие разработчики слышали о принципе программировании, используя интерфейсы, не понимают глубокий смысл всего этого. В попытке сделать правильную вещь илледовать советам и рекомендациям, они пишут код, который не имеет особого смысла.
В главе 2, вы видели пример ProductService, который использует экземплябстрактного класса ProductRepository (листинг 2-6), чтобы получить список
165
рекомендуемых товаров. В качестве напоминания, вот соответствующий метод по своерироде:
public IEnumerable<Product> GetFeaturedProducts(IPrincipal user)
{
return from p in this.repository.GetFeaturedProducts()
select p.ApplyDiscountFor(user);
}
По сравнению с листингом 2-6 я опустил ограждающее условие, но характерный моменаключается в том, что переменная repository представляет абстрактный класс. В главе 2
вы заметили, как поле repository может быть заполнено через внедрение в конструкторо я видел и другие, более наивные попытки, например, вот такую.
Листинг 5-1: Обновление ProductRepository
1. private readonly ProductRepository repository;
2. public ProductService()
3. {
4. string connectionString =
5. ConfigurationManager.ConnectionStrings
6. ["CommerceObjectContext"].ConnectionString;
7. this.repository = new SqlProductRepository(connectionString);
8. }
Строки 7: Напрямую создается новый экземпляр
Поле repository объявлено как абстрактный класс ProductRepository, поэтому люболен в классе ProductService (например, GetFeaturedProducts) будут разрабатыватьсри помощи интерфейса. Хотя это звучит правильно, но это не принесет особой пользыотому что во время выполнения тип всегда будет SqlProductRepository. Нет никакоозможности перехватить или изменить переменную repository, пока вы не поменяетод и перекомпилируете его.
Вы не получите многого, определив переменную как интерфейс или абстрактный класссли вы ее жестко закодировали на то, чтобы она всегда имела конкретный тип.
Единственное небольшое преимущество заключается в том, что конкретный типределяется только в одном или нескольких местах в программном коде, поэтому замендной конкретной реализации другой не потребует крупного рефакторинга. В эторимере вы должны только довести другую реализацию ProductRepository онструктор, в то время как остальная часть ProductService будет работать безменений.
Обновление зависимостей напрямую при помощи new является лишь одним примеронти-паттерна Control Freak. Прежде чем я перейду к анализу и возможным путясправления проблемы, созданной Control Freak, давайте посмотрим на несколькримеров, которые дадут вам более полное представление о контексте и общих неудачныопытках решения некоторых из полученных проблем.
В этом конкретном примере очевидно, что решение не является оптимальным.
Большинство разработчиков попытается усовершенствовать свой подход, как вы увидит следующем примере.
166
Пример: фабрика
Наиболее распространенная (ошибочная) попытка исправить явные проблемы бновлением зависимости при помощи new включает в себя какую-то фабрику. Естесколько вариантов, где речь идет о фабриках, и я вкратце опишу каждый из них:
? Конкретная фабрика (Concrete Factory)
? Абстрактная фабрика (Abstract Factory)
? Статическая фабрика (Static Factory)
Если сказать Мэри Роуэн (из главы 2), что она может иметь дело только с абстрактнылассом ProductRepository, она введет ProductRepositoryFactory, которая будеоздавать экземпляры, нужные для того, чтобы работа была сделана. Давайте послушаемак она обсуждает такой подход со своим коллегой Йенсом: я думаю, что их обсуждениудет охватывать варианты фабрик, которые я перечислил:
Мэри: Нам нужен экземпляр ProductRepository в классе ProductService. Тем не менее,
ProductRepository является абстракт ным, поэт ому мы не можем прост о создат ь еговые экземпляры, и наш консультант говорит , что мы не должны также создават овые экземпляры SqlProductRepository.
Йенс: Как насчет фабрики?
Мэри: Да, я подумала о т ом же, но я не знаю, что делат ь дальш е. Я не понимаю, как онешит наши проблемы. Смот ри ...
Мэри начинает писать код, чтобы показать проблему.
Конкретная фабрика
Это код, который пишет Мэри:
public class ProductRepositoryFactory
{
public ProductRepository Create()
{
string connectionString =
ConfigurationManager.ConnectionStrings
["CommerceObjectContext"].ConnectionString;
return new SqlProductRepository(connectionString);
}
}
Мэри: Эта ProductRepositoryFactory инкапсулирует знания о том, как создат кземпляры ProductRepository, но это не реш ает проблемы, потому что нам нужнспользоват ь это в ProductService вот т ак:
var factory = new ProductRepositoryFactory();
this.repository = factory.Create();
Мэри: Видишь? Теперь мы прост о должны создат ь новый экземпляр класса
ProductRepositoryFactory в ProductService, но это все же жест ко кодирует
167
использование SqlProductRepository. Единст венное, чего мы добились, эт о переместилроблему в другой класс.
Йенс: Да, я вижу... А мы не можем реш ить проблему при помощ и абст рактной фабрики?
Давайте поставим на паузу обсуждения Мэри и Йенса, чтобы оценить то, что произошло.
Мэри совершенно права в том, что класс конкретной фабрики не решает проблему Control
Freak, а только перемещает ее дальше. Это делает код более сложным. ProductServicеперь непосредственно контролирует жизненный цикл фабрики, а фабрикепосредственно управляет жизненным циклом ProductRepository, поэтому мы до сиор не может перехватить или заменить экземпляра repository во время выполнения.
Примечание
Не делайте выводов по этому разделу, что я вообще против использования классоонкретной фабрики. Конкретная фабрика может решить другие проблемы, такие каовторение кода, путем инкапсуляции сложной логики создания. Она просто не имееикакой ценности для DI. Используйте ее, когда это имеет смысл.
Довольно очевидно, что конкретная фабрика не решит никаких проблем DI, и я думаюто я никогда видел, чтобы она использовалась таким образом. Комментарий Йенса обстрактной фабрике звучит более перспективно.
Абстрактная фабрика
Давайте продолжим дискуссию Мэри и Йенса и посмотрим, что Йенс может сказать обстрактной фабрике.
Йенс: А что если мы сделаем фабрику абст рактной? Например, вот т ак:
public abstract class ProductRepositoryFactory
{
public abstract ProductRepository Create();
}
Йенс: Эт о означает, что мы жестко не кодируем любые ссылки на
SqlProductRepository, и мы можем использоват ь фабрику в ProductService, чт оболучит ь экземпляры ProductRepository.
Мэри: Но т еперь, когда фабрика абстракт ная, как мы получим ее новые экземпляры?
Йенс: мы создадим ее реализацию, которая возвращает экземпляры SqlProductService.
Мэри: Да, но как мы создадим экземпляр эт ого?
Йенс: мы прост о используем ключевое слово new в ProductService... Ой, подожди...
Мэри: Это просто вернет нас назад, от куда мы начали.
Мэри и Йенс быстро поняли, что абстрактная фабрика не меняет ситуацию. Сутаключается в том, что им нужен был экземпляр абстрактного класса ProductRepository теперь вместо этого нужен экземпляр абстрактной ProductRepositoryFactory.
168
Абстрактная фабрика
Абстрактная фабрика является одним из шаблонов проектирования из оригинальнониги Design Patterns. Она полезна для DI, потому что она может инкапсулироватложную логику, которая создает другие зависимости.
Она предлагает хорошую альтернативу полной передачи управления, которая участвует нверсии управления, потому что она частично позволяет потребителю контролироватизненный цикл зависимостей, созданных фабрикой; фабрика по-прежнему управляеем, что создается и как это создается.
Паттерн Abstract Factory встречается гораздо чаще, нежели вы можете ожидать: именключенных классов часто скрывают этот факт. Класс CurrencyProvider представленны разделе 4.1.4, на самом деле является абстрактной фабрикой с другим именем: этбстрактный класс, который создает экземпляры другого абстрактного класса (Currency).
В разделе 6.1 мы вернемся к паттерну Abstract Factory, чтобы увидеть, как он можеомочь в решении одного типа проблем, которые часто происходят с DI.
Мэри и Йенс сделали только такую реализацию фабрики, которая не была бы вредна длих. С другой стороны, это также не решит их проблемы; а поскольку предполагается, чтогика создания для экземпляров ProductRepository не будет сложной, такоспользование не имеет никакой ценности.
Теперь, когда Мэри и Йенс отвергли единственную безопасную реализацию фабрикиолько один вариант остается открытым.
С татическая фабрика
Мэри и Йенс собираются прийти к выводу. Давайте послушаем, как они принимаюешения о подходе, который, как они думают, будет работать:
Мэри: Давай сделаем статическую фабрику. Я тебе покажу:
public static class ProductRepositoryFactory
{
public static ProductRepository Create()
{
string connectionString =
ConfigurationManager.ConnectionStrings
["CommerceObjectContext"].ConnectionString;
return new SqlProductRepository(connectionString);
}
}
Мэри: Теперь, когда класс ст атический, нам не нужно думать, как его создат ь.
Йенс: Но у нас по-прежнему ост ает ся жесткая закодированность в т ом, чт о мозвращаем экземпляры SqlProductRepository, поэт ому разве это нам как-т оможет?
Мэри: Мы могли бы справиться с эт им через наст ройку конфигурации, которапределяет, какой тип ProductRepository создат ь. Примерно вот так:
169
public static ProductRepository Create()
{
var repositoryType =
ConfigurationManager.AppSettings["productRepository"];
switch (repositoryType)
{
case "sql":
return ProductRepositoryFactory.CreateSql();
case "azure":
return ProductRepositoryFactory.CreateAzure();
default:
throw new InvalidOperationException("...");
}
}
Мэри: Видиш ь? Таким образом, мы можем определить, должны ли мы использоват еализацию на основе SQL Server или реализацию на основе Windows Azure, и нам даже нужно перекомпилировать приложение, чтобы переходит ь от одной к другой.
Йенс: Супер! Это то, чт о мы сделаем. Консульт ант должен быт ь счастлив.
Есть несколько причин, почему такая статическая фабрика не дает удовлетворительногешения первоначальной цели программировании при помощи интерфейсов. Давайтосмотрим на граф зависимостей на рисунке 5-2.
Рисунок 5-2: Граф зависимостей для предполагаемого решения: статический
ProductRepositoryFactory используется для создания экземпляро в ProductRepository.
Я не приукрашиваю
Если бы я был консультантом в этом примере, я не был бы в восторге. На самом делеакое "решение" было предложено на проекте, с которым я был связан, и я написал 14-
страничный документ, описывающий, почему это не будет работать и что делать вместтого.
Это был довольно большой проект, который был нацелен на центральную деловубласть компании Fortune 500, поэтому надлежащая модульность была важна в связи сложностью применения. К сожалению, я стал участвовать в проекте слишком поздно, и
170
мои предложения были отклонены, потому что они несли драматические изменения в ужазработанный код.
Я переключился на другие проекты, но позже я узнал, что, хотя команде удалось сделатостаточно для выполнения контракта, проект был признан неудачным, и полетелоловы.
Было бы неразумным утверждать, что проект не удался только потому, что не былспользовано DI, но принятый подход был симптомом отсутствия надлежащегроектирования. Я не могу сказать, что я был удивлен, узнав, что проект так и не удался.
Все классы должны ссылаться на абстрактный класс ProductRepository:
? ProductService, потому что потребляет экземпляры ProductRepository
? ProductRepositoryFactory, потому что раскрывает экземпляры
ProductRepository
? AzureProductRepository и SqlProductRepository, потому что они реализуют
ProductRepository
ProductRepositoryFactory зависит от обоих классов AzureProductRepository и
SqlProductRepository. Поскольку ProductService напрямую зависит от
ProductRepositoryFactory, он также зависит от обеих реализаций ProductRepository.
Крах зависимости
Плохая ситуация возникает, когда абстракция ProductRepository и потребляющий
ProductService определены в одной сборке (как это имеет место с реализациямиоторые я создавал в книге до сих пор). Давайте предположим, что это сборка доменноодели. В этом случае, ProductRepositoryFactory также должна быть в этой же сборкеначе у нас была бы циклическая ссылка, которая не представляется возможной.
Тем не менее, фабрика имеет ссылки на обе реализации, а у них есть ссылка на сборкоменной модели, поскольку они реализуют класс ProductRepository. Опять жединственный способ избежать циклической ссылки заключается в размещенионкретных реализаций в той же сборке.
Когда AzureProductRepository и SqlProductRepository реализованы в сборке доменноодели, это полностью идет вразрез с принципом разделения понятий (Separation of
Concerns). Мы, по существу, останемся с монолитным приложением.
Единственный выход из этой проблемы заключается в определении абстракции
ProductRepository в отдельной сборке. Это может быть хорошей идеей по многиругим причинам, но этого не достаточно, чтобы сделать статическую фабрикизнеспособным решением для DI.
Вместо слабо связанных реализаций ProductRepository, Мэри и Йенс в итоге получилесно связанные модули. Хуже того, фабрика всегда тянет за собой все реализации, даже, которые не нужны.
Если Мэри и Йенсу когда-нибудь понадобится третий тип ProductRepository, иридется изменить фабрику и перекомпилировать решение. Хотя их решение может бытастраиваемым, оно не является расширяемым.
171
Также невозможно заменить конкретные реализации ProductRepository тестовымеализациями, такими как динамические m ock, потому что это потребует определиткземпляры ProductRepository во время выполнения, а не статически в файлонфигурации во время разработки.
Примечание
Динамические mock выходят за рамки этой книги, но я кратко коснулся данной темыогда я описывал тестируемость в главе 1 (раздел 1.2.2).
Короче говоря, кажется, что статическая фабрика решает проблему, но ействительности лишь усугубляет ее. Даже в лучшем случае это заставит вас ссылатьса непостоянные зависимости.
Теперь, когда вы увидели много примеров Control Freak, я надеюсь, у вас есть довольнорошее представление о том, что искать: вхождения ключевого слова new рядом ависимостями. Это может позволить вам избежать наиболее очевидных ловушек, но еслам нужно оградить себя от возникновения этого анти-паттерна, в следующем разделбсуждается, как бороться с такой проблемой.
Анализ
Control Freak является антитезой инверсии управления. Когда мы напрямую управляеозданием изменчивых зависимостей, мы в конечном итоге получаем тесно связанныод, теряя многие (если не все) преимущества слабой связанности, описанной в главе 1.
Влияние
С тесно связанным кодом, который является результатом Control Freak, теряются многиреимущества модульной конструкции:
? Хотя мы можем настроить приложение для работы с одной из несколькиредварительно конфигурированных зависимостей, мы не можем заменить ихогда захотим. Не возможно предоставить реализацию, которая была создана послого, как было скомпилировано приложение, и, конечно же, не возможнредоставить конкретные экземпляр ы реализации.
? Все сложнее становится повторно использовать модуль, поскольку он приносит обой зависимости, которые могут быть нежелательны в новом контексте.
? Это усложняет параллельную разработку, потому что потребляющее приложение-
тесно связано со всеми реализациями его зависимостей.
? Страдает тестируемость, потому что динамические mock не могут бытспользованы в качестве заменителей зависимостей.
При тщательном проектировании мы можем все еще быть в состоянии реализовыватесно связанные приложения с четко определенными обязанностями, так чтоддерживаемость не страдает, но даже при этом цена слишком высока. Нам нужнтойти от Control Freak к надлежащим DI.
Рефакторинг к DI
Чтобы избавиться от Control Freak, мы должны сделать рефакторинг нашего кода дному из паттернов проектирования DI, представленных в главе 4. В качестве первого
172
шага, мы должны использовать руководство, чтобы определить, какой паттерн выбрать. В
большинстве случаев это будет внедрение в конструктор. Шаги рефакторингаключаются в следующем:
1. Убедитесь, что вы программируете, используя инт ерфейсы. В примерах, которые олько что представил, это уже имело место, но в других ситуациях, возможноотребуется сначала извлечь интерфейс и изменить объявления переменных.
2. Если вы создаете конкретную реализацию зависимостей в нескольких местахереместите их все в один метода создания. Убедитесь, что возвращаемое значенитого метода выражается в виде абстракции, а не конкретного типа.
3. Теперь, когда у вас есть только одно место, где вы создаете экземпляр, переместитто создание из потребляющего класса путем реализации одного из DI паттерновакого как внедрение в конструктор.
В случае с примерами ProductService из предыдущих разделов, внедрение в конструктовляется отличным решением:
private readonly ProductRepository repository;
public ProductService(ProductRepository repository)
{
if (repository == null)
{
throw new ArgumentNullException("repository");
}
this.repository = repository;
}
В некоторых случаях исходный код использует сложную логику для определения тогоак создавать экземпляры зависимости. В таком случае эта сложная логика может бытеализована в фабрике, а затем можно извлечь интерфейс такой фабрики для созданибстрактной фабрики. В сущности, это означает, что зависимость меняется, так что новабстрактная фабрика становится зависимостью вместо первоначальной абстракции, и можем применить ту же логику рефакторинга к фабрике. В большинстве случаев мы онечном итоге внедряем фабрику в потребляющий класс через его конструктор.
Control Freak является наиболее распространенным DI анти-паттерном. Он представляеобой способ по умолчанию создания экземпляров в большинстве языкорограммирования, так что его можно видеть даже в тех приложениях, где разработчикикогда не использовали DI. Это такой естественный и глубоко укорененный спосооздания новых объектов, что многим разработчикам трудно от этого отказаться. Дажогда, когда разработчики начинают думать о DI, многие все же полагают, что онолжны как-то контролировать, когда и где создаются экземпляр ы. Отказаться от такогонтроля может быть трудным психическим прыжком, но даже если вы сделаете это, ест другие, хотя и более мелкие, ловушки, которых нужно избегать.
Control Freak на сегодняшний день является самым разрушительным анти-паттерном, наже если у вас все под контролем, могут возникнуть более тонкие проблемы. В
следующих разделах рассматриваются эти анти-паттерны. Хотя они менероблематичны, чем Control Freak, их также, как правило, легче решить, так чтнимательно смотрите и исправляйте их, когда вы их обнаружите.
173
5.2. Bastard Injection
Перегруженные конструкторы являются довольно распространенными во многих базаода .NET (включая BCL). Часто многие перегруженные варианты обеспечиваюазумные значения по умолчанию для одного или двух полномасштабных конструкторовоторые принимают все соответствующие параметры в качестве входных данных.
Время от времени мы видим другое использование, когда речь идет о DI. Довольно общинти-паттерн определяет предназначенный для тестирования перегруженный варианонструктора, который позволяет нам явно определить зависимость, в то время каонструктор по умолчанию используется в производственном коде.
Это может быть вредным, когда реализация зависимости по умолчанию представляет
Foreign Default, а не Local Default.
Когда мы полностью охватываем DI, такие перегруженные конструкторы становятсишними в лучшем случае. Учитывая негативные последствия, лучше избегать их.
ProductService с Foreign Default
Когда Мэри первоначально реализовала класс ProductService (в главе 2), она имелвиду только одну зависимость: реализацию на основе SQL Server. Класс
SqlProductRepository изначально был задуман как единственная реализация
ProductRepository, поэтому казалось очевидным использовать его по умолчанию.
Foreign Default
Foreign Default является противоположностью Local Default. Это реализация зависимостиоторая используется по умолчанию, даже если она определена в другом модуле, чем еотребитель.
В качестве примера давайте рассмотрим реализации Repository, которые мы видели римере коммерческого приложения в предыду щих главах. Сервис, такой как
ProductService, требует для работы экземпляр ProductRepository. Во многих случаяхогда мы разрабатываем такие приложения, мы имеем в виду разумную реализацию: туоторая реализует нужный функционал путем чтения и записи данных в и из реляционноазы данных. Было бы заманчиво использовать такую реализацию по умолчанию.
Проблема заключается в том, что реализация по умолчанию, которую мы имеем в виду
(SqlProductRepository), определена в другом модуле, нежели ProductService. Этаставляет нас принять нежелательну ю зависимость для модуля CommerceSqlDataAccessак показано здесь.
Когда ProductService использует SqlProductRepository в качестве реализации пмолчанию, это заставляет нас делать жесткую ссылку на модуль
CommerceSqlDataAccess, а мы этого не хотим.
174
Использование нежелательных модулей отнимает у нас многие преимущества слабовязанности, которые обсуждались в главе 1. Все сложнее становится повторноспользование модуля CommerceDomain, потому что он потянет за собой модуль
CommerceSqlDataAccess, а мы, возможно, не захотим использовать это в другоонтексте. Это также усложняет параллельну ю разработку, потому что класс
ProductService теперь напрямую зависит от класса SqlProductRepository.
Таковы основные причины того, что вы должны избегать Foreign Default, если это вообщозможно.
Мэри еще не чувствует себя комфортно с идеей внедрения в конструктор, потому что ее есть проблема в выяснении, где будет размещена структура объекта. Она до сих пое обращала внимания на концепцию Composition Root.
Приглашенный консультант сказал ей использовать внедрение в конструктор для
ProductService, но она по-прежнему считает, что она должна создать его новыкземпляр следующим образом:
var productService = new ProductService();
Для этого она добавляет следующий код в класс ProductService.
Листинг 5-2: ProductService с Bastard Injectiorivate readonly ProductRepository repository;
public ProductService()
: this(ProductService.CreateDefaultRepository())
{
}
public ProductService(ProductRepository repository)
{
if (repository == null)
{
throw new ArgumentNullException("repository");
}
this.repository = repository;
}
private static ProductRepository CreateDefaultRepository()
{
string connectionString =
ConfigurationManager.ConnectionStrings
["CommerceObjectContext"].ConnectionString;
return new SqlProductRepository(connectionString);
}
Строки 2-5: Конструктор по умолчанию
Строки 6-13: Внедрение в конструктор
175
Класс ProductService теперь имеет конструктор по умолчанию, который вызывает егругой конструктор, используя Foreign Default.
Другой конструктор правильно реализует паттерн внедрение в конструктор, имеграждающее условие, а затем сохраняя внедренный ProductRepository в поле толькля чтения. Конструктор по умолчанию вызывает этот конструктор с Foreign Defaultозданной в закрытом методе CreateDefaultRepository. Класс SqlProductRepositorвляется Foreign Default, поскольку он определен в другой сборке, чем класс
ProductService. Это приводит к тому, что сборка, содержащая класс ProductServiceесно связана со сборкой, содержащей класс SqlProductRepository.
Хотя ProductService можно использовать с различными типами ProductRepositoryередавая их с помощью самого гибкого перегруженного варианта конструктора, Мэри нможет перехватить экземпляр ProductRepository в приложении, если она настаивает нспользовании конструктора по умолчанию.
Анализ
Bastard Injection наиболее часто встречается, когда разработчики пытаются сделать сволассы тестируемыми без полного понимания DI. При написании модульных тестов длласса очень важно, чтобы мы могли заменить изменчивую зависимость дублирующиестом, так чтобы мы могли правильно изолировать тестируемую систему (SUT) от еависимостей, и внедрение в конструктор позволяет сделать именно это.
Хотя Bastard Injection включает тестируемость, он имеет некоторые нежелательныоследствия.
Конкретный пример: ASP.NET MVC
Когда вы создаете новый ASP.NET MVC проект, автоматически создается нескольктандартных классов контроллеров. Одним из них является класс AccountControllerоторый использует Bastard Injection. В исходном коде это объясняется даже омментариях:
// Этот конструктор используется MVC фреймворк,
// чтобы создать экземпляр контроллера при помощи
// форм аутентификации по умолчанию и провайдеров членства.
public AccountController()
: this(null, null)
{
}
// Этот конструктор не используется MVC фреймворком,
// но он используется для упрощения юнит тестирования этого типа.
// Посмотрите комментарии в конце этого файла
// для более полной информации.
public AccountController(IFormsAuthentication formsAuth,
IMembershipService service)
{
this.FormsAuth = formsAuth ?? new FormsAuthenticationService();
this.MembershipService = service ?? new AccountMembershipService();
}
Как я могу сказать, что Bastard Injection – это плохо, когда кажется, что Microsofспользует и одобряет его? В данном случае, мотивация, кажется, исключительно связана
176
с тестируемостью, и Bastard Injection вполне соответствует этой цели – он просто ноответствует другим целям модульности, таким как способность к замещению овторному использованию модулей, а также параллельной разработке.
Другие придерживаются того же мнения. Айенде Райен отметил следующее в своелоге, в котором обсуждалось ASP.NET MVC приложение:
Я имею в виду, если вы хот ит е сделать слабый IoC – вперед. Но, пожалуйста, ноздавайте этого бастарда.
Эта фраза вдохновила меня назвать анти-паттерн так, как я это сделал.
Влияние
Основная проблема с Bastard Injection заключается в использовании Foreign Default. Хотестируемость и включена, мы больше не можем свободно повторно использовать классотому что это потянет за собой зависимость, которую мы не хотим. Кроме тогоараллельная разработка усложняется, потому что класс сильно зависит от своеависимости.
В дополнение к последствиям Bastard Injection для модульности приложенияуществование множества конструкторов также представляет собой другой тип проблемы.
Когда есть только один конструктор, DI контейнер может автоматически проводить всависимости, потому что никогда не встает вопрос, какой конструктор использовать.
Когда существует более чем один конструктор, выбор между конструкторами становитсеоднозначным. DI контейнеру приходится прибегать к своего рода эвристике, чтобделать выбор между различными конструкторами, или он может от этого отказаться. Каи странно, это один из немногих сценариев, где бедное DI менее подвержено влияниюотому что мы можем решать в каждом конкретном случае индивидуально, когда мручную проводим зависимости.
Среди различных анти-паттернов DI, Bastard Injection не так вреден, как Control Freak, н от него также гораздо легче избавиться.
Рефакторинг по направлению к DI
Bastard Injection часто является результатом ошибочной попытки реализовать DI. Хорошото есть такие основы, как программирование к интерфейсам, так что провестефакторинг к надлежащему DI паттерну легко.
С овет
Даже если вы думаете, что воздействие Bastard Injection вас не касается, вы все равнолжны провести рефакторинг к надлежащему DI паттерну. Ведь это так просто сделатьто не стоит даже сомневаться в нужности этого.
Первый шаг заключается в выборе того, какой DI паттерн соответствует цели. Рисунок 5-3
иллюстрирует простой процесс принятия решений. Если значение по умолчанию, которыыло использовано до сих пор, это Foreign Default, лучшим выбором является внедрение онструктор. В другом случае, хорошей альтернативой считается внедрение в свойство.
177
Рисунок 5-3: При рефакторинге от Bastard Injection решающий фактор заключается в томвляется ли зависимость Foreign Default или Local Default.
Во многих случаях, значение по умолчанию, используемое конструктором по умолчаниюредставляет Foreign Default. В этих случаях внедрение в конструктор является лучшитветом, потому что он так прост в реализации и хорошо справляется с любыми видамависимостей. Конструктор, который принимает зависимость в качестве параметра, ужуществует, так что единственное изменение, которое мы должны сделать в используемолассе, заключается в удалении конструктора по умолчанию.
Это, несомненно, приведет к некоторым ошибкам компилятора, но на данный момент можем опереться на компилятор и переместить весь код, который создаеассматриваемый класс, в Composition Root.
Когда значение по умолчанию представляет Local Default, ситуация очень напоминаесновной сценарий для внедрения в свойство. Хотя механика и разная, структура такае: в обоих случаях у нас есть подходящая Local Default, но мы все еще хотим открыташ потребляющий класс для расширяемости.
Это вырождающийся случай Bastard Injection, где воздействие гораздо менее серьезное.
Поскольку значение по умолчанию является Local Default, нет никакого влияния нтепень компонуемости класса; единственным негативным последствием является то, чтвусмысленно сть конструктора делает автовнедрение более сложным.
В данном случае мы могли бы реализовать внедрение в свойство, удалив конструктороторый принимает зависимость в качестве параметра, и заменив его свойством длаписи. Если это изменение приводит к ошибкам компилятора, мы снова можем оперетьса компилятор и переместить создание кода в Composition Root.
В Composition Root есть много различных способов компоновать зависимости, в том числакие, которые далеки от идеальных, как покажет следующий анти-паттерн.
178
5.3. Constrained Construction
Самая большая проблема должным образом реализовать DI заключается в том, чтобы вслассы с зависимостями были перемещены в Composition Root. Пока мы достигнем этогоы пройдем долгий путь.
И даже тогда все еще существуют некоторые ловушки, которые нужно отслеживать.
Распространенной ошибкой является требование того, чтобы у всех зависимостей быонструктор с конкретной сигнатурой. Как правило, это происходит от желания достичоздней связанности, так чтобы зависимости могли быть определены во внешнем файлонфигурации и тем самым изменены без повторной компиляции приложения.
Примечание
Так называемый паттерн Провайдер (Provider), используемый в ASP.NET, являетсримером Constrained Construction, потому что Провайдеры должны иметь конструкторо умолчанию. Это, как правило, усугубляется тем, что конструктор Провайдера пытаетситать файл конфигурации приложения. Часто конструктор генерирует исключение, еслеобходимый раздел файла конфигурации недоступен.
Примечание
Этот раздел относится только к тем сценариям, где нужно позднее связывание. В
сценариях, где мы напрямую ссылаемся на зависимости из корня приложения, у нас нетой проблемы – но опять же, у нас также нет возможности для замены зависимостей беовторной компиляции.
В главе 3 мы кратко коснулись этого вопроса. В этом разделе мы рассмотрим его болещательно.
Пример: отложенная связанность ProductRepository
В примере коммерческого приложения некоторые классы зависят от абстрактного класса
ProductRepository. Это означает, что для создания этих классов в первую очередеобходимо создать экземпляр ProductRepository. На данный момент вы узнали, что
Composition Root – это нужное место, чтобы сделать это. В приложении ASP.NET длтого есть Global.asax; следующий листинг показывает соответствующую часть, гдоздается экземпляр ProductRepository.
Листинг 5-3: Неявное ограничение конструктора ProductRepository
1. string connectionString =
2. ConfigurationManager.ConnectionStrings
3. ["CommerceObjectContext"].ConnectionString;
4. string productRepositoryTypeName =
5. ConfigurationManager.AppSettings
6. ["ProductRepositoryType"];
7. var productRepositoryType =
8. Type.GetType(productRepositoryTypeName, true);
9. var repository =
10. (ProductRepository)Activator.CreateInstance(
11. productRepositoryType, connectionString);
179
Строки 9-11: Создание экземпляра конкретного типа
Первое, что должно вызвать подозрение – это то, что строка соединения считывается иайла web.config. Зачем вам нужна строка соединения, если вы планируете обрабатывать
ProductRepository как абстракцию? Хотя, возможно, это и маловероятно, но вы можетахотеть реализовать ProductRepository с базой данных в памяти или XML файлом.
REST-сервис хранения данных, такой как Windows Azure Table Storage Service предлагаеолее реалистичную альтернативу, но в очередной раз самым популярным выборомажется, остаются реляционные базы данных. Повсеместное распространение баз данныедет к тому, что слишком легко забыть, что строка соединения неявно представляеыбор реализации.
Чтобы сделать позднюю привязку ProductRepository, вы должны определить, какой тиыл выбран в качестве реализации. Это можно сделать, прочитав имя типа, определенноборкой, из web.config и создав экземпляр типа с таким именем. Это само по себе нвляется проблемой – трудность возникает только тогда, когда вам нужно создаткземпляр этого типа.
С наличием Type вы можете создать экземпляр с помощью класса Activator. Метод
CreateInstance вызывает конструктор типа, поэтому вы должны передать верныараметры конструктору, чтобы предотвратить исключение. В этом случае нужно указаттроку соединения.
Если бы вы ничего не знали о приложении, только видели код в листинге 5-3, то вы бдивились, почему строка соединения передается в качестве аргумента конструктореизвестному типу. Это не имело бы больше смысла, если бы реализация была основана REST веб-сервисе или XML файле.
На самом деле, это не имеет смысла, так как это представляет собой случайнограничение для конструктора зависимости. В данном случае у вас есть неявноребование, чтобы любая реализация ProductRepository имела конструктор, которыринимает одну строку в качестве входных данных. Это дополнение к явномграничению, что класс должен наследоваться от ProductRepository.
Примечание
Неявное ограничение, что конструктор должен принять одну строку, по-прежнемставляет нам большую степень гибкости, потому что мы можем кодировать много разнонформации в строках для дальнейшего декодирования. Представьте себе, что вместтого ограничения был бы конструктор, который принимает TimeSpan и число, и вожете себе представить, насколько ограничивающим это было бы.
Можно утверждать, что ProductRepository на основе XML файла также потребуетроку в качестве параметра конструктора, хотя этой строкой будет имя файла, а не строкоединения. Тем не менее, концептуально это все равно будет странно, потому что вам всавно нужно было бы определить это имя файла в элементе connectionStrings eb.config (и в любом случае, я думаю, что такой гипотетический XmlProductRepositorолжен принять XmlReader в качестве аргумента конструктора, а не имя файла).
180
Моделирование конструкции зависимости исключительно на явных ограничениях
(интерфейса или базового класса) является намного более хорошим и более гибкиариантом.
Анализ
В предыдущем примере неявное ограничение требует от реализующих элементов иметонструктор с одним строковым параметром. Более распространенным ограничениевляется то, что все реализации должны иметь конструктор по умолчанию, так чтобаботала простейшая форма Activator.CreateInstance:
var dep = (ISomeDependency)Activator.CreateInstance(type);
Хотя это можно назвать наименьшим общим знаменателем, цена гибкости слишкоысока.
Влияние
Независимо от того, как мы ограничиваем строение объекта, мы теряем гибкость. Можеозникнуть соблазн заявить, что все реализации зависимостей должны иметь конструктоо умолчанию – в конце концов, они могли бы выполнять свою инициализацинутренне, например, чтением конфигурационных данных, таких как конфигурационнытроки, непосредственно из файла .config. Однако это ограничило бы нас по-другомуотому что мы, возможно, захотели бы иметь возможность компоновать приложенилоями экземпляров, которые включают другие экземпляры. В некоторых случаяхапример, мы могли бы захотеть распределить экземпляры между различнымотребителями, как показано на рисунке 5-4.
Рисунок 5-4: В этом примере мы хотим создать единственный экземпляр класса
ObjectContext и внедрить этот же экземпляр в оба репозитория. Это возможно только ом случае, если мы можем внедрить экземпляр извне.
Когда у нас есть более чем один класс, требующий одну и ту же зависимость, мыозможно, захотим поделиться одним экземпляро м со всеми этими классами. Этозможно только тогда, когда мы можем внедрить этот экземпляр извне. Хотя мы моглы написать код внутри каждого из этих классов, чтобы прочитать информацию о типаз конфигурационного файла, и использовать Activator.CreateInstance для созданиравильного типа экземпляра, мы никогда не смогли бы поделиться одним экземпляроаким способом – вместо этого у нас было бы несколько экземпляров одного классаоторые занимали бы больше памяти.
181
Примечание
Только потому, что DI позволяет нам делиться одним экземпляром среди многиотребителей, не означает, что мы всегда должны это сделать. Совместное использованикземпляра экономит память, но может создать проблемы взаимодействия, напримерроблем многопоточности. Решение о том, хотим мы поделиться экземпляром или нетесно связано с концепцией жизненного цикла объекта, которая обсуждается в главе 8.
Вместо введения неявных ограничений о том, как объекты должны быть построены, молжны реализовать наш Composition Root, так чтобы он мог работать с любыонструктором или методом фабрики, которые мы можем ему дать.
Рефакторинг по направлению к DI
Что делать, если у нас нет ограничений для компонентов конструктора, а нам нужнозднее связывание? Может возникнуть соблазн ввести абстрактную фабрику, которуожно использовать для создания экземпляров необходимой абстракции, а затеотребовать, чтобы реализации такой абстрактной фабрики имели конструкторы пмолчанию, но это приведет к тому, что мы будем лишь ходить вокруг да околроблемы, а не решать ее.
Внимание
Хотя мы можем использовать абстрактные фабрики, чтобы успешно реализовать поздневязывание, это требует дисциплины. В общем, нам будет лучше с надлежащим DI
контейнером; но я, тем не менее, покажу, как это сделать.
Давайте кратко рассмотрим такой подход. Представьте себе, что у вас есть абстракциервиса, образно называемая ISomeService. Схема абстрактной фабрики подсказываетто вам также нужен интерфейс ISomeServiceFactory. Рисунок 5-5 иллюстрирует эттруктуру.
Рисунок 5-5: ISomeService представляет реальную зависимость. Однако чтобы сохранитеализующие элементы свободными от неявных ограничений, вы пытаетесь разрешитопрос поздней связанности путем введения ISomeServiceFactory, которая будеспользоваться для создания экземпляров ISomeService. И вам потребуется любаабрика, поскольку у нее есть конструктор по умолчанию.
Теперь давайте предположим, что вы хотите использовать реализацию ISomeServiceоторому требуется рабочий экземпляр ISomeRepository, как показано в следующеистинге.
182
Листинг 5-4:SomeService который требует ISomeRepositorublic class SomeService : ISomeService
{
public SomeService(ISomeRepository repository)
{
}
}
Класс SomeService реализует интерфейс ISomeService, но требует экземпляр
ISomeRepository. Поскольку единственный конструктор не является конструктором пмолчанию, пригодится ISomeServiceFactory.
Теперь вы хотите использовать реализацию ISomeRepository, основанную на Entity
Framework. Вы называете эту реализацию SomeEntityRepository, и она определена ругой сборке, чем SomeService.
Поскольку вы не хотите перетащить ссылку в библиотеку EntityDataAccess наряду с
SomeService, единственным решением является реализация SomeServiceFactory в другоборке, чем SomeService, как показано на рисунке 5-6.
Рисунок 5-6: Класс SomeServiceFactory должен быть реализован в отдельной сборкеежели SomeService, чтобы предотвратить связанность библиотеки DomainModel иблиотеки EntityDataAccess.
Хотя ISomeService и ISomeServiceFactory похожи на сплоченную пару, важнеализовать их в двух различных сборках, так как фабрика должна иметь ссылки на всависимости, чтобы иметь возможность их правильно связывать.
По соглашению реализация ISomeServiceFactory имеет конструктор по умолчанию, тато вы можете написать имя типа, определенное сборкой, в файле .config и использовать
Activator.CreateInstance для создания экземпляра. Каждый раз, когда вам нужнвязывать вместе новую комбинацию зависимостей, необходимо реализовать новую
ISomeServiceFactory, чтобы провести именно эту комбинацию, а затем настроитриложение для использования этой фабрики вместо предыдущей. Это означает, что вы
183
не можете определить произвольные комбинации зависимостей без написания омпиляции кода, но вы можете сделать это без перекомпиляции самого приложения.
По сути, такая абстрактная фабрика становится абстрактным Composition Root, которыпределен в сборке отдельно от основного приложения. Хотя это, безусловно, являетсизнеспособным подходом, как правило, гораздо легче использовать DI контейнебщего назначения, который может сделать все это для нас сам на основе файлоонфигурации.
Анти-паттерн Constrained Construction применяется действительно только тогда, когда мспользуем позднее связывание, потому что когда мы используем раннее связываниеомпилятор гарантирует, что мы никогда не введем неявные ограничения в том, катроятся компоненты.
Последний анти-паттерн применяется более часто – некоторые люди даже считают егастоящим паттерном, а не анти-паттерном.
184
5.4. Service Locator
Это может быть трудным – отказаться от идеи прямого контроля зависимостей, поэтомногие разработчики выводят статические фабрики (как описано в разделе 5.1.2) на новыровень. Это приводит к анти-паттерну Service Locator.
Внимание
Это довольно спорно – называть Service Locator анти-паттерном. Некоторые людчитают его настоящим паттерном проектирования, тогда как другие (и я в том числе)
считают анти-паттерном. В этой книге я решил описать его как анти-паттерн, потому что умаю, что у него больше недостатков, чем преимуществ, но не удивляйтесь, если ввидите, что он одобрен в других местах. Важно понять преимущества и недостаткитобы иметь возможность принять для себя обоснованное решение.
Service Locator был введен в качестве паттерна проектирования Мартином Фаулером в
2004, поэтому обозначение его как анти-паттерн является большим шагом. Короче говорян вводит статическую фабрику с дополнительно й деталью, что становится возможннедрить сервисы в эту фабрику.
Примечание
Термин сервис в данном контексте приблизительно эквивалентен термину зависимость.
Как это чаще всего реализуется, Service Locator является статической фабрикой, котораожет быть сконфигурирована с конкретными сервисами, пока первый потребитель начинает ее использовать (см. рисунок 5-7). Это, вероятно, может произойти в
Com position Root. В зависимости от конкретной реализации, Service Locator может бытастроен с кодом, когда читаются файлы конфигурации или используется их комбинации.
Рисунок 5-7: Основная ответственность Service Locator заключается в том, чтоббрабатывать экземпляр ы сервисов, когда потребители их запрашивают. Consumeспользует интерфейс IService и запрашивает экземпляр от Service Locator, которыатем возвращает экземпляр той конкретной реализации, которую он должен вернуть
Основная обязанность Service Locator заключается в том, чтобы обрабатывать экземплярервисов, когда потребители их запрашивают. Потребитель использует интерфейс
IService и запрашивает экземпляр у Service Locator, который затем возвращает экземпляюбой конкретной реализации, которую он сконфигурирован вернуть.
185
Моя личная история с Service Locator
У меня с Service Locator были интенсивные отношения в течение нескольких лет, преждем мы расстались. Хотя я точно не помню, когда я впервые наткнулся на статью
Фаулера, мне показалось, что он предоставил мне потенциальное решение проблемыоторую я обдумывал в течение некоторого времени: как внедрить зависимости.
Как было описано, паттерн Service Locator казался ответом на все мои вопросы, и ыстро начал разрабатывать Service Locator для первой версии Microsoft patterns &
practices’ Enterprise Library. Это было размещено на ныне не существующем сайте
GotDotNet. Хотя у меня все еще есть исходный код, я потерял историю релизов, когда
GotDotNet закрыли, поэтому я не могу сказать наверняка, но я, кажется, опубликоваервую версию в середине 2005 года.
В 2007 году я выпустил полностью переписанный релиз, ориентированный на Enterprise
Library 2. Он по-прежнему доступен на CodePlex, но я давно уже отказался от негоотому что я вскоре пришел к выводу, что это был действительно анти-паттерн.
Как вы можете видеть, у меня ушло несколько лет интенсивного использования, чтобонять недостатки Service Locator и что существуют лучшие альтернативы. По эторичине я с легкостью понимаю, почему так много разработчиков находят егривлекательным, несмотря на его недостатки. Паттерны, описанные в главе 4редлагают более совершенные варианты, но вы не поймете недостатки Service Locatorока не изучите их.
Внимание
Если вы посмотрите только на статическую структуру классов, DI контейнер выглядит как
Service Locator. Разница мизерная и заключается не в механике реализации, а в том, как ве используете. В сущности, просьба к контейнеру или локатору разрешить полный граависимости из Composition Root является правильным использованием. Просьба о
"зернистых" сервисах из любого другого места подразумевает анти-паттерн Service
Locator.
Давайте рассмотрим пример, где он сконфигурирован с кодом.
Пример: ProductService, использующий Service Locator
Для примера давайте вернемся к нашему проверенному и истинному ProductServiceоторый требует экземпляр абстрактного класса ProductRepository. В данном случае
ProductService может использовать статический метод GetService, чтобы получитеобходимый экземпляр:
this.repository = Locator.GetService<ProductRepository>();
В данном примере я реализую методы, используя параметры дженерик типа, чтобказать тип запрашиваемого сервиса, но я также мог бы использовать экземпляр Typeтобы указать тип.
Как показано в следующем листинге, эта реализация класса Locator являетсинималистичной, насколько это возможно. Я мог бы добавить ограждающее условие бработку ошибок, но я хотел выделить основное поведение. Код может также включать в
186
себя возможность, которая позволяет загружать его конфигурацию из файла .config, но ставлю это в качестве упражнения для вас.
Листинг 5-5: Минимальная реализация Service Locator
1. public static class Locator
2. {
3. private readonly static Dictionary<Type, object> services
4. = new Dictionary<Type, object>();
5. public static T GetService<T>()
6. {
7. return (T)Locator.services[typeof(T)];
8. }
9. public static void Register<T>(T service)
10. {
11. Locator.services[typeof(T)] = service;
12. }
13. public static void Reset()
14. {
15. Locator.services.Clear();
16. }
17. }
Строки 5-8: Получить сервис
Locator – это класс с только статическими членами, так что вы могли бы также явнтметить его как статический класс. Он содержит все настроенные сервисы во внутреннеловаре, который связывает абстрактные типы с конкретными экземплярами.
Клиенты, такие как ProductService, могут использовать метод GetService, чтобапросить экземпляр абстрактного типа T. Поскольку в этом примере кода не содержитсграждающее условие или обработка ошибок, данный метод сгенерирует довольнуманное KeyNotFoundException, если запрашиваемый тип не имеет записи в словаре, ны можете представить, как добавить код, чтобы выбросить более осмысленносключение.
Метод GetService может возвращать только экземпляр запрошенного типа, если он ранеыл вставлен во внутренний словарь. Это можно сделать с помощью метода Register.
Опять же, этот пример кода не содержит ограждающего условия, так что можно было барегистрировать null, но более надежная реализация не должна этого допустить.
В некоторых случаях (особенно при модульном тестировании), важно иметь возможностбросить Service Locator. Эта функционально сть обеспечивается методом Reset, которычищает внутренний словарь.
Такие классы, как ProductService полагаются на сервис, чтобы быть доступными в
Service Locator, поэтому очень важно, что он был ранее настроен. В модульных тестах этожет быть сделано при помощи тестового дублера (поддельного объекта, Test Double)еализованного динамической mock библиотекой, такой как Moq, как в этом примере:
var stub = new Mock<ProductRepository>().Object;
Locator.Register<ProductRepository>(stub);
Сначала мы создаем заглушку абстрактного класса ProductRepository, а затем омощью статического метода Register настраиваем Service Locator с этим экземпляром.
187
Если это сделано, прежде чем ProductService используется в первый раз,
ProductService будет использовать настроенный Stub, чтобы работать с
ProductRepository. В производственном приложении Service Locator будет настроен равильной реализацией ProductRepository в Composition Root.
Этот способ обнаружения зависимостей из класса ProductService определенно работаетсли наш единственный критерий успеха заключается в том, что зависимость может бытспользована и заменена по желанию, но это имеет некоторые другие серьезныедостатки.
Анализ
Service Locator является опасным паттерном, потому что он почти работает. Мы можебнаружить зависимости из потребляющих классов, и мы можем заменить этависимости различными реализациями – даже поддельными объектами из юнит тестов.
Если мы применим модель анализа, изложенную в главе 1, чтобы оценить, соответствуеи Service Locator преимуществам модульной конструкции приложении, мы увидим, что сновном он соответствует:
? У нас есть поддержка для позднего (от ложенного) связывания при сменегистрации.
? Возможна параллельная разработка, потому что мы программируем, использунтерфейсы, и можем по желанию заменить модули.
? Мы можем достичь хорошего разделения понятий, поэтому нас ничего нстанавливает от написания поддерживаемого кода. Но это все сложнее сделать.
? Мы можем заменить зависимости дублирующими элементами, поэтоместируемость возможна.
Существует только одна область, где Service Locator не дотягивает.
Влияние
Основная проблема с Service Locator заключается в том, что он влияет на повторноспользование классов, которые его потребляют. Это проявляется в двух направлениях:
? Модуль потянет за собой избыточную зависимость.
? Это не очевидно, что используется DI.
Давайте сначала посмотрим на граф зависимостей для ProductService из примера азделе 5.4.1, который показан на рисунке 5-8. В дополнение к ожидаемой ссылке нбстрактный класс ProductRepository, ProductService также зависит от класса Locator.
Рисунок 5-8: Граф зависимости для реализации ProductService, которая использует
Service Locator, чтобы обработать экземпляры абстрактного класса ProductRepository.
188
Это означает, что для повторного использования класса ProductService, мы должнерераспределить не только его релевантную зависимость ProductRepository, а такжависимость Locator, которая существует только по механическим причинам. Если класс
Locator определен в другом модуле, чем ProductService и ProductRepository, новыриложения, которые желают повторно использовать ProductService, должны такжринять и этот модуль.
Чтобы понять, в чем дело, представьте, что новое приложение, повторно использующее
ProductService, уже использует другую DI стратегию, сосредотачиваясь на внедрении онструктор. ProductService не вписывается в эту стратегию, но вместо этого навязываевою собственную стратегию, которая сильно загрязняет DI архитектуру новогриложения. Чтобы это использовать, разработчики должны принять существование
Service Locator, и после того как он введен, он может быть случайно использоваачинающим разработчикам для других целей, где существуют лучшие альтернативы.
Возможно, мы могли даже просто перетерпеть эту дополнительну ю зависимость для
Locator, если бы это было действительно необходимо для работы DI – мы бассматривали это в качестве налога, подлежащего уплате, чтобы получить другиреимущества. Тем не менее, есть лучшие варианты (например, внедрение в конструктор)ак что эта зависимость является избыточной.
Чтобы добавить соли на рану, ни эта избыточная зависимость, ни ее соответствующиубликат, ProductRepository, явно не видны разработчикам, желающим использоватласс ProductService. Рисунок 5-9 показывает, что Visual Studio не может предложитикаких рекомендаций по использованию этого класса.
Рисунок 5-9: Единственная вещь, которую нам может сказать IntelliSense о классе
ProductService, это то, что у него есть конструктор по умолчанию. Его зависимостевидимы.
Когда мы хотим создать новый экземпляр класса ProductService, Visual Studio можеказать нам только, что класс имеет конструктор по умолчанию. Однако если мпоследствии попытаемся запустить код, который мы только что написали, мы получиообщение об ошибке времени выполнения, если мы забыли зарегистрировать экземпляр
ProductRepository при помощи класса Locator. Это может произойти, если мы хороше знаем класс ProductService.
С овет
Представьте себе, что код, который мы пишем, попадает в незадокументированныйуманный .dll. Как легко его может использовать кто-то еще? Это возможно –
разработать API, которые близки к самодокументированию, и хотя для этого требуетсрактика, это достойная цель.
189
Примечание
Проблема с Service Locator заключается в том, что любой клиент, использующий его, ннает о его уровне сложности. Он выглядит простым, но оказывается сложным – и мтого не узнаем, пока не получим исключение времени выполнения.
Проблема с классом ProductService заключается в том, что он далек оамодокументируемости: мы не можем сказать, какая зависимость должнрисутствовать, прежде чем он будет работать. На самом деле, разработчики
ProductService могут даже решить добавить несколько зависимостей в будущие версииоэтому код, который работает в текущем варианте, может не сработать в будущеерсии, и мы даже не получим ошибку компиляции, которая предупредит нас. С Service
Locator легко можно случайно ввести критические изменения.
Внимание
Использование дженериков может ввести вас в заблуждение, что Service Locator строгипизирован. Однако даже API, как в листинге 5-5, слабо типизированный, потому что можем запросить любой тип. Возможность компилировать код при помощи вызова метода
GetService<T> не дает нам никакой гарантии, что он не будет выбрасывать исключениалево и направо во время выполнения.
Примечание
При модульном тестировании у нас есть дополнительная проблема, что тестирующиублер, зарегистрированный в одном тесте, вызовет взаимозависимые тесты
(Interdependent Tests), потому что он останется в памяти, когда будет выполнеледующий тест. Поэтому необходимо использовать методы тестовых фикстур (Fixture
Teardown) после каждого теста, вызывая Locator.Reset(), и мы должны помнить всремя, что это делается вручную, а это легко забыть.
Это все действительно плохо. Service Locator может показаться безобидным, но это можеривести ко всяким неприятным ошибкам выполнения. Как избежать этих проблем?
Рефакторинг по направлению к DI
Когда мы решаем избавиться от Service Locator, мы должны найти способ сделать это. Касегда, главной альтернативой по умолчанию должно быть внедрение в конструктор, если один из других DI паттернов из главы 4 не подходит лучше.
Внимание
Когда мы смотрим на структуру Service Locator, она близка к Ambient Context. Оба неявнспользуют Одиночки (Singletons) но разница заключается в наличие Local Default.
Ambient Context гарантирует, что он всегда может предоставить соответствующикземпляр запрошенного сервиса (как правило, имеется только один). А Service Locator ножет дать такую гарантию, потому что он, в сущности, является слабо типизированныонтейнером сервисов, о которых он не имеет встроенных знаний.
Во многих случаях класс, который потребляет Service Locator, может вызываться по всемоду. В таких случаях он действует в качестве замены для ключевого слова new. Если это
190
так, первый шаг рефакторинга заключается в закреплении создания каждой зависимости дном методе.
Если мы не будем иметь поле для хранения экземпляра зависимостей, мы можем ввестакое поле и убедитесь, что остальная часть кода использует это поле, когда потребляеависимость. Отметьте поле как readonly, чтобы оно не могло быть изменено зределами конструктора. Это заставляет нас присваивать значения полю из конструкторри помощи Service Locator. Теперь мы можем ввести параметр конструктора, которырисваивает значение полю, вместо Service Locator, который затем может быть удален.
Представляя параметр зависимости конструктору, можно нарушить работуществующих потребителей, поэтому мы также должны справиться с этим и переместитродвижение всех зависимостей в Composition Root.
Рефакторинг класса, который использует Service Locator, похож на рефакторинг классаоторый использует Control Freak, потому что Service Locator – это просто окольныариант Control Freak. Раздел 5.1.3 содержит дополнительные заметки о рефакторингеализациий Control Freak к использованию DI.
На первый взгляд, Service Locator может выглядеть как настоящий DI паттерн, но нбманывайте себя: он может решить вопрос слабой связанности, но он создает другироблемы на этом пути. DI паттерны, представленные в главе 4, предлагают лучшильтернативы с меньшим количеством недостатков. Это верно как для анти-паттерна
Service Locator, так и для других анти-паттернов, представленных в этой главе. Даже еслни разные, все они имеют общую черту – решить создаваемые ими проблемы можно омощью одного из DI паттернов из главы 4.
191
5.5. Резюме
Поскольку DI представляет собой набор паттернов и технических приемов, ни одинструмент не может механически проверить, правильно ли мы их применили. В главе 4
мы рассмотрели паттерны, которые описывают, как DI можно использовать должныбразом, но это только одна сторона медали. Важно также понимать, где можно наделатшибок, даже если имеешь лучшие намерения. Есть важные уроки, которые можнзвлечь из неудач, но мы не всегда должны учиться на собственных ошибках, иногда можем учиться на ошибках других людей.
В этой главе я описал наиболее распространенные DI ошибки в виде анти-паттернов. Я
видел все эти ошибки в реальной жизни более чем один раз, и я признаю себя виновныо всем этим пунктам:
? Меня зовут Марк Симан, и я использовал Control Freak.
? Меня зовут Марк Симан, и я использовал Bastard Injection.
? Меня зовут Марк Симан, и я использовал Constrained Construction.
? Меня зовут Марк Симан, и я использовал Service Locator.
К счастью, я давно избавился от этих привычек. Я чист уже много лет.
Первая и самая опасная привычка, от которой стоит избавиться, это мнимаеобходимости иметь прямой контроль над зависимостями. Это легко – обнаружить
Control Freak: каждое место, когда вы используете ключевое слово new (в C #, по крайнеере), чтобы создать экземпляр изменчивой зависимости, вы являетесь Control Freak, и нмеет значения, сколько слоев фабрик вы используете, чтобы скрыть этот факт.
Единственное место, где можно использовать ключевое слово new для зависимостей, это
Composition Root.
Избавиться от Control Freak – это наиболее важная задача на сегодняшний день. Толькогда, когда вам удалось отсеять экземпляры Control Freak, вам стоит обратить вниманиа другие анти-паттерны: они гораздо менее разрушительные.
С овет
Control Freak мешает вам использовать слабую связанность, другие же DI анти-паттернросто делают использование неудобным, поэтому я сразу акцентирую ваше внимание на
Control Freak.
Bastard Injection разрешает DI, но потом портит партию, увлекая за собой избыточныависимости. К счастью, реализацию Bastard Injection легко изменить при помощнедрения в конструктор, поэтому никакой необходимости существовать с Bastard
Injection нет. М ы получаем больше, чем теряем, при переходе к правильному решению: намом деле, мы только теряем время, необходимое для выполнения рефакторинга.
Constrained Construction накладывает искусственные ограничения на типы, которые мспользуем для реализации абстракций. В большинстве случаев это принимает формграничения всех реализациях, чтобы иметь конструктор по умолчанию, но в некоторылучаях конструкторы должны принять определенные параметры для инициализациомпонента.
192
Вы должны снять эти ограничения и использовать DI контейнер или вручную внедрить бъекты необходимые зависимости, где бы они не были. Если у вас есть сценарий, гдеобходимо инициализиро вать некоторые компоненты при помощи информации екущем контексте, нужно применять внедрение в метод.
Service Locator может выглядеть привлекательно, но я считаю его анти-паттерном, хотто несколько спорное мнение. Несмотря на то, что он решает некоторые проблемы DI, оводит другие проблемы, которые перевешивают его преимущества. Нет никаких причиринимать его недостатки, поскольку DI паттерны, представленные в главе 4, предлагаюучшие альтернативы. Это общая тема для всех анти-паттернов, описанных в этой главе:
DI паттерны из главы 4 предлагают решения проблем, вызванных анти-паттернами.
Сейчас уже вы должны знать, чего следует избегать и что вы в идеале должны делатместо этого, но все же есть проблемы, которые выглядят так, как будто их труднешить. В следующей главе обсуждаются такие проблемы и их решения.
193
6. DI рефакторинг
Меню
? Преобразование динамических значений в абстракции
? Работа с недолговечными зависимостями
? Разрешение циклических зависимостей
? Работа с Constructor Over-injection
? Мониторинг связывания
Вы могли заметить, что мне нравится sauce bearnaise или sauce hollandaise в целом. Одноз причин является то, что они очень хороши на вкус, а другая заключается в том, что иовольно сложно сделать. В дополнение к проблеме приготовления sauce hollandaise даеам еще одно испытание: он должен быть подан немедленно (или мне так кажется).
Раньше это было далеко от идеала, когда у меня были гости. Вместо того, чтобриветствовать своих гостей и заставить их чувствовать себя желанными асслабленными, я отчаянно взбивал соус на кухне, оставив их развлекать самих себя.
После нескольких повторных выступлений, моя очень общительная жена решила взятело в свои руки. Мы живем через дорогу от ресторана, так что в один прекрасный денна разговорила поваров, чтобы выяснить секрет, который позволил бы мне приготовитодлинный голландский соус заблаговременно. Оказывается, что такой секрет есть, тато теперь я могу сделать вкусный соус для моих гостей, не подвергая их в атмосфертресса и безумия.
Каждый имеет свои хитрости. Это также верно для разработки программного обеспечени целом и, в частности, DI. Есть проблемы, которые просто продолжают появляться, и вногих случаях существуют хорошо известные способы борьбы с ними.
На протяжении многих лет я видел, как люди прилагают все усилия для изучения DI, не пришло в голову, что многие из вопросов похожи по своей структуре. В этой главы рассмотрим наиболее распространенные проблемы, которые появляются, когда мрименяем DI к коду, и как мы можем решить их. Когда мы закончим, вы должны быть остоянии лучше распознавать и решать такие проблемы, когда они появляются.
Как и две предыдущие главы этой части книги, эта глава организована в виде каталога –
на этот раз проблем и решений (или, если угодно, рефакторинга). Рисунок 6-1 показываетруктуру главы.
Рисунок 6-1: Структура этой главы представляет собой каталог способов рефакторинга ешений обычных DI проблем. Каждый раздел является независимым.
194
В каждом разделе я представлю общую проблему и ее решение, в том числе на примере.
Вы можете прочитать каждый раздел самостоятельно или в последовательно сти, как вадобнее. Цель каждого раздела заключается в ознакомлении с решением частстречающихся проблем, в том, что вы будете лучше оснащены для борьбы с ними, еслы с ними столкнетесь.
6.1. Преобразование динамических значений в абстракции
6.2. Работа с недолговечными зависимостями
6.3. Разрешение циклических зависимостей
6.4. Обсуждение феномена Constructor Over-injection
6.5. Мониторинг связывания
6.6. Резюме
195
6.1. Преобразование динамическиначений в абстракции
Когда вы начинаете применять DI, одна из первых трудностей, с которой вы, вероятнотолкнетесь, заключается в том, что абстракции зависят от значений времени выполнения.
Например, сайт с онлайн картой может предложить рассчитать маршрут между двумочками. Это может дать вам выбор по расчету маршрута: вы хотите кратчайший путь?
Самый быстрый маршрут на основе имеющихся видов транспорта? Самый живописныаршрут?
Каждый вариант представляет собой отдельный алгоритм, и приложение можебрабатывать каждый алгоритм как абстракцию, поэтому оно обрабатывает алгоритмдинаково. Для расчета маршрута приложению нужен алгоритм маршрута, и это нажно, какой именно. Мы должны сказать ему, какой алгоритм он должен использоватьо мы этого не узнаем до времени выполнения, потому что он основан на выборользователя.
В этом разделе рассказывается, как мы можем решить такого рода проблему. Прежде чеерейти к примеру, мы кратко поговорим об общей проблеме. Когда мы закончим, вашеефлекторной реакцией на этот вызов должен быть ввод абстрактной фабрики.
Абстракции с зависимостями времени выполнения
Когда мы используем внедрение в конструктор, мы неявно утверждаем – мы ожидаем, чтависимость должна быть однозначной во время выполнения. Рассмотрим сигнатуронструктора, как эта:
Рисунок 6-1a:
Это никогда не будет работать, если во время выполнения неясно, какая реализация
DiscountRepository должна быть использована. Во время разработки мы можеассматривать зависимость как абстракцию и следовать Принципу подстановки Барбары
Лисков (Liskov Substitution Principle), но во время выполнения решение о том, какой
DiscountRepository использовать, должно быть принято до того, как будет создан
RepositoryBasketDiscountPolicy. Поскольку зависимость запрашивается череонструктор, мы не можем принять решения после этого момента.
Это лишь означает, что как только класс RepositoryBasketDiscountPolicy идет в работуе может быть никакой двусмысленности относительно DiscountRepository. Прочиотребители также могут запрашивать экземпляр ы DiscountRepository, и будут ли онсе получать одинаковые или разные экземпляры, имеет меньшее значение. Такиависимости часто представляют сервисы, а не доменные объекты. Концептуально, естолько один экземпляр данного сервиса.
196
Примечание
Как вы увидите в главе 9, может быть несколько реализаций одной и той же абстракции аботе в одно и то же время. Однако, с точки зрения потребителя, есть только одна.
Сервисы принадлежат к общей группе зависимостей, но иногда зависимость представляеадлежащий доменный объект. Это особенно верно, когда речь идет о меняющиоведение абстракциях, такие как Стратегии (Strategies). Предыдущий алгоритм расчетаршрута является одним из таких примеров. Другим может быть коллекция графическиедакторов для растровых эффектов: каждый эффект выполняет преобразованиастрового изображения, но все они могут быть раскрыты в приложении как абстракции –
это также архитектура, позволяющая поддерживать надстройки.
В таких случаях мы не можем запросить зависимость через конструктор, потому что
Composer не будет знать, какую реализацию выбрать. В игре может быть ноль, один илного экземпляров в разное время жизненного цикла приложения. Зависимостеоднозначна во время разработки.
Как всегда, в разработке программного обеспечения, решением является окольный путь:
на этот раз, абстрактная фабрика.
Абстрактная фабрика
Паттерн проектирования абстрактная фабрика (Abstract Factory) решает проблему, когды по желанию должны быть в состоянии запросить экземпляр абстракции. Оредлагает мост между абстракций и конкретными значениями времени выполнения, чтозволяет нам переводить значение времени выполнения в зависимость.
На следующем рисунке показано, как это работает, то есть, вводится новая абстракцияоторая создает экземпляры первоначально требуемой абстракции.
Рисунок: Если мы должны быть в состоянии создать экземпляры IFoo по запросу, наужен способ сделать это. Абстрактная фабрика – это другая абстракция, которую можем использовать для создания таких экземпляров по мере необходимости.
Абстрактная фабрика – сама абстракция, единственной целью которой является созданикземпляров первоначально требуемых абстракции. Если мы должны быть в состояниоздать экземпляры IFoo из конкретных экземпляров Bar, соответствующая абстрактнаабрика может выглядеть следующим образом:
public interface IFooFactory
{
IFoo Create(Bar bar);
}
В ухудшенном варианте абстрактная фабрика может не принимать никаких входныараметров:
197
public interface IFooFactory
{
IFoo Create();
}
В таком случае абстрактная фабрика становится чистой фабрикой, в то время как аспекреобразования исчезает.
Абстрактная фабрика является одним из наиболее полезных паттернов проектирования.
Имейте это в виду, потому что она может быть использована для решения многиопросов, связанных с DI.
С овет
Когда один или несколько параметров, переданных абстрактной фабрике, сами по себвляются абстракциями, эта техника также становится примером внедрения в метод.
Абстрактная фабрика является универсальным решением, когда мы должны создатависимости из значения времени выполнения.
Прое ктные требования
Насколько полезной может быть абстрактная фабрика, настолько осторожно мы должнрименять ее. Зависимости, созданные абстрактной фабрикой, должны концептуальнребовать значению времени выполнения. Переход от значения времени выполнения бстракцию должен иметь смысл на концептуально м уровне. Если вы чувствуете желанивести абстрактную фабрику, чтобы иметь возможность создавать экземпляры конкретноеализации, стоит воспользоваться протекающей абстракцией (Leaky Abstraction).
Протекающие абстракции
Так же, как разработка через тестирование (Test-Driven Development, T DD) обеспечиваеестируемость, безопаснее сначала определить интерфейсы, а затем дальнейшу рограмму для них. Тем не менее, бывают случаи, когда у нас уже есть конкретный тип еперь мы хотим извлечь интерфейс.
Когда мы это делаем, мы должны позаботиться о том, чтобы лежащая в основе реализацие протекала. Один из моментов, когда это может случиться, если мы только извлекаентерфейс из данного конкретного типа, но все параметры и возвращаемые типы по-
прежнему являются конкретными типами, определенными в той же библиотеке.
Если нам нужно извлечь интерфейс, мы должны делать это рекурсивном образомарантируя, что все типы, извлекаемые корневым интерфейсом, сами являютснтерфейсами. Я называю это глубоким извлечением (Deep Extraction), а результат –
глубокими интерфейсами (Deep Interfaces).
В ASP.NET MVC есть некоторые примеры извлечения глубоких интерфейсов. Например HttpContextBase есть свойство Request типа HttpRequestBase, и так далее. Этбстракция была рекурсивно извлечена из System.Web.HttpContext.
Всегда учитывайте, имеет ли данная абстракция смысл для других реализаций, нежелой, которую вы имеете в виду. Если это не так, вы должны пересмотреть вашу структуру.
198
Абстрактные фабрики бывают разных форм и обличий, и не всегда может бытчевидным, что они у вас есть.
Примечание
Любая абстракция, которая создает экземпляры других абстракций, является фабрикобстракций (абстрактной фабрикой). И для этого не нужно иметь имя, котороаканчивается на Factory.
Давайте посмотрим на пару примеров: сначала простой, идиоматический пример, последствии более сложный пример, где абстрактная фабрика скрыта под другименем.
Пример: выбор алгоритма маршрута
Во введении к этому разделу кратко обсуждался сайт с онлайн картой, где пользователожет выбрать различные алгоритмы расчета маршрута. В этом разделе мы рассмотрио, как применить абстрактную фабрику, чтобы удовлетворить этому требованию
В веб-приложениях вы можете только передать примитивные типы от браузера на сервероэтому когда пользователь выбирает алгоритм маршрута из выпадающего списка, волжны представить это как число или строку. Перечисление – это на самом деле простисло, так что на сервере можно представить выбор с помощью RouteType:
public enum RouteType
{
Shortest = 0,
Fastest,
Scenic
}
Однако то, что вам нужно, это экземпляр IRouteAlgorithm, который может рассчитатаршрут для вас. Для перехода от значения времени выполнения RouteType к
IRouteAlgorithm, вы можете определить абстрактную фабрику:
public interface IRouteAlgorithmFactory
{
IRouteAlgorithm CreateAlgorithm(RouteType routeType);
}
Это позволяет реализовать метод GetRoute для RouteController путем внедрения
IRouteAlgorithmFactory и использовать это для перевода значения времени выполнени нужную зависимость: IRouteAlgorithm. Следующий листинг демонстрируезаимодействие.
Листинг 6-1: Использование IRouteAlgorithmFactory
1. public class RouteController
2. {
3. private readonly IRouteAlgorithmFactory factory;
4. public RouteController(IRouteAlgorithmFactory factory)
5. {
6. if (factory == null)
7. {
8. throw new ArgumentNullException("factory");
199
9. }
10. this.factory = factory;
11. }
12. public IRoute GetRoute(RouteSpecification spec,
13. RouteType routeType)
14. {
15. IRouteAlgorithm algorithm =
16. this.factory.CreateAlgorithm(routeType);
17. return algorithm.CalculateRoute(spec);
18. }
19. }
Строки 15-16: Преобразование значения времени выполнения
Строка 17: Использовать преобразованный алгоритм
Ответственность класса RouteController заключается в обработке веб запросов. Метод
GetRoute получает спецификацию пользователя о пунктах отправления и назначения, акже выбранный тип маршрута (через RouteType). Вам нужна абстрактная фабрика длреобразования значения времени выполнения RouteType в экземпляр IRouteAlgorithmоэтому вы запрашиваете экземпляр IRouteAlgorithmFactory, используя стандартнонедрение в конструктор.
В методе GetRoute вы можете использовать factory для преобразования переменноouteType в IRouteAlgorithm. Когда это будет сделано, вы можете использовать это дласчета маршрута и возвращения результата.
Примечание
Для краткости я опустил ограждающее условие в методе GetRoute. Т ем не менеередоставляемый RouteSpecification может быть null, поэтому в более совершенноеализации нужно сделать на это проверку.
Наиболее очевидная реализация IRouteAlgorithmFactory будет включать простоператор switch и возвращать три различные реализации IRouteAlgorithm на основходных данных. Тем не менее, я оставляю это как упражнение для читателя.
Этот пример продемонстрировал переход значения времени выполнения к зависимости спользованием абстрактной фабрикой в чистом виде. Следующий пример показываеолее сложный вариант, в котором с первого взгляда вы можете даже и не понять, чтспользуется абстрактная фабрика.
Пример: использование CurrencyProvider
В большей части главы 4 вы видели, как реализовать конвертацию валюты в контроллере
ASP.NET MVC. Тип Currency является абстрактным классом, воспроизведенным здесьтобы вам не пришлось возвращаться в раздел 4.1.4:
public abstract partial class Currency
{
public abstract string Code { get; }
public abstract decimal GetExchangeRateFor(string currencyCode);
}
200
На первый взгляд, кажется немного странным, обрабатывать такое понятие, как валюта, ачестве абстракции, потому что оно звучит скорее как Объект-значение (Value Object).
Тем не менее, обратите внимание, что метод GetExchangeRateFor позволяет наапросить его для практически неограниченного множества конверсий. Предположимсть 100 курсов обмена, каждый экземпляр Currency будет потреблять больше, чем 2 КБ
памяти. Это вроде бы и не так много, но, возможно, потребуется оптимизация, напримерспользование паттерна проектирования Приспособленец (Flyweight).
Другой вопрос, который сразу возникает при конвертации валюты, касается денег (sic!)
валюты: другими словами, ее актуальности. Такие приложения, как трейдерскорограммное обеспечение для монетарных рынков, требуют того, чтобы курсы валюбновлялись несколько раз в секунду, в то время как международные коммерческиайты, скорее всего, обойдутся несколькими обновлениями для стабильной валюты. Такириложения могут также включать разметку или стратегии округления, добавляотенциальную сложность в реализацию типа Currency. В свете этого, абстрактный класс
Currency кажется вполне разумным.
Когда потребителю, например, ASP.NET MVC контроллеру, необходимо преобразоватены, он затребует Currency как зависимость для выполнения конвертации. В примероммерческого приложения, используемого в этой книге, у класса Money, которыспользуются для представления цен, есть этот метод конверсии:
public Money ConvertTo(Currency currency)
Потребители, такие как контроллер, могут предоставить экземпляр Currency всем ценамтобы конвертировать их, но теперь возникает вопрос, какой экземпляр Currency?
Выбор целевого Currency зависит от значения времени выполнения: выбранноользователем валюты. Это означает, что мы не можем запросить один объект Currencерез внедрение в конструктор, потому что Com poser не сможет узнать, какую валютспользовать.
Как вы видели в разделе 4.1.1, решением является внедрение CurrencyProvider вместдного Currency:
public abstract class CurrencyProvider
{
public abstract Currency GetCurrency(string currencyCode);
}
Рисунок 6-2 показывает, как контроллер обычно извлекает код предпочтительно й валютользователя из профиля и использует внедренный CurrencyProvider для созданиоответствующего экземпляра Currency.
201
Рисунок 6-2: Внедренный CurrencyProvider используется для отображения простогначения времени выполнения (строку кода валюты) в зависимость времени выполнения
(экземпляр Currency).
Хотя он имеет другое имя, CurrencyProvider является абстрактной фабрикой, котораомогает нам преодолеть разрыв между значением времени выполнения и зависимостьремени выполнения. Currency концептуально зависит от кода валюты, поэтому можем быть уверены, что мы не внедрили протекающую абстракцию путем введения
CurrencyProvider.
Еще один пример из главы 4 показывает дегенеративный случай, где нет никакиервоначальных входных параметров. В разделе 4.2.4 вы видели, как у абстрактного
CurrencyProfileService есть метод GetCurrencyCode, который будет возвращатекущий валютный код пользователя:
public abstract string GetCurrencyCode();
Хотя метод GetCurrencyCode возвращает строку, а не абстракцию, вы можетассматривать CurrencyProfileService как вариант абстрактной фабрики.
В HomeController вы объединяете оба варианта, чтобы выяснить предпочтительнуалюту пользователя:
var currencyCode = this.CurrencyProfileService.GetCurrencyCode();
var currency = this.currencyProvider.GetCurrency(currencyCode);
И в CurrencyProfileService, и в currencyProvider внедряются абстрактные фабрикиоторые доступны для любого члена класса HomeController. В разделах 4.1.4 и 4.2.4
показано, как они внедряются.
Всякий раз, когда мы должны подготовить значение времени выполнения, и мы хотиметь возможность варьировать средствами, с помощью которых мы создаем это значениезависимо от потребителя, мы можем внедрить абстрактную фабрику. Как правило, этtateless (не сохраняющий состояние) сервис, поэтому он подходит лучше к тому способуак мы обычно обрабатываем зависимости, и мы можем использовать внедрение онструктор или внедрение в свойство, чтобы предоставить потребителю фабрику.
Существует еще один тип сценариев, при котором абстрактная фабрика такжбеспечивает хорошее решение. Это происходит, если мы должны работать едолговечными зависимостями.
202
6.2. Работа с недолговечнымависимостями
Некоторые зависимости кажутся концептуально недолговечными. Они обычнредставляют соединения с внешними ресурсами, такими как базы данных или веервисы. Такие связи должны быть закрытыми или произойдут утечки ресурсов. В этоазделе мы рассмотрим лучший способ решения таких проблем.
Как и в предыду щем разделе, мы начнем с изучения общего случая, а затем приступим римеру. Когда мы закончим, вы должны понимать две вещи:
? Вы можете моделировать такие взаимодействия при помощи абстрактной фабрикиоторая создает одноразовые экземпляры.
? Вы должны стремиться скрыть этот паттерн за stateless абстракцией.
Прежде чем перейти к примеру, давайте посмотрим, что заставило меня сказать это.
Закрытие соединений через абстракции
Смысл слабой связанности и принцип подстановки Барбары Лисков состоит в том, чтависимость может быть реализована любым количеством способов. Даже тогда, когда вмеете в виду конкретную реализацию, потенциально в будущем на ум может прийтадикально отличная реализация.
Тем не менее, некоторые зависимости представляют доступ к внешним ресурсам, а этиак правило, переходят на вопросы, связанные с использованием ресурсов. Я, конечнооворю о соединениях в различных видах и формах.
Большинство .NET разработчиков знают, что они должны открыть соединение ADO.NET
прямо перед его использованием и закрыть его снова, как только работа будет закончена.
Современные API интерфейсы, как LINQ to SQL или LINQ to Entities, автоматическделают это для нас так, поэтому мы не должны работать с этим напрямую.
Хотя любой программист должен знать о правильно используемом паттерне, касающемся
ADO.NET соединений, гораздо менее известно, что это же самое верно для WCF
клиентов. Они должны быть закрыты, как только мы закончим с определенным наборопераций или сервисов, потому что в противном случае они могут оставить «мертвые»
ресурсы на стороне сервера.
W CF сервисы и состояние
Фундаментальное правило сервисной ориентации заключается в том, что сервисы нолжны сохранять состояние (должны быть stateless). Если мы будем следовать этомравилу, тогда, безусловно, WCF клиент не оставит «живые» ресурсы на стороне сервераак?
Удивительно, но это не может быть не так. Даже если мы построим сервис полностьtateless, WCF может таким не быть. Это зависит от связывания.
203
Один из многих примеров относится к безопасности. Основанная на сообщенияезопасность, как правило, влияет на производительность. Это верно, потому чтсимметричные ключи требуют большого объема вычислений, но это еще более верно для
Federated security, потому что несколько обменов сообщениями участвуют в созданионтекста безопасности. Поведением по умолчанию для WCF является созданиащищенного диалога на основе обмена асимметричными ключами. Сервис и клиенспользуют «рукопожатие» асимметричной безопасности для обмена специальныимметричным ключом, который используется для обеспечения безопасности всеоследующих сообщений, которые являются частью этой сессии.
Однако такое поведение требует, чтобы обе стороны сохранили общий секрет в памяти.
Клиент должен распрощаться с сервисом, когда он закончит сессию, или это будет
«мертвый» симметричный ключ на сервере. Это, в конечном счете, может быть очищеносле тайм-аута, но до тех пор это все занимает память. Чтобы сохранить ресурсы нервере, клиент должен явно закрыть "соединение", когда оно будет завершено.
Хотя это верно не для всех W CF связываний, но таких много, так что мы должнарантировать, что наши клиенты WCF являются «хорошими ребятами».
Как мы можем совместить необходимость закрыть WCF соединение с желанием избежатротекающей абстракции? Этот вопрос может быть рассмотрен на двух уровнях:
? Сокрытие всей логики управления соединениями за абстракцией
? Подражание открытию и закрытию соединений на более детальном уровне
Первый вариант предпочтительнее, но иногда также требуется и второй. Оба вариантогут быть объединены, чтобы получить лучшее от обоих.
С окрытие управления соединениями за абстракцией
DI не является оправданием для написания приложений с утечками памяти, так что молжны иметь возможность явно закрывать соединения как можно скорее. С друготороны, любая зависимость может представлять или не представлять связь «внроцесса», так что у нас была бы протекающая абстракция, если бы мы должны былмоделировать абстракцию, чтобы она включала метод Close.
Некоторые люди прибегают к тому, что разрешают зависимостям быть наследованнымт IDisposable. Тем не менее, метод Dispose – это просто метод Close с другим именемак что такой подход не решит основной проблемы.
К счастью, технологии доступа к базам данных, такие как LINQ to SQL и LINQ to Entitieемонстрируют правильный подход. В обоих случаях мы имеем доступ к данным череонтекст, который содержит соединение. Всякий раз, когда мы общаемся с базой данныхонтекст автоматически открывает и закрывает соединение по мере необходимостиолностью освобождая нас от бремени борьбы с этим.
Наша первая реакция должна заключаться в том, чтобы сделать то же самое. Рисунок 6-3
показывает, как определить абстракцию на уровне, который достаточно «крупнозернист»тобы реализация могла открывать и закрывать соединения по мере необходимости.
204
Рисунок 6-3: Мы можем разработать интерфейс, который достаточно «крупнозернист»тобы каждый метод включал в себя все взаимодействия с внешним ресурсом в одноакете. Consumer вызывает метод для интерфейса IResource. Реализация этого методожет открыть соединение и вызывать несколько методов по отношению ко внешниесурсам до закрытия соединения и возвращения результата потребителю.
Потребитель никогда не знает, что некоторые реализации могут открывать и закрыватоединения от его имени.
Когда это возможно, мы должны стремиться к разработке пользовательской зависимостиак чтобы нам никогда явно не нужно было иметь дело с жизненным циклом зависимоста этом уровне. Есть, однако, случаи, когда мы не можем этого сделать.
Открытие и закрытие зависимостей
Проблема с «крупнозернистыми» API заключается в том, что они не могут бытостаточно гибкими. Иногда нужна просто абстракция, которая позволяет нам явноделировать жизненный цикл зависимости, которая в противном случае приведет течке памяти.
Внимание
Остановка одной утечки приводит к другой. Мы меняем утечки памяти на "дырявые"
абстракции (Leaky Abstractions).
Наиболее распространенный жизненный цикл, который нам нужно смоделироватьоказан на фигуре 6-4.
Рисунок 6-4: Наиболее распространенный жизненный цикл соединения заключается ом, что мы создаем, используем и закрываем его, когда заканчиваем работу с ним. Этизненный цикл, который мы должны смоделировать, если мы должны моделироватакие вещи.
205
В разделе 6-1 было показано, как использовать абстрактную фабрику для созданиависимости по желанию, так что мы должны найти идиому кодирования, котораодходит к закрытию соединения. Как показано на рисунке 6-4, мы можем использовататтерн IDisposable, чтобы работать с зависимостями, использующими соединения.
Внимание
С одноразовыми зависимостями код «пахнет». Используйте их только тогда, когда неругого выбора. Подробнее об этом в разделе 8.2.
Другими словами, мы можем смоделировать почти любое взаимодействие, которооответствует жизненному циклу из рисунка 6-4, при помощи абстрактной фабрикиоторая создает одноразовые зависимости (см. рисунок 6-5).
Рисунок 6-5: Мы можем смоделировать управление соединением и аналогичныизненные циклы, принимая зависимость от абстрактной фабрики, такой как
IFooFactory, показанной здесь. Каждый раз, когда потребителю нужен экземпляр IFooн создается IFooFactory, но потребитель должен помнить, что должен избавиться оего соответствующим образом.
Паттерн, показанный на рисунке 6-5, часто лучше всего реализовать с помощьлючевого слова C# using (или аналогичной конструкции в других языках).
Как покажет следующий пример, имеет смысл объединять оба подхода, которые молько что обсуждали. Доступ к ресурсам моделируется как «крупнозернистая»
абстракция, которая защищает потребителя от непосредственно й работы с управлениеизненным циклом, в то время как реализация использует описанное сочетанибстрактной фабрики и одноразовых зависимостей. Давайте посмотрим, как это работает.
Пример: вызов сервиса управления продуктом
Представьте себе Windows Presentation Foundation (WPF), который обеспечивает богатыользовательский интерфейс для управления каталогом продукции. Такое приложениожет общаться с бэкэндом (сервером) через WCF сервис, который предоставляееобходимые операции по управлению каталогом продукции.
На рисунке 6-6 показано, как реализация сочетает в себе обе техники из предыдущегаздела.
206
Рисунок 6-6: Класс MainWindowViewModel потребляет интерфейс
IProductManagementAgent. Это крупнозернистый интерфейс, который предоставляеоответствующие методы для потребителя. С точки зрения MainWindowViewModel, неикакого управления соединением. Когда приложение запущено, класс
WcfProductManagementAgent обеспечивает реализацию крупнозернистого интерфейса. Оелает это, потребляя абстрактную фабрику IProductChannelFactory, которая создаедноразовые экземпляры. Интерфейс IProductManagementServiceChannel наследуется от
IDisposable, что позволяет WcfProductManagementAgent избавиться от WCF клиентаогда операции были успешно вызваны.
Примечание
Мы вернемся к этому W PF приложению в разделах 6.3.2 и 7.4.2.
Потребитель защищен от управления соединением, которое является частью реализации
WcfProductManagementAgent.
Всякий раз, когда класс MainWindowViewModel хочет вызвать сервисную операцию, оызывает зависимость IProductManagementAgent. Это совершенно нормальнаависимость, внедренная через конструктор. Это, например, показывает, как удалитродукт:
this.agent.DeleteProduct(productId);
В этом случае this.agent является внедренной зависимостью IProductManagementAgent.
Как видите, здесь нет никакого явного управления соединением, но если вы посмотрита реализацию в WcfProductManagementAgent, вы увидите, как абстрактная фабрикспользуется в комбинации с одноразовой зависимостью:
using (var channel = this.factory.CreateChannel())
{
channel.DeleteProduct(productId);
}
У вас нет внедренного WCF клиента, который можно использовать для вызова сервисноперации, потому что вы должны закрыть клиент, как только вы с ним закончите, и это нозможно – повторно использовать WCF каналы. Вместо этого у вас есть внедреннабстрактная фабрика, которую вы используете, чтобы создать новый канал. Посколькперация заключается в using, выход из зоны видимости отключает канал.
207
Зависимость factory является экземпляром интерфейса IProductChannelFactory. Этользовательский интерфейс, созданный по данному случаю:
public interface IProductChannelFactory
{
IProductManagementServiceChannel CreateChannel();
}
Тем не менее, интерфейс IProductManagementServiceChannel является автоматическгенерированным интерфейсом, созданным вместе со всеми другими типами WCF прокси.
Каждый раз, когда мы создаем ссылку на сервис в Visual Studio или используеvcutil.exe, такой интерфейс создается вместе с другими типами. Привлекательно собенностью этого автоматически сгенерированного интерфейса является то, что оеализует IDisposable вместе со всеми сервисными операциями.
WCF понимает этот тип, что делает реализацию IProductChannelFactory тривиальнойоскольку мы можем использовать System.ServiceModel.ChannelFactory<TChannel>
для создания экземпляров.
Как доминирующий принцип, я предпочитаю не сохраняющие состояние рупнозернистые интерфейсы, как IProductManagementAgent, чтобы оградитользователей от деталей реализации. Хотя мы должны рассматривать одноразовыависимости как протекающие абстракции, утечка может содержаться в конкретноеализации; и, делая это, мы получаем тестируемость без ущерба для общей структуры.
Абстрактная фабрика является чрезвычайно полезным шаблоном проектирования. Оомогает решать проблемы с зависимостями времени выполнения и недолговечнымависимостями. Мы также можем включить его в попытку решить проблемы иклическими зависимостями, но это не играет центральную роль в данном контексте.
208
6.3. Разрешение циклическиависимостей
Иногда реализации зависимости оказываются циклическими. Одна реализация требуеще одну зависимость, реализация которой требует первую абстракцию. Такой граависимостей не может быть удовлетворительным.
Важно понимать, что абстракции сами по себе могут быть совершенно нецикличными, онкретная реализация может ввести цикл. На рисунке 6-7 показано, как это можероизойти.
Рисунок 6-7: Циклы в графе зависимостей могут произойти даже тогда, когда абстракцие имеют отношения друг к другу. В этом примере каждая реализация реализуетдельный интерфейс, но также требует зависимость. Поскольку Concretec требует IA, ндинственной реализацией IA является ConcreteA со своей зависимостью для IB и таалее, то есть у нас есть цикл, который не может быть разрешен, как есть.
Пока цикл остается, мы не можем удовлетворить все зависимости, и наши приложения нудут иметь возможность запускаться. Ясно, что надо что-то делать, но что?
В этом разделе мы рассмотрим вопрос о циклических зависимостях, в том числе нримере. Когда мы закончили, ваша первая реакция должна состоять в том, чтобопытаться переделать свои зависимости. Если это невозможно, вы можете разорваторочный круг путем рефакторинга от внедрения в конструктор ко внедрению в свойство.
Это представляет собой ослабление инвариантов класса, так что это нужно делать оченбдуманно.
Разрешение проблем с циклами зависимостей
Всякий раз, когда я сталкиваюсь с циклом зависимости, вот мой первый вопрос: "Где шибся?"
Совет
Цикл зависимостей указывает на «плохо пахнущий» код. Если такое появится, вы должнерьезно пересмотреть структуру и код.
209
Цикл зависимостей должен немедленно вызвать тщательную оценку причин цикла. Онасто основаны либо на неправильных предположениях, либо на серьезных нарушенияравил однонаправленных зависимостей. В слоевом приложении классы должны говорит другими классами только в своем слое или близлежащем нижнем слое.
Если цикл проходит более одного слоя, мы знаем, что что-то в корне неверно. Каоказано на рисунке 6-8, это обозначает, что некоторые ссылки идут не в ту сторону.
Рисунок 6-8: Когда цикл пересекает одну или более границ слоя, по крайней мере, однсылка архитектурно незаконна. В данном случае, ссылка от D до А является незаконной.
Если такая ситуация возникает, решать ее нужно немедленно.
Если у нас есть цикл в пределах одного слоя, то немного непонятно, что происходит. Этаже может быть результатом хорошей идеи, которая просто закончилась неудачноеализацией.
Нам необходимо сломать цикл любым способом. Пока цикл существует, приложение нудет работать.
Любой цикл является плохо пахнущим кодом, поэтому наша первая реакция должнаключаться в том, чтобы переделать вовлеченные части и предотвратить цикл. Таблица
6-1 показывает некоторые общие направления, в которых мы можем двигаться.
Таблица 6-1: Некоторые стратегии разработки, чтобы сломать цикличные зависимости
Стратегия Описание
События
Вы можете часто сломать цикл, изменив одну из абстракций так, чтобы онызывала события вместо явного вызова зависимости, сообщающиависимости, что что-то произошло. События особенно уместны, еслолько одна сторона вызывает void методы для своей зависимости. .NET
события являются применением шаблона проектирования Наблюдатель
(Observer), и вы можете иногда рассматривать вопрос о явной реализации.
Это особенно верно, если вы решите использовать доменные события
(Domain Events), чтобы разорвать порочный круг. Т ут есть потенциабеспечить возможность истинной асинхронной односторонней передачообщений.
Внедрение войство
Если ничего не помогает, мы можем разорвать порочный круг путеефакторинга одного класса от внедрения в конструктор ко внедрению войство. Это самый крайний вариант, потому что он только лечиимптомы.
210
Я не намерен тщательно исследовать первый вариант, потому что существующаитература уже предоставляет подробную информацию.
Совет
Попытайтесь решить проблему циклов с помощью событий. Если это не поможетопробуйте Наблюдатель. И только если у вас все еще не получается разорвать циклспользуйте внедрение в свойство.
Не ошибитесь: цикл зависимостей является плохо пахнущим кодом. Наш первыриоритет заключается в том, чтобы проанализировать код и понять, почему появилсикл. Когда мы поймем, почему, мы должны изменить структуру и код.
Тем не менее, иногда мы не можем изменить дизайн. Даже если мы понимаем причинозникновения цикла, API-«нарушитель» может быть вне нашего контроля.
Прерывание цикла при помощи внедрения в свойство
В некоторых случаях ошибка проектирования находится вне нашего контроля, но нам всще нужно разорвать порочный круг. В таких случаях мы можем сломать цикл, использунедрение в свойство.
Внимание
Вы должны прибегать к решению проблемы с циклами при помощи внедрения в свойстволько в крайнем случае. Оно лечит симптомы, а не лечит болезнь.
Чтобы разорвать порочный круг, мы должны проанализировать его, чтобы выяснить, гды можем сделать разрыв. Поскольку использование внедрения в свойство предлагаеакультативную, а не необходимую зависимость, очень важно тщательно проверить всависимости, чтобы определить, где разрыв принесет наименьший вред.
На рисунке 6-9, B требует экземпляр IC (интерфейс, который реализует C). Мы можеазорвать цикл, изменив зависимость для B от внедрения в конструктор во внедрение войство. Это означает, что мы можем сначала создать B и внедрить его в A, а затепоследствии присвоить С B:
var b = new B();
var a = new A(b);
b.C = new C(new D(a));
Рисунок 6-9: Учитывая цикл, мы должны сначала решить, где его оборвать. В даннолучае мы решили сломать цикл между В и С.
211
Использование внедрения в свойство таким способом добавляет дополнительнуложность в B, потому что теперь он должен быть в состоянии работать тогда, когда егависимость пока не доступна.
С овет
Классы никогда не должны выполнять работу, вовлекая зависимости в своонструкторы, потому что внедренная зависимость может быть еще не полностьнициализирована.
Если мы не хотим ослабить любой оригинальный класс таким образом, мы можем ввестиртуальную прокси (Virtual Proxy), которая оставляет B нетронутым:
var lb = new LazyB();
var a = new A(lb);
lb.B = new B(new C(new D(a)));
LazyB реализует IB, как это делает B. Тем не менее, он принимает свою зависимость IB
через внедрение в свойство вместо внедрения в конструктор, что позволяет нам разорватикл, не нарушая инвариантов любого из оригинальных классов.
Хотя классы с образными именами A-D иллюстрируют структуру решения, болееалистичный пример является более оправданным.
Пример: создание окна
Одна из наиболее распространенных ситуаций, когда мы не можем перестроить наыход из цикла зависимостей, это когда мы имеем дело с внешними API. Одним из такиримеров является WPF.
В WPF мы можем использовать MVVM паттерн, чтобы реализовать разделение понятиутем деления кода на представления и лежащие в основе модели. Модели присваиваютсредставлению через свойство DataContext. Это, по существу, внедрение в свойство ействии.
С овет
Вы можете прочитать больше о создании WPF приложений при помощи MVVM в разделе
7.4.
DataContext служит как зависимость для Window, но модель играет большую роль правлении тем, какие представления и где активируются. Одним из действий, котороодель должна быть в состоянии выполнить, – это сделать всплывающим диалоговокно. И один из способов реализации этого заключается во внедрении абстракции, как эта модель:
public interface IWindow
{
void Close();
IWindow CreateChild(object viewModel);
void Show();
bool? ShowDialog();
}
212
С внедренным IWindow любая модель может создать новые Window и отобразить их в видодальных или немодальных окон. Однако чтобы реализовать этот интерфейс, молжны иметь ссылку на реальный Window, чтобы правильно установить свойство Owner.
В следующем листинге показана реализация метода CreateChild.
Листинг 6-2: Создание дочернего окнublic virtual IWindow CreateChild(object viewModel)
{
var cw = new ContentWindow();
cw.Owner = this.wpfWindow;
cw.DataContext = viewModel;
WindowAdapter.ConfigureBehavior(cw);
return new WindowAdapter(cw);
}
ContentWindow – это WPF окно, которое вы можете использовать, чтобы показать новокно. Важно установить владельца Window, прежде чем показывать его, потому что иначогут произойти странные ошибки, когда фокусированное или модальное окно скрыто зругими окнами. Чтобы предотвратить такие ошибки, вы устанавливаете свойство Owneля текущего Window. Поле wpfWindow является другим экземпляром
System.Windows.Window.
Вы также присваиваете viewModel новому Window DataContext, прежде чем обернуть ег новую реализацию IWindow и вернуть его.
Вопрос в том, что с этой реализацией у вас есть ViewModel, которые требуют IWindowеализация IWindow, которая требует WPF Window, и WPF Window, которые через их
DataContext требуют, чтобы работала ViewModel. Рисунок 6-10 показывает этот цикл.
Рисунок 6-10: Цикл WPF MVVM. В MVVM Window зависит от ViewModel, которая, вою очередь, зависит от экземпляра IWindow. Надлежащей реализацией IWindow является
WindowAdapter, который зависит от WPF Window, чтобы иметь возможность установитладельца каждого Window и избежать ошибок фокусировки.
Мы ничего не можем тут изменить, чтобы выйти из циклической зависимости. Связежду Window и ViewModel зафиксирована, потому что System.Windows.Window являетснешним API (определенным в BCL). Кроме того, WindowAdapter зависит от Windowтобы избежать ошибок фокусировки, так что это отношение дано также и извне.
Единственное отношение, которое можно изменить, это только между ViewModel и его
IWindow. Т ехнически вы можете перепроектировать все это, чтобы использовать событияо это приведет к довольно нелогичному API. Для отображения диалогового окна ваужно было бы вызвать событие и надеяться, что кто-то подпишется, показываодальное окно. Кроме того, вам пришлось бы возвращать результат диалогового окна по
213
ссылке через аргументы исходного события. Вызов события был бы блокирующиызовом. Это было бы технически возможным, но странным, так что мы исключим это.
Кажется, мы не можем переделать наш выход из цикла, так как же мы можем разорватго?
Прерывание цикла
Нам нужно найти отношение, где мы сможем прервать цикл и ввести внедрение войство. В данном случае это легко, потому что отношение между WPF Window и
ViewModel уже использует внедрение в свойство. Это и будет место прерывания.
Самым простым решением будет подключить что-нибудь еще и установить свойство
DataContext для MainWindow в последнюю очередь перед показом. Это возможно, но нсобенно дружелюбно по отношению к DI контейнерам, потому что это потребовало бт нас явно присвоить зависимость, после того как построение было выполнено.
В качестве альтернативы мы можем инкапсулировать отложенное присвоение в адаптетложенной загрузки. Это позволяет соединить все должным образом с DI контейнером.
Примечание
В следующем примере показан этот же проект, который также описан в разделе 7.4.2. Вожете увидеть весь код в примерах для книги.
Давайте посмотрим, как инкапсулировать создание реализации IWindow, котораравильно загружает MainWindowViewModel и присваивает ее экземпляру WPF
MainWindow. Чтобы помочь сделать это, вы вводите эту абстрактную фабрику:
public interface IMainWindowViewModelFactory
{
MainWindowViewModel Create(IWindow window);
}
Класс MainWindowViewModel имеет более чем одну зависимость, но все зависимостироме IWindow, могут быть удовлетворены сразу, так что вам не нужно передавать их ачестве параметра методу Create. Вместо этого вы можете внедрить их в конкретнуеализацию IMainWindowViewModelFactory.
Вы используете IMainWindowViewModelFactory как зависимость в реализации IWindowнаследованной от WindowAdapter, что представлен в листинге 6-2. Это позволяетложить инициализацию реализации IWindow, пока не будет вызван первый метод. Здесы видите, как переписывается метод CreateChild из листинга 6-2:
public override IWindow CreateChild(object viewModel)
{
this.EnsureInitialized();
return base.CreateChild(viewModel);
}
Перед выполнением реальной работы вы должны убедиться, что все зависимостолностью инициализированы. Когда они инициализированы, вы можете безопаснызвать базовую реализацию.
214
Следующий листинг показывает, как реализуется метод EnsureInitialized при помощнедренной IMainWindowViewModelFactory.
Листинг 6-3: Отложенная инициализация зависимостей
1. private void EnsureInitialized()
2. {
3. if (this.initialized)
4. {
5. return;
6. }
7. var vm = this.vmFactory.Create(this);
8. this.WpfWindow.DataContext = vm;
9. this.DeclareKeyBindings(vm);
10. this.initialized = true;
11. }
Строка 7: Создать ViewModel
Строка 8: Внедрить ViewModel в Window
При инициализации MainWindowAdapter вы в первый раз вызываете внедреннубстрактную фабрику для создания желаемой ViewModel. Это возможно на данныомент, потому что экземпляр MainWindowAdapter уже создан, и поскольку он реализует
IWindow, вы можете передать экземпляр методу Create.
Когда у вас есть ViewModel, вы можете присвоить ее DataContext инкапсулированного
WPF Window. С небольшой дальнейшей настройкой Window теперь полностьнициализирован и готов к использованию.
В Composition Root приложения вы можете подключить все это вот так:
IMainWindowViewModelFactory vmFactory =
new MainWindowViewModelFactory(agent);
Window mainWindow = new MainWindow();
IWindow w =
new MainWindowAdapter(mainWindow, vmFactory);
Переменная MainWindow становится свойством WpfWindow в листинге 6-3, а vmFactorоответствует полю с одноименным названием. При вызове методов Show или ShowDialoля результирующего IWindow вызывается метод EnsureInitialize и все зависимостдовлетворены.
Эта комбинация отложенной инициализации и помощи абстрактной фабрики может быторошим дополнительным штрихом, но на первом месте – это наличие внедрения войство, которое позволяет разорвать порочный круг. В данном случае вам «повезло»отому что WPF Window уже использует внедрение в свойство через свое свойство
DataContext.
Всегда имейте в виду, что лучший способ решить проблему цикла – это пересмотреть APIак чтобы цикл исчез. Тем не менее, в тех редких случаях, когда это невозможно илрайне нежелательно, мы должны разорвать цикл при помощи внедрения в свойство, прайней мере, в одном месте. Это позволяет составить остальную часть графа объекттдельно от зависимости, связанной со свойством. Когда остальная часть графа объектолностью заполнена, то можно внедрить соответствующий экземпляр с помощью
215
свойства. В качестве дополнительного шага мы можем инкапсулировать эту логиказначения свойства в классе и использовать абстрактную фабрику, чтобы присвоитначение свойства в самый последний момент.
Внедрение в свойство сигнализирует о том, что зависимость не является обязательнойоэтому это изменение не должно нам даваться легко. Внедрение в конструктор намногредпочтительнее в большинстве случаев, но оно может быть сложным для некоторыюдей. Давайте посмотрим, почему.
216
6.4. Обсуждение феномена Constructor
Over-injection
Если у вас нет специальных требований, внедрение в конструктор должно быть ваширедпочтительным паттерном внедрения. Тем не менее, некоторым людям неудобно, еслисло зависимостей растет. Они не любят конструкторы со слишком большим числоараметров.
В этом разделе мы рассмотрим очевидную проблему растущего числа параметроонструктора и то, почему это хорошо, а не плохо. Как вы увидите, это не значит, что молжны принять длинные списки параметров в конструкторах, поэтому мы такжассмотрим, что мы можем сделать со слишком большим числом аргументоонструктора. В данном разделе есть пример.
Распознание и решение проблемы Constructor Over-injection
Когда список параметров конструктора становится слишком большим, мы называем этвление Constructor Over-injection и считают его плохо пахнущим кодом. Этот плохахнущий код не появляется, но усугубляется в результате использования DI. Хотя нашеачальной реакцией может быть то, что нам не нравится внедрение в конструктор из-за
Constructor Over-injection, мы должны быть благодарны, что общая проблемроектирования открывается нам.
В этом разделе мы сначала найдем время, чтобы оценить, как Constructor Over-injectioемного облегчает нашу жизнь, а затем рассмотрим соответствующие последствия.
C onstructor Over-injection как сигнал
Хотя внедрение в конструктор легко реализовать и использовать, оно доставляееудобство, когда конструкторы начинают выглядеть так:
public MyClass(IUnitOfWorkFactory uowFactory,
CurrencyProvider currencyProvider,
IFooPolicy fooPolicy,
IBarService barService,
ICoffeeMaker coffeeMaker,
IKitchenSink kitchenSink)
Я не могу сказать, что я кого-то обвиняю, если он не любит такой конструктор, но я ниню внедрение в конструктор. Я могу согласиться, что конструктор с шестьараметрами сигнализирует о плохо пахнущем коде, но это свидетельствует о нарушении
Принципа единственной обязанност и, а не о проблемах, связанных с DI.
С овет
Внедрение в конструктор позволяет легко определить нарушения принципа единственнобязанности.
Вместо того чтобы чувствовать неловкость из-за Constructor Over-injection, мы должнринять его как удачный побочный эффект внедрения в конструктор. Это сигнал, который
217
предупреждает нас всякий раз, когда класс берет на себя слишком большутветственность.
Моим личным порогом являются четыре аргумента конструктора. Всякий раз, когда обавляю третий аргумент, я начинаю рассматривать вопрос, могу ли я спроектироватещи по-другому, но я могу жить с четырьмя аргументами для нескольких классов. Ваимит может быть другим, но когда вы его пересекаете, приходит время рефакторинга.
То, как мы проводим рефакторинг определенного класса, который слишком сильно выросависит от конкретных обстоятельств: на месте ли объектная модель, домен, бизнес-
логика и так далее. Разделение Божественного класса (God Class) на более мелкие, болефокусированные классы в соответствии с известными паттернами проектирования – этсегда хороший ход.
Тем не менее, бывают случаи, когда бизнес требования обязывают нас делать многазных вещей в одно и то же время. Это часто случается в пограничной областриложения. Подумайте о крупнозернистой операции веб сервиса, которая запускаеного бизнес событий. Один из способов моделирования таких операций заключается окрытии множества зависимостей за Фасадными сервисами (Facade Services).
Рефакторинг по направлению к Ф асадным сервисам
Есть много способов, как мы можем разработать и осуществить необходимые операцииак чтобы они не нарушали принцип единственной обязанности. В главе 9 мы обсудимак паттерн проектирования Декорат ор (Decorator) может помочь нам со стеком Cross-
Cutting Concerns, вместо внедрения их в потребляющие элементы в виде сервисов. Этожет устранить лишнее число аргументов конструктора.
Тем не менее, в некоторых случаях единая точка входа должна организовать многависимостей. Одним из примеров является операция веб сервиса, которая запускаеложное взаимодействие различных сервисов. Точка входа пакета информации можетолкнуться с той же проблемой.
На рисунке 6-11 показано, как мы можем провести рефакторинг ключевых отношений паправлению к фасадным сервисам.
218
Рисунок 6-11: На самой верхней диаграмме видно, что у потребителя есть пятависимостей, которые являются сильным признаком того, что нарушен принцидинственной обязанности. Тем не менее, если роль потребителя заключается в томтобы организовать эти пять зависимостей, мы не можем какую-либо выбросить. Вместтого мы можем ввести фасадные сервисы, которые организуют части отношений. В
нижней части диаграммы у потребителя есть только две зависимости, а у фасадов две ри зависимости.
Рефакторинг к фасадным сервисам – это просто трюк, чтобы избавиться от слишкоольшого числа зависимостей. Ключом является определение естественных кластерозаимодействия. На рисунке 6-11 показано, что зависимости A–C формируюстественный кластер взаимодействия, и также делают D и Е.
Благотворный сторонний эффект заключается в том, что открытие этих естественныластеров раскрывает ранее неизвестные отношения и доменные понятия. В ходе этогроцесса мы обращаем неявные понятия в явные понятия. Каждый фасад становитсервисом, который фиксирует это взаимодействие на более высоком уровне, динственная обязанность потребителя заключается в том, чтобы организовать этысокоуровневые сервисы.
Примечание
Фасадные сервисы являются абстрактными фасадами, как следует из названия.
Фасадные сервисы связаны с Param eter Objects, но вместо объединения и раскрытиомпонентов, фасадный сервис раскрывает только инкапсулированное поведение, скрываомпоненты.
219
Очевидно, что мы можем повторить этот рефакторинг, если у нас есть такая сложнориложение, что у потребителя появляется слишком много зависимостей в фасадныервисах. Создание фасадов для фасадных сервисов является вполне разумным шагом.
В пограничных сферах нашего приложения (например, пользовательский интерфейс илеб сервис) мы можем работать с набором крупнозернистых абстракций. Рассматриваеализации зависимостей, мы видим, что за крупнозернистыми сервисами стояонкозернистые (детальные) сервисы, которые являются комбинациями еще болеетальных сервисов. Это позволяет нам быстро все рассмотреть на первичном уровнебеспечивая при этом то, что каждая окончательная реализация придерживается принципдинственной обязанности.
Давайте рассмотрим пример.
Пример: рефакторинг приема заказов
Примеру коммерческого приложения, к которому мы обращаемся на время от времениужно иметь возможность получать заказы. Это часто лучше всего делать в отдельнориложении или подсистеме, потому что в этот момент меняется семантика транзакции.
Когда вы работаете с покупательской корзиной, вы можете динамически вычислитдельные цены, курсы валют, а также скидки, но когда клиент делает заказ, все этначения должны быть получены и заморожены так, как они были предоставлены, когдокупатель одобрил заказ. В таблице 6-2 представлен процесс приема заказа.
Таблица 6-2: Когда подсистема заказов получает новый заказ, она должна выполнитазличные операции
Действие Требуемые зависимости
Сохранить заказ OrderRepository
Отправить имейл о заказе покупателю IMessageService
Сообщить системе учета сумму счета IBillingSystem
Выбрать лучшие склады, чтобы подобрать и отправитаказ на основе товаров в заказе и близости к адресоставки
ILocationService,
IInventoryManagement
Запросить выбранные склады подобрать и отправить весаказ или часть его IInventoryManagement
Пять различных зависимостей требуется для того, чтобы просто получить заказ.
Представьте себе, сколько других зависимостей вам нужно будет обработать по другиперациям, связанным с заказами!
Давайте сначала рассмотрим, как это будет выглядеть, если потребляющий класс
OrderService непосредственно импортировал все эти зависимости, а в дальнейшем ввидите, как можно провести рефакторинг функционала с помощью фасадных сервисов.
С лишком много детальных зависимостей
Если вы позволите OrderService непосредственно потреблять все пять зависимостейтруктура будет такой, как показано на рисунке 6-12.
220
Рисунок 6-12: У OrderService есть пять зависимостей, и это сигнализирует о том, чтарушен принцип единственной обязанности.
Если вы используете внедрение в конструктор для класса OrderService, у вас будеонструктор с пятью параметрами. Это слишком много, и указывает на то, что
OrderService имеет слишком много обязанностей. С другой стороны, все этависимости необходимы, поскольку класс OrderService должен реализовать всеобходимые функции, когда он получает новый заказ.
Вы можете решить эту проблему, переделав OrderService.
Рефакторинг по направлению к фасадным сервисам
Первое, что вам нужно сделать, это посмотреть на естественные кластеры взаимодействи целью выявления потенциальных фасадных сервисов. Взаимодействие между
ILocationService и IInventoryManagement должны немедленно привлечь вашнимание, потому что вы используете их, чтобы найти ближайшие склады, которые могуыполнить заказ. Потенциально это может быть более сложный алгоритм, но после тогак вы выбрали склады, вам нужно уведомить их о заказе.
Если вы подумаете об этом чуть больше, то оказывается, что ILocationService являетсеталью реализации уведомления соответствующих складов о заказе. Все взаимодействиожет быть скрыто за интерфейсом IOrderFulfillment, как показано на рисунке 6-13.
Интересно, что выполнение заказов звучит очень похоже на концепцию; есть вероятностьто вы только что обнаружили неявную доменную концепцию и сделали ее явной.
Рисунок 6-13: Взаимодействие между IInventoryManagement и ILocationServicсуществлено в классе LocationOrderFulfillment, который реализует интерфейс
IOrderFulfillment. Потребители интерфейса IOrderFulfillment понятия не имеют, чт реализации есть две зависимости.
221
Реализация по умолчанию IOrderFulfillment потребляет две исходные зависимостиоэтому имеет конструктор с двумя параметрами, а это хорошо. Как дополнительнореимущество, вы инкапсулировали алгоритм для нахождения лучших складов панному заказу в многократно используемый компонент.
Этот рефакторинг объединяет две зависимости в одну, но оставляет вас с четырьмависимостями класса OrderService. Вам нужно искать другие возможности длбъединения зависимостей в фасад.
Следующая вещь, которую вы могли заметить, заключается в том, что все требованиключают уведомления других систем о заказе. Это означает, что вы можете определитбщую абстракцию, которая моделирует уведомления, возможно, что-то вроде этограгмента кода:
public interface INotificationService
{
void OrderAdded(Order order);
}
Совет
Паттерн проектирования Domain Event (доменное событие) может быть хорошельтернативой для данного сценария.
Каждое уведомление внешней системы может быть реализовано с помощью этогнтерфейса. Вы можете даже рассмотреть обертывание OrderRepository в
INotificationService, но вполне вероятно, что классу OrderService будет необходиоступ к другим методам OrderRepository для реализации других функций. Рисунок 6-14
показывает, как вы реализуете другие уведомления при помощи INotificationService.
Рисунок 6-14: Каждое уведомление внешней системы может быть спрятано за
INotificationService: даже новый интерфейс IOrderFulfillment, который вы тольквели.
Вы можете удивиться, чем же это помогает, потому что вы обернули каждую зависимост новый интерфейс. Количество зависимостей не уменьшилось, и это мне поможет?
Да. Поскольку все три уведомления реализуют один интерфейс, вы можете обернуть их в
Компоновщ ик (Composite). Это еще одна реализация INotificationService, которабрабатывает коллекцию экземпляров INotificationService и вызывает метод
OrderAdded для них всех.
222
С концептуальной точки зрения это также имеет смысл, поскольку с высокоуровневогредставления вы не заботитесь о деталях того, как OrderService уведомляет другиистемы. Тем не менее, вас волнует, что он делает. Рисунок 6-15 показывает конечныависимости OrderService.
Рисунок 6-15: Окончательный OrderService с зависимостями после рефакторинга. Вставляете OrderRepository как отдельную зависимость, потому что вам нужны егополнительные методы для реализации других функций OrderService. Все другиведомления скрыты за интерфейсом INotificationService. Во время выполнения вспользуете CompositeNotificationService, который содержит оставшиеся трведомления.
Это уменьшает OrderService до двух зависимостей, что является намного болеазумным числом. Функционально сть не изменилась, что делает это истинныефакторингом. С другой стороны, изменился концептуальный уровень OrderService. В
его обязанности сейчас входит: получить заказ, сохранить его и уведомить другиистемы. Детали того, какие системы извещены и как это реализовано, были вытеснены нолее детальный уровень.
Даже если вы везде последовательно использовали внедрение в конструктор, ни одионструктор класса не должен требовать более двух параметров
(CompositeNotificationService принимает IEnumerable<INotificationService> кадин аргумент).
Constructor Over-injection – это не проблема, связанная с DI в целом или, в частности, недрением в конструктор. Скорее, это сигнал о том, что класс имеет слишком многбязанностей. В этом классе плохо пахнет код, а не внедрение в конструктор; и как всегдаы должны внимательно отнестись к плохо пахнущему коду и улучшить его.
Есть много способов, которыми мы можем провести рефакторинг к паттернам, но одниз вариантов является введение фасадных сервисов, которые моделируют концепции нолее высоком уровне абстракции. Это решает проблему нарушения принципдинственной обязанности и часто в процессе раскрывает ранее неизвестные доменныонятия.
Это один из многих способов, когда DI помогает нам лучше написать код. Поскольклабая связанность является настолько ценной, мы хотим убедиться, что слабосвязанныод остается слабосвязанным. В следующем разделе рассматривается, как это сделать.
223
6.5. Мониторинг связывания
Слабая связанность является ценной, но это удивительно легко – ввести сильную (тесную)
связанность. Все, что нужно, это начинающий разработчик и малейшая неосторожность, удут введены жесткие ссылки. В Visual Studio можно легко добавить новые ссылки нуществующий проект, но часто мы хотим того избежать. Необходимо соблюдатисциплину, чтобы гарантировать, что каждый модуль фокусируется на своей зонтветственности.
В этом разделе мы рассмотрим некоторые техники, которые могут быть полезны, когды хотим убедиться, что слабосвязанный код остается слабосвязанным. Возможно, мотим защитить код от своих ошибок, или, возможно, джуниор разработчикам в командужно немного помощи.
Ничто не сравнится с человеческим взаимодействием, когда речь заходит о передачнаний. Парное программирование является идеальным, но это все же хорошая идеяросматривать то, что написано вручную, при помощи автоматизированнынструментов. В следующих разделах мы рассмотрим, насколько полезным может бытвтоматизированное тестирование, а также изучим специализиро ванный инструментоторый называется NDepend.
Связывание при юнит тестировании
Если у нас есть набор юнит тестов, с которым мы регулярно работаем, мы можем быстробавить несколько модульных тестов, посвященных изучению зависимости, и онровалятся, если будет обнаружена необоснованная зависимость. Используя системипов .NET, мы легко можем написать модульный тест, который пройдет циклом по всесылкам сборки и провалится, если найдет что-то там, чего там быть не должно.
В примере коммерческого приложения уже есть юнит тесты, так что вы легко можетобавить еще один. Следующий листинг показывает модульный тест, который защищаеодуль логики представления (Presentation Logic module) от прямого обращения к модулоступа к данным на основе SQL Server (SQL Server–based Data Access module).
Листинг 6-4: Обеспечение слабой связанности при помощи юнит тестирования
[Fact]
public void SutShouldNotReferenceSqlDataAccess()
{
// Fixture setup
Type sutRepresentative = typeof(HomeController);
var unwanted = "Ploeh.Samples.Commerce.Data.Sql";
// Exercise systear references =
sutRepresentative.Assembly
.GetReferencedAssemblies();
// Verify outcome
Assert.False(
references.Any(a => a.Name == unwanted)tring.Format(
"{0} should not be referenced by SUT"nwanted));
// Teardown
}
224
Этот тест ищет зависимости модуля презентационной логики. Чтобы получить списосылок, вам нужно запросить сборку. Вы можете получить сборку из любого типаодержащегося в этой сборке, так что вы можете выбрать один. Часто лучше всегыбирать тип, который останется в сборке на долгое время, потому что иначе варидется переписывать тест, если выбранный тип будет удален. В данном тесте выбран
HomeController, потому что у сайта всегда будет главная страница.
Кроме того, необходимо определить сборку, на которую не должны ссылаться. Вы можетспользовать ту же технику и выбрать репрезентативный тип из этой сборки, но это будезначать, что вы должны сослаться на эту сборку из модульного теста. Это не так плохоак ссылки на нежелательную сборку из рабочего кода, но это все равно создасскусственную связь между этими двумя библиотеками – можно сказать, они становятся
«уличенными в связи». Хотя безопасность типа желательна, слабая связанность имееозыри в данном случае, поэтому вы определяете нежелательную сборку при помощтроки (но см. следующие обсуждения относительно других возможностей).
Получить сборку, на которую ссылаются, от репрезентативного типа так же просто, кадин раз вызвать метод. Теперь вы можете использовать простой LINQ запрос, чтоббедиться, что ни одна из этих сборок, на которые ссылаются, не имеет нежелательногмени. В утверждении (прим. переводчика: в принципе ААА при юнит тестированиоследнее А – это Assert, в данном случае «утверждение») вы также выводитообщение, которое отображается, если утверждение не выполняется.
С овет
Это утверждение использует простой LINQ запрос, но вы можете заменить его циклоoreach, если вы разрабатываете на .NET 3.0 или более ранних версиях.
С овет
Вы также можете изменить логику на обратную и написать тест, так чтобы тольконкретные ссылки из заранее подготовленного списка были разрешены, а все другисылки считались незаконными.
Тестирование связанности при помощи Red/Green/Refactor
Если вы используете TDD для реализации вашего кода, вы привыкли к так называемомиклу разработки Red/Green/Refactor, где вы сначала пишете неудачный тест, затем ороходит успешно, и, наконец, вы меняете код, чтобы сделать его более легким оддержке.
Оказывается, сделать так, чтобы тест, предотвращающий тесную связанность, нработал, сложнее, чем вы думаете. Даже если целевой проект Visual Studio имеет ссылка нежелательную зависимость, компилятор включит только ссылку, если онспользуется.
Таким образом, чтобы сделать тест, который не сработает, мы должны сначала добавитежелательну ю ссылку, а затем написать фиктивную строку кода (dumm y code), котораспользует тип из нежелательной зависимости. Как только мы увидели, что тест нрошел, мы можем затем изменить процесс на противоположный, чтобы тест прошел.
Очевидно, что это не проблема, если тестируемая библиотека уже нарушает ограниченивязанности.
225
В предыдущем примере юнит тест добавлен к существующему набору юнит тестовредназначенному для модуля логики представления. Рисунок 6-16 иллюстрирует ссылк действии.
Рисунок 6-16: Библиотека PresentationLogicUnitTest – это набор тестов, нацеленныа библиотеку PresentationLogic. Чтобы сделать это, данная библиотека должнодержать ссылку к своей цели, а также общие абстракции, которые определены оменной модели. Поскольку PresentationLogicUnitTest не нацелен на доменнуодель, модуль DomainModel показан серым цветом.
Листинг 6-4 определяет нежелательну ю сборку при помощи простой строки, но было более безопасно для типа определить его при помощи репрезентативного типа. Однакам может потребоваться добавить в юнит тест ссылку к модулю доступа к данным нснове SQL Server (SQL Server–based Data Access module), как показано на рисунке 6-17.
Рисунок 6-17: Если мы хотим безопасности типов, добавив репрезентативный тип ииблиотеки SqlDataAccess в PresentationLogicUnitTest, мы вводим новую зависимост набор юнит тестов по той единственной причине, что мы хотим убедиться, что этикогда не будет случайно добавлено в библиотеку PresentationLogic. Иронично, не таи?
Вы можете подумать, что добавление дополнительной ссылки к проекту модульногестирования – это не так плохо, но это имеет больше недостатков, которые не сразтановятся очевидными.
Косвенные зависимости
Подробное рассмотрение того, почему проект юнит тестов должен ссылаться только нот проект, на который он направлен, выходит за рамки этой книги, но в целом проблема
226
состоит в том, что юнит тесты создают косвенную зависимость между PresentationMode SqlDataAccess. Хотя оба эти проекты могут существовать и быть скомпилировантдельно, проект модульного тестирования связывает их вместе.
Эта косвенная зависимость может быть сломана только тогда, когда будет исключеодульный тест, который изначально ее создал. Тем не менее, юнит тесты написаны длого, чтобы выполняться, так что это далеко от желаемого.
Если мы хотим оставить такие юнит тесты, предотвращающие тесную связанность, амках существующего проекта модульного тестирования, цена добавления жесткосылки на все нежелательные сборки слишком велика. Лучше всего определятежелательные зависимости при помощи строк, как показано в листинге 6-4.
Недостатком является то, что если мы изменим название запрещенной сборки, тестановится бесполезным или, возможно, еще хуже – мы будем думать, что мы защищены на самом деле это будет не так.
Это не проблема, если у нас есть основания полагать, что имена сборок стабильны. Есле это не так, нам нужна другая стратегия.
Связывание при интеграционном тестировании
Существуют веские причины того, почему проекты юнит тестов должны ссылаться толька свои цели. Оставаясь надежными в условиях изменения имен сборок, нам все жногда могут понадобиться безопасные для типов ссылки на все нежелательныависимости. Эти звучит как противоречивое требование, но мы можем решить этоловоломку, введя новый проект по интеграционному тестированию.
Вы можете добавить новый тестовый проект в решение Comm erce (Comm erce solution) обавить все нужные ссылки. Рисунок 6-18 показывает это решение, и хотя он оченохож на рисунок 6-17, разница состоит в том, что для интеграционного теста все ссылкегальны и одинаково действительны.
Рисунок 6-18: Проект CommerceIntegrationTest содержит автоматизированные тестыоторые проверяют, что отношения между модулями являются правильными. В отличит модульных тестов, интеграционные тесты могут содержать столько ссылок, сколькеобходимо, для проведения данного теста.
227
Инте грационные тесты
Интеграционное т ест ирование – это еще один тип автоматизированного тестирования нровне API. Разница между модульным тестом и интеграционным тестом заключается ом, что модульное тестирование имеет дело с модулями (юнитами) в изоляции, в тремя как интеграционные тесты сосредоточены на проверке того, что несколько юнитов
(часто в разных библиотеках) интегрируются друг с другом, как нужно.
Согласно определению, проект по интеграционному тестированию может ссылаться нсе зависимости, которые ему нужны, чтобы делать свою работу, так что это хорошодходит для тестов, соблюдающих архитектурные ограничения.
Набор интеграционных тестов тесно связан с конкретной совокупностью модулей, так чтн менее многоразовый. Он должен содержать только тесты, которые абсолютно могуыть определены как интеграционные тесты, и тесты, которые защищают оежелательно й связанности, принадлежат к этой категории. Листинг 6-5 показываеезопасный для типов тест, эквивалентный тесту из листинга 6-4. Он следует тому жлану, но меняется, когда дело доходит до выявления нежелательно й зависимости.
Листинг 6-5: Обеспечение слабой связанности при помощи интеграционного теста
1. [Fact]
2. public void PresentationModuleShouldNotReferenceSqlDataAccess()
3. {
4. // Fixture setup
5. Type presentationRepresentative =
6. typeof(HomeController);
7. Type sqlRepresentative =
8. typeof(SqlProductRepository);
9. // Exercise system
10. var references =
11. presentationRepresentative.Assembly
12. .GetReferencedAssemblies();
13. // Verify outcome
14. AssemblyName sqlAssemblyName =
15. sqlRepresentative.Assembly.GetName();
16. AssemblyName presentationAssemblyName =
17. presentationRepresentative.Assembly.GetName();
18. Assert.False(references.Any(a =>
19. AssemblyName.ReferenceMatchesDefinition(
20. sqlAssemblyName, a)),
21. string.Format(
22. "{0} should not be referenced by {1}",
23. sqlAssemblyName,
24. presentationAssemblyName));
25. // Teardown
26. }
Строки 10-12: Получить сборки, на которые ссылаются
Строки 14-17: Получить имена сборок
Строки 18-20: Искать нежелательную зависимость
Теперь, когда у вас есть ссылки на все необходимые зависимости, вы можете выбрать тиз каждого модуля, который можно использовать, чтобы представить их сборки. В
отличие от предыдущего примера, это можно определить безопасным для типа способом.
228
Так же как и раньше, вы получите список всех сборок, на которые ссылается библиотека
PresentationLogic. Используя AssemblyName каждой сборки, вы проверяете, чтобсылки не содержали сборку на основе SQL Server. Встроенные статический метод
ReferenceMatchesDefinition сравнивает имена сборок.
Возможно, вы заметили, что тесты в листингах 6-4 и 6-5 аналогичны. Вы могли баписать новые тесты, как тот, что в листинге 6-5, изменив два репрезентативных типа ставив все остальное, как есть.
Следующим логическим шагом было бы выделение общей части теста араметризованный тест (Parameterized Test). Это позволит вам написать простой списоочти декларативных тестов, которые определяют, что разрешено или не разрешено той конкретной совокупности модулей.
Модульные тесты и интеграционные тесты являются отличными вариантами, если вы ужспользуете автоматизированные тесты на API уровня. Если же нет, вы должны начателать это как можно скорее, но есть и другие альтернативы.
Использование NDepend для мониторинга связанности
Если по каким-то непостижимым причинам вы не хотите использовать юнит тесты, вожете использовать инструмент под названием NDepend (http://ndepend.com), которыредупредит вас, если вы или члены вашей команды ввели нежелательную связанность.
NDepend является коммерческим инструментом программного обеспечения, которынализирует проекты или решения и дает много статистики о коде. В качестве примера, оожет генерировать графы зависимостей, которые мало чем отличаются от тех, что видели в этой книге. Если проанализировать коммерческое решение Мэри из главы 2, молучим граф, показанный на рисунке 6-19.
Рисунок 6-19: Граф зависимостей, сгенерированный NDepend, для коммерческогешения Мэри. По умолчанию NDepend включает все зависимости, в том числе модули из
BCL. Размер блоков отображает число строк кода в каждом модуле, а толщина стрелктражает число элементов, используемых по всем ссылкам.
Это кажется сложным, но мы можем скрыть BCL модули, и мы получим рисунок 6-20.
229
Рисунок 6-20: Измененный график NDepend для коммерческого решения Мэри. На эторафе я вручную удалил все BCL модули и сделал блоки и стрелки одного размера.
Выглядит ли рисунок 6-20 знакомыми? Если вы обладаете эйдетической памятью, вожете вспомнить рисунок 2-10, в ином же случае просто вернитесь к нему. Обратитнимание, что они представляют одни и те же структуры и иллюстрируют одни и те жтношения.
NDepend может сделать гораздо больше, чем нарисовать симпатичные графики. Одна иго наиболее мощных возможностей – это Code Query Language (CQL), который позволяеам запрашивать наш код по широкому спектру информации и имеет синтаксисапоминающий синтаксис SQL.
Если бы Мэри написала CQL проверку, прежде чем разрабатывать решение, она была бредупреждена до того, как был нанесен большой ущерб. Вот запрос, который мог бзбавить ее от многих неприятностей:
WARN IF Count > 0 IN SELECT ASSEMBLIES WHERE
IsDirectlyUsing "ASSEMBLY:Ploeh.Samples.Mary.ECommerce.Data.Sql" AND
NameIs "Ploeh.Samples.Mary.ECommerce.Domain"
После выполнения этот CQL запрос выдает предупреждение, если доменный модулапрямую обращается к модулю SQL Server DataAccess. В решении Мэри этот запроействительно выдаст предупреждение.
230
Мы можем написать столько CQL запросов для решения, сколько захотим, и запустить иибо с помощью редактора или автоматизировать процесс с помощью командной строки.
В обоих случаях генерируются XML файлы с результатами анализа, поэтому мы можеаписать свои собственные инструменты автоматизации, которые принимаюоответствующие меры, если мы хотим включить такой шаг в автоматизированныроцесс сборки.
Примечание
Я лишь поверхностно рассмотрел возможности NDepend. Он может делать много другиещей, но я хотел сосредоточиться на его способности следить за связанностью.
NDepend и автоматизированные тесты – это два способа автоматического контроля кодатобы незаконные зависимости случайно не прокрались. Мы можем использовать одили оба из этих вариантов в рамках тестирования сборки (Build Verification Test, BVT)
или непрерывной интеграции (Continuous Integration, CI).
Для больших баз кода, которые поддерживается большими командами, это можеащитить нас от значительных проблем. Хотя мы не можем следить за всем, чтроисходит, и выполняем проверки кода вручную на каждом этапе, автоматизированнынструменты могут предупредить нас, если произойдет что-то странное.
Внимание
Некоторые инструменты могут вам «наврать», так что не стоит слепо верить им, когда оноворят вам, что есть проблемы. Всегда используйте ваш опыт и знания для оценкредупреждений. Откажись от них, если вы не согласны.
Обращайте внимание на каждый случай, и если есть реальная проблема, решайте ее.
Рассмотрите возможность использования автоматизированных инструментов длониторинга связанности в больших базах кода. Это может предотвратить случайнуесную связанность и «порчу» вашего кода, а сами сосредоточьтесь на другие проблемахписанных в этой главе.
231
6.6. Резюме
DI не представляет собой особой сложности, если вы понимаете несколько основныринципов, но как вы поняли, вы почти наверняка столкнетесь с проблемами, которыогут поставить в тупик на некоторое время. В этой главе мы сделали попыткассмотреть некоторые из наиболее распространенных проблем.
Один из самых универсальных и полезных шаблонов проектирования, связанных с DIвляется абстрактная фабрика. Мы можем использовать ее для перевода простыначений времени выполнения, таких как строки или числа, введенных пользователями, кземпляры сложных абстракций. Мы также можем использовать абстрактные фабрики очетании с интерфейсом IDisposable, чтобы имитировать краткосрочные зависимостиакие как соединения с внешними ресурсами.
С овет
Переводите значения времени выполнения в зависимости при помощи абстрактныабрик.
С овет
Имитируйте соединения при помощи абстрактных фабрик, которые создают одноразовыависимости.
Проблема, которая иногда возникает, – это циклы зависимостей. Они, как правилооявляются из-за того, что API-интерфейсы являются слишком строгими. Чем больше API
строится вокруг парадигмы запросов, тем больше шансов получить циклы. Мы можезбежать циклов, соблюдая Принцип Голливуда (Hollywood Principle). Методы с voiигнатурами могут быть преобразованы в события, которые часто могут бытспользованы для прерывания циклов. Если перепроектирование невозможно, мы можеазорвать цикл, изменив одно внедрение в конструктор во внедрение в свойство. Тем ненее, это надо делать аккуратно, потому что это меняет семантику потребителя.
С овет
Ломайте циклы при помощи внедрения в свойство.
Внедрение в конструктор должно быть вашим предпочтительным DI паттерном;
дополнительным преимуществом является то, что всегда становится очевидно, когда варушаете принцип единственной обязанности. Когда один класс имеет слишком многависимостей, это сигнал, что мы должны его перестроить. Возможно, мы можем разбитго на несколько меньших классов, но иногда мы должны сохранить все функциональныозможности в рамках одного класса.
С овет
Решайте проблему Constructor Over-injection путем рефакторинга к фасадным сервисам.
В этих случаях мы можем поднять уровень абстракции, вставив слой фасадных сервисоежду потребителем и зависимостями. Выполнение такого рефакторинга часто приводи положительно му побочному эффекту, что некоторые из этих фасадных сервисов
232
оказываются ранее неизвестными, неявными доменными концепциями. Выявлениеявных концепций и вывод их в явные концепции является усовершенствованиеоменной модели.
В то время как мы выполняем этот мелкий рефакторинг, мы не должны упускать из видбщую картину. Автоматизированные тесты или инструменты могут помочь нам уследита тем, если тесная связанность появляется в части кода.
Если мы напишем много юнит тестов (в частности, если мы используем Test-Driven
Developm ent), тесная связанность быстро проявит себя в сложном и хрупком тестовооде. Или, вероятно, потому что это невозможно – провести модульное тестированиольших частей приложения.
С овет
Пишите автоматизированные тесты для обеспечения слабой связанности.
Если мы не будем писать юнит тесты, тесную связанность можно не заметить, но мвидим многие из ее симптомов: когда код усложняется, его все сложнее и сложнеоддерживать. Хороший и чистый дизайн, к которому мы изначально стремилисьедленно превращается в спагетти-код. Добавление новой функциональной возможностребует от нас того, чтобы мы залезли даже в несвязанные области.
В этой главе описаны решения для часто встречающихся проблем с DI. Вместе с двумредыдущими главами она образует каталог паттернов, анти-паттернов и рефакторинга.
Данный каталог представляет собой часть 2 книги. В части 3 мы повернемся лицом к трезмерениям DI: Композиции объект ов (Object Composition), Управлению жизненныиклом (Lifetime Management) и Перехвату (Interception).
233
DI самостоятельно
В главе 1 "Дегустационное меню" механизма внедрения зависимостей" я предоставираткий обзор трех аспектов механизма внедрения зависимостей: композиция объектовправление жизненным циклом и механизм перехвата. В этой части книги я раскрою эточку зрения в трех отдельных главах. Многие DI-контейнеры обладают чертами, которыапрямую относятся к этим аспектам. Некоторые DI-контейнеры предоставляют чертсех трех аспектов, тогда как остальные поддерживают только некоторые из них.
Тем не менее, поскольку DI-контейнер является необязательным инструментом, я считаюто важнее объяснить основные принципы и приемы, которые контейнеры обычнспользуют для реализации этих характеристик. В части 2 "DI самостоятельно"
исследуется то, как вы можете сделать это самостоятельно, а не с помощью DI-
контейнера. Теоретически вы можете использовать эту информацию для создания своегобственного DI-контейнера (но, пожалуйста, не делайте это – миру не нужен еще один
DI-контейнер), или применять же механизм внедрения зависимостей вообще беспользования контейнера – это то, что мы называем Poor m an's DI. Однако главная целтой части книги – изложить основные алгоритмы композиции объектов, управлениизненным циклом и механизма перехвата без необходимости использованионкретного DI-контейнера. Думаю, если бы я использовал конкретный контейнер, тыло бы трудно отделить основные принципы от деталей конкретного API.
Глава 7 "Построение объектов" объясняет, как компоновать объекты в таких различныреймворках, как ASP.NET MVC, WPF, WCF и т.д. Не все фреймворки в равной степенорошо поддерживают механизм внедрения зависимостей, и даже среди тех, которые егоддерживают, способы, с помощью которых они это выполняют, значительназличаются. Для каждого фреймворка трудно идентифицировать шов, которыазрешает механизм внедрения зависимостей в этом фреймворке. Тем не менее, прбнаружении этого шва вы получаете решение для всех приложений, которые используютот конкретный фреймворк. В главе 7 я выполнил эту задачу для большинствбщеизвестных фреймворков .NET приложений. Рассматривайте эту главу как каталовов для фреймворков.
Даже если выбранный вами конкретный фреймворк не рассматривается здесь, опытался обратиться ко всем возможным видам ограничений фреймворков, с которымы можете столкнуться. Например, с точки зрения механизма внедрения зависимостей,
PowerShell – это самый ограниченный тип фреймворка, о котором я только мог подуматьоэтому я использовал его в качестве примера. Вы должны уметь экстраполироватешение для схожих фреймворков, даже если они явно не рассматриваются.
Несмотря на то, что компоновка объектов не усложняется благодаря Poor man's DI, волжны начать понимать преимущества настоящего DI-контейнера после того, карочтете о таком аспекте, как управление жизненным циклом. Существует возможностадлежащим образом управлять жизненным циклом различных объектов с помощьиаграммы объектов, но для этого нужно больше пользовательского кода, нежели дломпозиции объектов, и ни один из этих кодов не добавляет в приложение никакогонкретного бизнес-значения.
Кроме объяснения основных принципов управления жизненным циклом, глава
"Жизненный цикл объектов" также содержит каталог универсальных стилеуществования. Этот каталог выступает в роли словаря для обсуждения стилей
234
существования на протяжении всей части "DI-контейнеры", поэтому, несмотря на то, чтам не нужно уметь реализовывать любой из этих стилей вручную, хорошо бы знать, кани работают.
В главе "Механизм перехвата" мы рассматриваем часто встречающуюся проблемеализации сквозных сущностей на основе компонентов. Переходя окончательно оростого приложения паттерна проектирования Decorator к механизму перехвата абочей среде, мы рассматриваем способы формирования слабо связанных приложений одульном исполнении. Я считаю эту главу кульминацион ной точкой книги – это тесто, в котором многие читатели во время начальной программы по управлениоступом высказали мнение, что они начали понимать очертания чрезвычайно мощногпособа моделирования программного обеспечения.
Несмотря на то, что я использую Poor man's DI для исследования и объяснения механизмнедрения зависимостей, я не рекомендую использовать его для профессиональногспользования. Многие отличные DI-контейнеры доступны на .NET и все они являютсесплатными. Таким образом, часть "DI-контейнеры" посвящена подробномассмотрению API конкретного контейнера.
7. Построение объектов
8. Жизненный цикл объектов
9. Механизм перехвата
235
7. Построение объектов
Меню:
? Консольные приложения
? ASP.NET MVC
? Windows Communication Foundation
? Windows Presentation Foundation
? ASP.NET (Web Forms)
? PowerShell
Приготовление изысканных блюд из нескольких слоев – смелое начинание, особенносли вы хотите поучаствовать в поедании этих блюд. Вы не можете хорошо кушать отовить в одно и то же время, кроме того, многие блюда, чтобы они хорошо получилисьеобходимо готовить в последнюю минуту.
Профессиональные кулинары знают, как решить большинство из этих задач. Средногих хитростей они используют в качестве основного принцип "mise en place", которыожно приблизительно перевести как "все готово": все, что может быть приготовленорошо заранее готовится заранее. Чистятся и нарезаются овощи, нарезается мясоодготавливается инвентарь, разогревается духовка, раскладываются инструменты и т.д.
Подготавливается настолько много компонентов, насколько это возможно. Еслороженое является частью десерта, то его можно сделать за день до приготовлениесерта. Если первый слой содержит мидии, их можно почистить за несколько часов дтого. Даже такой недолговечный компонент, как беарнский соус можно приготовить зас до приготовления основного блюда. Когда гости готовы приступить к едееобходимы только финальные приготовления: подогреть соус во время жарки мяса и т.д.
Во многих случаях эта финальная композиция блюда не занимает более 5-10 минут.
Рисунок 7-1 иллюстрирует этот процесс.
Рисунок 7-1: Принцип "mise en place" подразумевает приготовление всех компонентолюда заранее для того, чтобы финальная композиция блюда была выполнена настолькыстро и легко, насколько это возможно.
Принцип "mise en place" похож на разработку слабо связанного приложения с помощьеханизма внедрения зависимостей. Мы можем написать все требуемые компонентаранее и компоновать их только тогда, когда мы должны это делать.
Примечание
В разделе "Composition Root" я сравнивал Composition Root с таким понятием Бережливоазработки программного обеспечения (Lean Software Development), как Последнит вет ственный момент . Сравнение Composition Root с принципом "mise en place"
является схожей аналогией, несмотря на то, что при таком сравнении придается большоначение несколько другому аспекту: композиции.
236
Как и все аналогии, мы можем использовать их только до настоящего момента. Разница ом, что в кулинарии этапы подготовки и композиции разделены во времени, тогда как азработке приложений это разделение проявляется в рамках модулей и уровней. Рисунок
7-2 демонстрирует то, как мы компонуем компоненты в Composition Root (часто на уровнользовательского интерфейса).
Рисунок 7-2: Com position Root соединяет все независимые модули приложения. В
противоположность "mise en place" это не происходит настолько поздно, насколько этозможно, но происходит там, где необходима интеграция различных модулей.
Первое, что происходит на этапе выполнения – это композиция объектов. Как толькиаграмма объектов подключена, завершается композиция объектов и составныомпоненты соединяются.
Несмотря на то, что композиция объектов – это фундаментальная основа механизмнедрения зависимостей, она является самой простой для понимания составляющей. Вже знаете, как это делать, поскольку вы все время компонуете объекты при созданибъектов, которые содержат в себе другие объекты. В разделе 3.3. "Паттерны DI-
контейнеров" мы рассмотрели основные принципы того, когда и как компоноватриложения. Следовательно, я не собираюсь использовать следующие 40 страниц длого, чтобы поведать вам о том, как компоновать объекты.
Вместо этого я хочу помочь вам обратиться к тем трудностям, которые могут возникнутьогда вы будете компоновать объекты. Эти трудности возникают не из-за самоомпозиции объектов, а из-за фреймворков приложений, в которых вы хотели бомпоновать ваши объекты. Эти проблемы специфичны для каждого фреймворка и то жамое касается и резолюций. В моем случае эти проблемы принимают вид некоторыамых значимых препятствий для успешного применения механизма внедрениависимостей, поэтому я сконцентрирую свое внимание именно на них. Это делает главенее теоретической и более практической по сравнению с предыдущими главами.
237
Подсказка
Если вы хотите почитать только о применении механизма внедрения зависимостей ыбранном вами фреймворке, то вы можете пропустить этот раздел. Каждый раздевляется автономным.
Легко формировать целостную иерархию зависимостей приложения, когда мы имееолный контроль над жизненным циклом приложения (как мы поступаем с приложениямомандной строки). Тем не менее, большинство фреймворков (ASP.NET, WCF и т.д.) в
.NET включают в себя инверсию управления, которая иногда может усложнять процесрименения механизма внедрения зависимостей. Понимание швов каждого фреймворквляется ключевым моментом для применения механизма внедрения зависимостей онкретному фреймворку. Как иллюстрирует рисунок 7-3, в этой главе мы будеассматривать то, как реализовать Com position Root'ы в некоторых универсальныреймворках стандартной библиотеки классов (BCL).
Рисунок 7-3: Структура этой главы принимает форму каталога различных BCL
фреймворков и швов, которыми они могут обладать для разрешения механизма внедрениависимостей. Каждый раздел написан таким образом, что его можно читать независимт остальных разделов.
Примечание
В связи с пространственными ограничениями я не буду рассматривать приложения
Windows Form s. Тем не менее, когда дело касается композиции объектов, то в этом онхожи с WPF приложениями.
Каждый раздел посвящен одному из этих фреймворков и может быть прочитан более иленее независимо от остальных. Я буду начинать каждый раздел с общего введения рименению механизма внедрения зависимостей в этом конкретном фреймворке, затеоследует обширный пример, который построен на универсальном примере Commerceоторый используется в большей части данной книги.
Начнем мы с самого простого фреймворка, в котором применяется механизм внедрениависимостей, и постепенно перейдем к более сложным фреймворкам. Когда мы дойдем
238
до ASP.NET, нам нужно будет пересечь бездну, за пределами которой мы можерименять механизм внедрения зависимостей, только подвергая риску, по крайней мереесколько наших принципов. Не опровергается тот факт, что такие фреймворки, как
ASP.NET и PowerShell являются попросту враждебными средами для применениеханизма внедрения зависимостей, поэтому мы должны сделать все так хорошоасколько мы это можем. Тем не менее, пока мы не достигнем этой точки, нееобходимости в компромиссе.
Консольное приложение, вероятно, является самым простым типом приложения, отором применяется механизм внедрения зависимостей.
7.1. Построение консольных приложений
7.2. Построение ASP.NET MVC приложений
7.3. Построение WCF приложений
7.4. Построение WPF приложений
7.5. Построение ASP.NET приложений
7.6. Построение PowerShell cmdlets
7.7. Резюме
239
7.1. Построение консольных приложений
Консольное приложение – это самый простой для композиции вид приложения. В
противоположность большинству других фреймворков BCL приложений, консольнориложение, в сущности, не содержит инверсию управления. Когда процесс выполнениоходит до точки входа в приложение (обычно это метод Main), мы берем все в свои руки.
Не существует никаких особенных событий, которые нужно было бы описатьнтерфейсов, которые нужно было бы реализовать, и мы можем использовать оченграниченное количество сервисов.
Метод Main соответствует Composition Root. Первое, что нам нужно сделать в методе
Main, – скомпоновать модули приложения и позволить им соединиться в единое целое.
Это не сложно, но давайте рассмотрим пример.
Пример: актуализация валют
В главе 4 "DI паттерны" мы рассматривали то, как обеспечить возможность конвертациалют в шаблонном приложении Commerce. В разделе "Пример: конвертация валюты орзине" был введен класс Currency, который предоставляет курс обмена одной валюта другие. Поскольку Currency является абстрактным классом, мы могли бы создатножество различных реализаций, но в данном примере мы использовали базу данных.
Целью примера кода из главы "DI паттерны" было продемонстрировать то, каосстановить и реализовать конвертацию валюты, таким образом, мы никогда нассматривали то, как актуализировать обменный курс в базе данных.
Для того чтобы продолжить пример, давайте изучим то, как написать простое консольнориложение, которое позволяет администратору или привилегированному пользователбновлять обменные курсы в базе данных без необходимости прямого взаимодействия азой данных.
Программа UpdateCurrency
Поскольку целью этой программы является актуализация обменных курсов в базе данныхна имеет название UpdateCurrency.exe. Она будет принимать в качестве входных данныри аргумента командной строки:
? Код целевой валюты
? Код исходной валюты
? Обменный курс
Может показаться странным, что мы указываем цель до исходных данных, но такопособ является наиболее подходящим для большинства людей. Это говорит вам о томколько исходной валюты вам понадобится для того, чтобы купить одну единицу целевоалюты; например, обменный курс доллара к евро выражается как 1 евро за 1,44 доллара.
В командной строке это выглядит примерно так:
PS Ploeh:\> .\UpdateCurrency.exe EUR USD "1,44"
Updated: 1 EUR in USD = 1,44.
240
В результате выполнения программы происходит обновление базы данных и записбновленных значений обратно в консоль.
Composition Root
UpdateCurrency использует точку входа по умолчанию для консольного приложения:
метод Main в классе Program. Это Composition Root для приложения, чтродемонстрировано в следующем листинге.
Листинг 7-1: Composition Root консольного приложениublic static void Main(string[] args)
{
var container = new CurrencyContainer();
container.ResolveCurrencyParser()
.Parse(args)
.Execute();
}
Единственной ответственностью метода Main является компоновка всех соответствующиодулей, и затем он передает ответственность за функциональнос ть сформированноиаграмме объектов. В данном примере пользовательский контейнер инкапсулирует тоак компонуются модули. Поскольку он выполняет точно такую же функцию, как и DI-
контейнер, я решил назвать его конт ейнером, несмотря на то, что он являетсользовательским контейнером с жестко подключенными зависимостями. Мы вернемся ему для того, чтобы вкратце рассмотреть, как он реализован.
После размещения контейнера вы можете теперь попросить его разрешить
CurrencyParser, который анализирует входные аргументы и, в итоге, выполняеоотвествующу ю команду.
Подсказка
Composition Root должна делать всего две вещи: настраивать контейнер и разрешать типоторый реализует требуемую функциональность. Как только он это выполнил, он должеойти с дистанции и оставить остальную работу разрешенному экземпляру.
Подсказка
Используйте для ваших рабочих приложений настоящий DI-контейнер вместоморощенного пользовательского контейнера.
В этом примере используется пользовательский контейнер, явно созданный для этогриложения, но необходимо прямо заменить его таким настоящим DI-контейнером, кае, что рассматривались в главе "DI паттерны".
Контейнер
Класс CurrencyContainer – пользовательский контейнер, созданный специально длелей подключения всех зависимостей к программе UpdateCurrency. Следующий листинемонстрирует реализацию.
241
Листинг 7-2: Пользовательский CurrencyContainer
1. public class CurrencyContainer
2. {
3. public CurrencyParser ResolveCurrencyParser()
4. {
5. string connectionString =
6. ConfigurationManager.ConnectionStrings
7. ["CommerceObjectContext"].ConnectionString;
8. CurrencyProvider provider =
9. new SqlCurrencyProvider(connectionString);
10. return new CurrencyParser(provider);
11. }
12. }
13.
Строка 5-7: Получает строку соединения из config
В этом примере диаграмма зависимостей довольно поверхностная. Для класса
CurrencyParser необходим экземпляр абстрактного класса CurrencyProvider, а в
CurrencyContainer вы решаете, что реализацией должен быть SqlCurrencyProviderоторый предоставляет необходимое взаимодействие с базой данных.
Класс CurrencyParser использует механизм внедрения через конструктор, поэтому вередаете в него только что созданный экземпляр SqlCurrencyProvider до того, каернуть его из метода.
Если вдруг вам станет интересно, то ниже я привожу сигнатуру конструктора
CurrencyParser:
public CurrencyParser(CurrencyProvider currencyProvider)
Помните о том, что CurrencyProvider – это абстрактный класс, который реализуется
SqlCurrencyProvider. Несмотря на то, что CurrencyContainer содержит жесткакодированное преобразование CurrencyProvider в SqlCurrencyProvider, остальнаасть кода является слабо связанной, поскольку в ней применяется только абстракция.
Этот пример может показаться простым, но в нем компонуются типы из трех различныровней приложения. Давайте вкратце исследуем то, как эти уровни взаимодействуют анном конкретном примере.
Иерархическо е представление
Composition Root – это место, в котором компоненты всех уровней соединяются вместе.
Точка входа и Composition Root образуют единственный исполняемый код. Всеализация делегирована более низшим уровням, как это иллюстрирует рисунок 7-4.
Рисунок 7-4: Композиция компонентов приложения UpdateCurrency. CurrencyParseнализирует аргументы командной строки и возвращает соответствующий ICommand. Еслргументы были понятны, то он возвращает CurrencyUpdateCommand, который используекземпляр Currency для актуализации обменного курса. Вертикальная линия справоказывает соответствующий уровень приложения. Каждый уровень реализуется тдельной сборке.
242
Диаграмма на рисунке 7-4 может казаться сложной, но она представляет почти всю базода приложения. Большая часть логики приложения состоит из анализа входныргументов и выбора корректной команды на основании этих входных данных. Все этмеет место на уровне Application Services (сервисы приложения), которызаимодействует напрямую с уровнем доменной модели посредством абстрактнылассов CurrencyProvider и Currency.
CurrencyProvider внедряется в CurrencyParser с помощью контейнера и впоследствиспользуется в качестве абстрактной фабрики для создания экземпляра Currency, которыспользуется CurrencyUpdateCommand.
Уровень доступа к данным поставляет SQL Server реализации доменных классов.
Несмотря на то, что никакие другие классы приложения не обращаются напрямую к этилассам, CurrencyContainer преобразует абстракции в конкретные классы.
Использовать механизм внедрения зависимостей в консольном приложении легкооскольку в действительности в нем нет внешней инверсии зависимостей. .NET
Framework просто ускоряет процесс и передает управление методу Main.
В большинстве других BCL фреймворков присутствует более высокая степень инверсиправления, которая подразумевает, что нам нужно уметь определять корректные местасширяемости для того, чтобы подключить требуемую диаграмму объектов. Одним иаких фреймворков является ASP.NET MVC.
243
7.2. Построение ASP.NET MVC
приложений
ASP.NET MVC был создан с выраженным стремлением стать DI-дружественным, менно таким он и является. Он не вынуждает использовать механизм внедрениависимостей, но с легкостью разрешает его, не заставляя нас при этом делатредположения о том, какой вид механизма внедрения зависимостей мы будем применять.
Мы можем использовать Poor's Man DI или такой DI-контейнер, какой только пожелаем.
Расширяемость ASP.NET MVC
Как всегда и происходит с механизмом внедрения зависимостей, ключ к его применениаключается в обнаружении корректных мест расширяемости. В ASP.NET MVC такилючом является интерфейс под названием IControllerFactory. Рисунок 7-5
иллюстрирует то, как он вписывается в фреймворк.
Рисунок 7-5: Когда рабочая среда ASP.NET MVC получает запрос, он просит своабрику контроллеров создать Controller для запрашиваемого URL. Фабриконтроллеров определяет корректный тип контроллера, который используется дланного запроса, создает и возвращает новый экземпляр этого типа. Затем ASP.NET MVC
вызывает соответствующий метод действия для экземпляра Controller. После созданикземпляра контроллера ASP.NET MVC дает фабрике контроллеров освободить ресурсутем вызова ReleaseController.
244
Контроллеры являются центральным понятием в ASP.NET MVC. Они управляюапросами и определяют то, как на них откликаться. Если нам нужно сделать запрос к базанных, проверить и сохранить входные данные, вызвать доменную логику и т.д., то мнициируем такие действия из контроллера.
Контроллер не должен выполнять такие действия сам, а должен делегировать работоответствующим зависимостям. Это именно то место, где в игру вступает механизнедрения зависимостей. Мы хотим уметь снабжать зависимостями данный класс
Controller, в идеале с помощью внедрения через конструктор. Это можно сделать промощи пользовательского IControllerFactory.
IDependencyResolver
После выхода в 2011 году ASP.NET MVC 3 одной из новых реализованных возможностетала "поддержка DI". Оказалось, что эта поддержка сосредоточена вокруг новогнтерфейса с названием IDependencyResolver. Этот интерфейс и тот способ, при помощоторого он используется в фреймворке ASP.NET MVC, являются проблематичными.
На концептуальном уровне предполагалось использовать IDependencyResolver в качестве
Service Locator, и именно так фреймворк его и использует.
На более конкретном уровне интерфейс обладает ограниченной полезностью, поскольку ем отсутствует метод Release. Другими словами, мы не можем правильно управлятизненным циклом диаграмм объектов посредством этого интерфейса. Для некоторых DI-
контейнеров этот факт гарантирует утечку ресурсов.
С учетом его текущего воплощения я считаю, что безопаснее и правильнее будегнорировать IDependencyResolver. Ирония данной ситуации заключается в том, чтстинный механизм внедрения зависимостей поддерживался ASP.NET MVC еще сремен первой его версии через интерфейс IControllerFactory.
С оздание пользовательской фабрики контроллеров
ASP.NET MVC поставляется с DefaultControllerFactory, которая требует, чтоблассы Controller имели конструктор по умолчанию. Именно разумное поведение пмолчанию не вынуждает нас использовать механизм внедрения зависимостей, если мтого не хотим. Тем не менее, конструкторы по умолчанию и механизм внедрения череонструктор являются взаимно исключающими, поэтому нам необходимо изменить этоведение посредством реализации пользовательско й фабрики контроллеров.
Это не так уж сложно. Для этого необходимо реализовать интерфейс
IControllerFactory.
public interface IControllerFactory
{
IController CreateController(RequestContext requestContexttring controllerName);
SessionStateBehavior GetControllerSessionBehavior(
RequestContext requestContext, string controllerName);
void ReleaseController(IController controller);
}
245
Метод CreateController предоставляет RequestContext, который содержит такунформацию, как HttpContext, тогда как controllerName указывает на то, какоонтроллер запрашивается.
Вы можете решить игнорировать RequestContext и использовать только controllerNamля определения того, какой контроллер необходимо вернуть. Вне зависимости от тогото вы делаете, этот метод является местом, в котором вы получаете шанс подключить всеобходимые зависимости и поставить их в контроллер прежде, чем вернуть экземпляр.
Вы увидите пример в разделе "Пример: реализация CommerceControllerFactory".
Если вы создали какие-либо ресурсы, которые должны быть явно уничтожены, то вожете сделать это при вызове метода ReleaseController.
Подсказка
DefaultControllerFactory реализует IControllerFactory и имеет несколькиртуальных методов. Вместо того чтобы реализовывать IControllerFactory с самогачала, часто легче наследовать его от DefaultControllerFactory.
Несмотря на то, что реализация пользовательско й фабрики контроллеров являетсрудной частью, она не будет использоваться, пока мы не скажем о ней ASP.NET MVC.
Регистрация пользовательской фабрики контролле ров
Пользовательские фабрики контроллеров регистрируются как часть последовательностапуска приложения – обычно в файле Global.asax. Они регистрируются при помощызова ControllerBuilder.Current.SetControllerFactory. Ниже приведен фрагмент иаблонного приложения Commerce:
var controllerFactory = new CommerceControllerFactory();
ControllerBuilder.Current.SetControllerFactory(controllerFactory);
Этот пример создает и определяет новый экземпляр пользовательской
CommerceControllerFactory. ASP.NET MVC теперь будет использовать экземпляontrollerFactory в качестве фабрики контроллеров данного приложения.
Если этот код кажется вам слегка знакомым, то это потому, что вы видели нечто похоже разделе "Паттерны DI-контейнеров". Тогда я обещал показать вам, как реализовыватользовательскую фабрику контроллеров, в главе "Построение объектов", и что? Это сть глава "Паттерны DI-контейнеров".
Пример: реализация CommerceControllerFactory
Для шаблонного приложения Commerce нужна пользовательская фабрика контроллеровтобы подсоединить необходимые зависимости к контроллерам. Несмотря на то, чтолноценная диаграмма зависимостей для всех контроллеров значительно глубже, с точкрения самих контроллеров, соединение всех ближайших зависимостей достигает трелементов, что продемонстрировано на рисунке 7-6.
246
Рисунок 7-6: Диаграмма зависимостей для трех контроллеров шаблонного приложения
Com merce. Конкретные реализации каждой из трех зависимостей имеют другиависимости, но они здесь не показаны. BasketController и HomeController имеют однбщую зависимость CurrencyProvider. AccountController унаследован неизмененныт шаблона ASP.NET MVC по умолчанию; поскольку он использует Bastard Injection, ое имеет неразрешенных зависимостей
Несмотря на то, что вы могли бы реализовать IControllerFactory напрямую, прощаследовать его от DefaultControllerFactory и переопределить его метод
GetControllerInstance. Это означает, что DefaultControllerFactory заботится реобразовании имени контроллера в тип контроллера, и все, что вам приходится делать –
это возвращать экземпляры необходимых типов.
Листинг 7-3: Создание контроллеров
1. protected override IController GetControllerInstance(
2. RequestContext requestContext, Type controllerType)
3. {
4. string connectionString =
5. ConfigurationManager.ConnectionStrings
6. ["CommerceObjectContext"].ConnectionString;
7. var productRepository =
8. new SqlProductRepository(connectionString);
9. var basketRepository =
10. new SqlBasketRepository(connectionString);
11. var discountRepository =
12. new SqlDiscountRepository(connectionString);
13. var discountPolicy =
14. new RepositoryBasketDiscountPolicy(
15. discountRepository);
16. var basketService =
17. new BasketService(basketRepository,
18. discountPolicy);
19. var currencyProvider = new CachingCurrencyProvider(
20. new SqlCurrencyProvider(connectionString),
21. TimeSpan.FromHours(1));
22. if (controllerType == typeof(BasketController))
23. {
24. return new BasketController(
25. basketService, currencyProvider);
26. }
27. if (controllerType == typeof(HomeController))
28. {
29. return new HomeController(
30. productRepository, currencyProvider);
31. }
32. return base.GetControllerInstance(
33. requestContext, controllerType);
34. }
247
Строка 1-2: Переопределяет
Строка 4-21: Создает зависимости
Строка 22-31: Возвращает подключенные контроллеры
Строка 32-33: Использует базу для других контроллеров
Этот метод переопределяет DefaultControllerFactory.GetControllerInstance длого, чтобы создать экземпляры необходимых типов контроллера. Если требуемый тип –
это BasketController или HomeController, то вы явно соединяете их с необходимымависимостями и возвращаете их. Оба типа используют внедрение через конструктороэтому вы поставляете зависимости через их конструкторы.
Для упрощения кода я решил соединить все зависимости до проверки controllerType.
Очевидно, это означает, что некоторые созданные зависимости не будут использоватьсяоэтому это не слишком рациональная реализация. Вы можете выполнить рефакторинистинга 7-3 в более подходящую (но слегка более сложную) форму.
Для тех типов, которые не обрабатываются явно, вы по умолчанию обращаетесь азовому поведению, которое заключается в создании необходимого контроллера промощи его конструктора по умолчанию. Обратите внимание на то, что вы нбрабатываете явно AccountController, поэтому вместо этого вы позволяете базовомоведению справляться с AccountController. AccountController является остаткоаблона ASP.NET MVC проекта и использует Bastard Injection, который дает емонструктор по умолчанию.
Примечание
Я считаю Bastard Injection анти-паттерном, но я оставляю AccountController в такоостоянии, поскольку у меня есть множество других корректных примеров механизмнедрения зависимостей для демонстрации. Я сделал это, в конце концов, потому что этаблонный код, но я бы никогда не оставил это в подобном состоянии в рабочем коде.
После регистрации экземпляра CommerceControllerFactory в файле Global.asax он будеорректно создавать все необходимые контроллеры с необходимыми зависимостями.
Подсказка
Подумайте над тем, чтобы не писать пользовательскую фабрику контроллероамостоятельно. Вместо этого используйте универсальную фабрику контроллеровоторая работает совместно с выбранным вами DI-контейнером. Для вдохновениосмотрите MVC Contrib проект или используйте одну из доступных в нем многократнспользуемых реализаций. Некоторые DI-контейнеры также имеют "официальную"
интеграцию с ASP.NET MVC.
Прекрасно, что ASP.NET MVC был сконструирован таким образом, что уже подразумевал
DI, поэтому нам всего лишь нужно знать и использовать единственное местасширяемости для того, чтобы разрешить DI для нашего приложения. В другиреймворках разрешение DI может быть гораздо более сложной задачей. Windows
Communication Foundation (WCF), хотя и является расширяемым, выступает в качествримера такого фреймворка.
248
7.3. Построение WCF приложений
WCF – одна из самых расширяемых составляющих библиотеки стандартных классов
(BCL). Несмотря на то, что начать писать WCF сервисы довольно легко, бесчисленныозможности расширяемости могут усложнить процесс поиска той возможности, котораужна именно вам. Это еще один случай, когда в игру вступает механизм внедрениависимостей.
Примечание
Согласно шутке, WCF – это акроним для Windows Com plication Foundation. В этотверждении есть определенная доля правды.
Вас легко можно было бы склонить к тому, что WCF не поддерживает внедрение череонструктор. Если вы будете реализовывать WCF сервис при помощи механизмнедрения через конструктор и без конструктора по умолчанию, то хостинг WCF сервис рабочей среде будет выдавать ServiceActivationException с сообщением, подобныледующему:
Предоставленный тип сервиса не удалось загрузить в качестве сервиса, поскольку у негтсутствует конструктор по умолчанию (непараметризованный). Для устранения проблемобавьте к типу конструктор по умолчанию или передайте экземпляр типа в хостинг.
Это сообщение строго указывает на необходимость наличия конструктора по умолчанию.
Кажется, что единственный выход – передать уже созданный экземпляр в WCF хостинго это приводит к нескольким проблемам:
? Как мы можем это сделать, если мы размещаем сервис на Internet Information
Services (IIS)?
? Для этого требуется, чтобы сервис запускался в Single InstanceContextModeоторый по разным причинам не желателен.
Отличная новость – сообщение об исключении просто вводит нас в заблуждение.
Существуют другие способы разрешения внедрения через конструктор в рамках WCF.
Расширяемость WCF
WCF обладает множеством возможностей для расширяемости, но когда дело доходит деханизма внедрения зависимостей, нам всего лишь необходимо иметь представление онтерфейсе IInstanceProvider и о поведениях контрактов. Поведение контракт а – этов в WCF, который позволяет нам изменять то, как ведет себя данный контракт (анном случае – сервис).
IInstanceProvider – это интерфейс, который определяет, как создаются экземплярервиса (и высвобождаются). Ниже приведено определение интерфейса во всей его красе:
public interface IInstanceProvider
{
object GetInstance(InstanceContext instanceContext);
object GetInstance(InstanceContext instanceContext, Message message);
void ReleaseInstance(InstanceContext instanceContext, object instance);
}
249
Две перегрузки GetInstance ответственны за создание соответствующего экземплярервиса, а ReleaseInstance при необходимости предоставляет возможность для очистки.
Реализация по умолчанию выполняет поиск конструктора по умолчанию для типервиса, но мы можем заменить ее какой-либо другой реализацией, использующееханизм внедрения зависимостей. Рисунок 7-7 иллюстрирует весь поток при получениазмещенным сервисом сообщения.
Рисунок 7-7: Когда в сервисную операцию поступает сообщение (запрос), WCF
определяет, какой тип CLR реализует сервис. WCF просит ServiceHostFactory создатоответствующий ServiceHost, который может разместить запрашиваемый сервис.
ServiceHost выполняет свою часть работы, применяя поведения и создаваапрашиваемый экземпляр.
Когда мы размещаем WCF сервис в IIS, ServiceHostFactory обязателен, несмотря на тото, если мы явным образом не определим альтернативу, будет использоваться реализацио умолчанию. Если мы размещаем сервис вручную, ServiceHostFactory все еще можеыть полезной, но не является необходимой, потому что мы можем создатоответствующий ServiceHost, напрямую в коде.
Когда ServiceHost применяет поведения, он собирает их, по крайней мере, из треазличных мест перед тем, как их объединить:
? Атрибуты
? Файл .config
? Объекты, хранящиеся в оперативной памяти
Несмотря на то, что мы можем определить поведения в атрибутах, это не оченаманчивая для использования стратегия в тех случаях, когда дело касается механизмнедрения зависимостей, поскольку это означает, что мы компилируем в коде конкретнутратегию создания с конкретными зависимостями. Конечный результат почти такой жеак если бы у нас прямо в сервисе присутствовали жестко закодированные зависимостиолько гораздо более изощрённее.
Конфигурационный файл может казаться максимально гибким, но это не так, потому чтн не позволяет нам обязательно сконфигурировать зависимости, если мы хотим этделать.
Объекты, хранящиеся в оперативной памяти, обеспечивают наилучшую гибкость, потомто мы можем выбрать вариант создания зависимостей напрямую в коде или на основании
250
настроек конфигурации. Если мы используем DI-контейнер, мы получаем обе опциесплатно. Это означает, что мы должны создать пользовательский ServiceHostFactoryоторый создает экземпляры пользовательского ServiceHost, который снова можеоединить нужный сервис со всеми его зависимостями.
Мы можем создать набор универсальных классов, которые делают это на основаниыбранного DI-контейнера, или используют один из уже реализованных, многократнспользуемых ServiceHostFactorys. Также мы можем создать специальный
ServiceHostFactory для конкретного сервиса. Поскольку создание специального
ServiceHostFactory является наилучшей иллюстрацией процесса, в следующем примерспользуется специализированная фабрика.
Пример: подключение сервиса управления продуктами
В качестве примера представьте себе, что вас попросили расширить шаблоннориложение Commerce WCF сервисом, который раскрывает операции, позволяющиругим приложениям управлять данными товара. Это позволяет вам вмонтироватогатого по функциям клиента (вы будете делать это в следующем разделе) или пакетноадание для того, чтобы управлять данными товара.
Знакомство с сервисом управления товарами
Для упрощения примера давайте предположим, что вы хотите раскрыть простые операции
Create, Read, Update и Delete (CRUD). Рисунок 7-8 демонстрирует диаграмму сервисов вязанных контрактов данных.
Рисунок 7-8: IProductManagementService – это WCF сервис, который определяеростые CRUD операции для товаров. Он использует связанные ProductContract и
MoneyContract для раскрытия этих операций. Несмотря на то, что это нродемонстрировано на диаграмме, все три типа помечены обычными WCF атрибутами:
ServiceContract, OperationContract, DataContract и DataMember.
251
Поскольку у вас уже есть существующая доменная модель, вам хотелось бы реализоваттот сервис путем расширения доменной модели, и раскрыть ее операции посредством ее
WCF контракта. Точные детали не важны; достаточно сказать, что вы расширяетбстрактный класс ProductRepository, который вы видели в предыдущих главах.
Подсказка
Несмотря на то, что я не хочу проводить вас здесь по всему доменному коду, вы можетросмотреть детали в коде, загруженном из книги.
Доменная модель представляет товар как Entity Product, а сервисный контракаскрывает его операции в терминах Data Transfer Object (DTO) ProductContract. Длреобразований между этими двумя различными типами вы также вводите интерфейс поазванием IContractMapper.
Итоговый результат заключается в том, что вы завершаете реализацию сервиса двумависимостями, и поскольку они являются обязательными, вам хотелось бы использоватнедрение через конструктор. Ниже приведена сигнатура конструктора сервиса:
public ProductManagementService(ProductRepository repository,
IContractMapper mapper)
До настоящего времени мы счастливо игнорировали слона в комнате: как нам получить
WCF для того, чтобы корректно подключить экземпляр ProductManagementService?
Присоединение ProductManagementService к WCF
Как показано на рисунке 7-7, Com position Root в W CF – это триплет ServiceHostFactory,
ServiceHost и IInstanceProvider. Чтобы подключить к сервису механизм внедрениерез конструктор, мы должны обеспечить пользовательские реализации всех трех этиомпонентов.
Подсказка
Вы можете написать полностью пригодные для повторного использования реализацииоторые заворачивают ваш любимый DI-контейнер в эти три типа и используют их длеализации IInstanceProvider. Многие люди уже делали это, поэтому вы, скорее всегоожете найти готовый набор для выбранного вами DI-контейнера.
Примечание
В данном примере реализуется контейнер, жестко присоединенный при помощи Poor
Man's DI. Я решил инкапсулировать жестко закодированные зависимости ользовательском классе контейнера для того, чтобы дать вам хорошее представление ом, как создать многократно используемое решение на основании конкретного DI-
контейнера.
Entity vs. DTO
Предыду щий параграф подбросил вам немного жаргона, поэтому давайте вкратцассмотрим, что подразумевается под Entity и DTO.
252
Entity – это термин проблемно-ориентированного проектирования (Dom ain-Driven Design)оторый охватывает объект Domain, имеющий долгосрочную идентификацию, которая нтносится к конкретному экземпляру объекта. Это может показаться абстрактным еоретическим, но это означает, что Entity представляет собой объект, который живет зределами произвольных битов памяти. Любой экземпляр .NET объекта имеенутренний адрес (идентификаци ю), но Entity обладает идентификацией, которая обитаео ту сторону жизненного процесса. Мы часто используем базы данных и первичнылючи для идентификации Entities и для того, чтобы убедиться, что мы можем сохранять итать их, даже если хост-компьютер будет перезагружен.
Доменный объект Product – это Entity, поскольку у сущности товара гораздо болеродолжительный жизненный цикл, нежели у единичного процесса, и мы используем ID
товара для его идентификации в ProductRepository.
Data Transfer Object (DTO), с другой стороны, существует только для того, чтобы бытереданным с одного уровня приложения на другой. Несмотря на то, что Entity моженкапсулировать большую часть поведения, DTO – это структура данных без поведения.
При демонстрации доменной модели внешним системам мы часто поступаем так ервисами и DTOs, поскольку мы никогда не можем быть уверены в том, что другаистема сможет использовать нашу типовую систему (она может даже не использовать
.NET). В таких ситуациях нам всегда нужно выполнять преобразования между Entity и
DTOs.
Давайте начнем с пользовательского ServiceHostFactory, который является настоящеочкой входа в WCF сервис. Следующий листинг демонстрирует реализацию.
Листинг 7-4: Пользовательский ServiceHostFactory
1. public class CommerceServiceHostFactory : ServiceHostFactory
2. {
3. private readonly ICommerceServiceContainer container;
4. public CommerceServiceHostFactory()
5. {
6. this.container =
7. new CommerceServiceContainer();
8. }
9. protected override ServiceHost CreateServiceHost(
10. Type serviceType, Uri[] baseAddresses)
11. {
12. if (serviceType == typeof(ProductManagementService))
13. {
14. return new CommerceServiceHost(
15. this.container,
16. serviceType, baseAddresses);
17. }
18. return base.CreateServiceHost(serviceType, baseAddresses);
19. }
20. }
21.
Строка 6-7: Создает экземпляр контейнера
Строка 14-16: Создает пользовательский ServiceHost
253
Пользовательский CommerceServiceHostFactory унаследован от ServiceHostFactory динственной целью – присоединить экземпляры ProductManagementService. Оспользует пользовательский CommerceServiceContainer для выполнения реальноаботы, поэтому создает экземпляр контейнера в его конструкторе. Вы можете легкасширить этот пример для того, чтобы использовать настоящий DI-контейнер, создавая онфигурируя вместо этого экземпляр данного контейнера.
При получении запроса о создании ServiceHost он возвращает новый
CommerceServiceHost с настроенным контейнером, если запрашиваемый тип сервисодходит. CommerceServiceHost ответственен за определение подходящих поведений длсех типов сервисов, на которых он размещается. В данном примере вы хотите добавитсего лишь одно поведение, которое передает желаемый IInstanceProvider в сервисы.
Вы можете завершить всю эту работу в конструкторе, продемонстрированном ниже, азовый класс позаботится обо всем остальном.
Листинг 7-5: Пользовательский ServiceHost
1. public class CommerceServiceHost : ServiceHost
2. {
3. public CommerceServiceHost(ICommerceServiceContainer container,
4. Type serviceType, params Uri[] baseAddresses)
5. : base(serviceType, baseAddresses)
6. {
7. if (container == null)
8. {
9. throw new ArgumentNullException("container");
10. }
11. var contracts = this.ImplementedContracts.Values;
12. foreach (var c in contracts)
13. {
14. var instanceProvider =
15. new CommerceInstanceProvider(
16. container);
17. c.Behaviors.Add(instanceProvider);
18. }
19. }
20. }
Строка 14-16: Создает InstanceProvider
Строка 17: Добавляет InstanceProvider в качестве поведения
Класс CommerceServiceHost наследуется от ServiceHost, который является конкретнылассом, выполняющим всю тяжелую работу. В большинстве случаев вы будетазмещать только один вид сервиса (в данном случае, ProductManagementService), нам разрешено размещать самые разнообразные сервисы; это означает, что вы должнобавить ко всем этим сервисам IInstanceProvider. Свойство ImplementedContracts –
это словарь, поэтому вы можете выполнить цикл по его Values, чтобы пометить их всех.
Для каждого вида сервиса вы инициализируете новый экземпляр пользовательскогласса CommerceInstanceProvider вместе с контейнером. Поскольку он дублируется ачестве поведения, вы можете добавить его в Behaviors сервиса.
Последней составляющей пользовательского WCF триплета является
CommerceInstanceProvider, который дублирует как IInstanceProvider, так и
254
IContractBehavior. Это простая реализация, но поскольку она реализует два различнынтерфейса со сложными сигнатурами, она может выглядеть слегка устрашающей, еслы видите ее впервые. Вместо нее я продемонстрирую код, отнимающий мало времени;
рисунок 7-9 предоставляет краткий обзор.
Рисунок 7-9: CommerceInstanceProvider реализует как IInstanceProvider, так и
IContractBehavior, поэтому вам нужно реализовать семь методов. Вы можете оставитри этих метода пустыми, а остальные четыре являются однострочными.
Листинг 7-6 демонстрирует объявление класса и конструктор. Здесь ничего нроисходит, кроме использования Constructor Injection для внедрения контейнера. Обычны используем механизм внедрения через конструктор, для того, чтобы объявить DI-
контейнеру, что классу нужны некоторые зависимости, но в данном случае это делатоздно, поскольку вы внедряете сам контейнер. Это обычно попахивает большим кодомотому что он чаще всего указывает на намерение использовать анти-паттерн Service
Locator, но здесь это необходимо, поскольку вы реализуете Composition Root.
Листинг 7-6: Объявление класса CommerceInstanceProvider и конструктор
1. public partial class CommerceInstanceProvider :
2. IInstanceProvider, IContractBehavior
3. {
4. private readonly ICommerceServiceContainer container;
5. public CommerceInstanceProvider(
6. ICommerceServiceContainer container)
7. {
8. if (container == null)
9. {
10. throw new ArgumentNullException("container");
11. }
12. this.container = container;
13. }
14. }
Строка 2: Реализует WCF интерфейсы
Строка 4-13: Constructor Injection
CommerceInstanceProvider реализует как IInstanceProvider, так и IContractBehavior.
Вы дополняете контейнер посредством стандартного Constructor Injection. В данноримере вы используете пользовательский CommerceServiceContainer, но замена егниверсальным DI-контейнером – обычная практика.
255
Реализация IInstanceProvider в следующем листинге используется рабочей средой WCF
для создания экземпляров класса ProductManagementService.
Листинг 7-7: Реализация IInstanceProvider
1. public object GetInstance(InstanceContext instanceContext, Messagessage)
2. {
3. return this.GetInstance(instanceContext);
4. }
5. public object GetInstance(InstanceContext instanceContext)
6. {
7. return this.container
8. .ResolveProductManagementService();
9. }
10. public void ReleaseInstance(InstanceContext instanceContext,
11. object instance)
12. {
13. this.container.Release(instance);
14. }
Строка 3: Делегирует полномочия перегрузке
Строка 7-8: Использует контейнер для преобразования
Строка 13: Просит контейнер высвободить экземпляр
Рабочая среда WCF вызывает один из методов GetInstance для того, чтобы получиткземпляр запрашиваемого вида сервиса, поэтому вы просите контейнер присоединить к
ProductManagementService всего его необходимые зависимости.
При завершении операции сервиса рабочая среда WCF просит вас высвободить экземпляр вы снова делегируете эту работу контейнеру.
Остальная часть CommerceInstanceProvider – это реализация IContractBehavior.
Единственная причина для реализации этого интерфейса – позволить вам добавить его писок поведений, как это продемонстрировано в листинге 7-5. Все методы интерфейса
IContractBehavior возвращают void, поэтому вы можете оставить большинство из ниустыми, поскольку вам не нужно их реализовывать.
Следующий листинг демонстрирует реализацию единственного метода, о котором ватоит позаботиться.
Листинг 7-8: Основная реализация IContractBehavioublic void ApplyDispatchBehavior(
ContractDescription contractDescription, ServiceEndpoint endpoint,
DispatchRuntime dispatchRuntime)
{
dispatchRuntime.InstanceProvider = this;
}
В этом методе вам нужно сделать всего лишь одну очень простую вещь. Рабочая среда
WCF вызывает этот метод и передает экземпляр DispatchRuntime, который позволяет ваказать методу о том, что он должен использовать эту конкретную реализацию
IInstanceProvider – помните, что CommerceInstanceProvider также реализует
256
IInstanceProvider. Рабочая среда WCF теперь знает, какой IInstanceProvideспользовать, и может впоследствии вызвать метод GetInstance, продемонстрированны листинге 7-7.
Кажется, чтобы разрешить механизм внедрения зависимостей для WCF необходимеализовать большое количество кода, а я даже не показал вам реализацию
CommerceServiceContainer.
Подсказка
Помните, что вы можете легко написать многократно используемые версии этих трелассов, обвертывающих ваш любимый DI-контейнер и упаковывающих эту реализацию иблиотеку. Это делают многие разработчики, поэтому вы, скорее всего, можете найтодходящую готовую библиотеку в интернете.
Контейнер – это последний фрагмент WCF DI паззла.
Реализация специализирова нно го контейнера
CommerceServiceContainer – это специализиро ванный контейнер с единственной цельрисоединения класса ProductManagementService. Помните, что для этого класса нужнкземпляры ProductRepository и IContractMapper в качестве зависимостей.
Если исключить всю WCF инфраструктуру, то контейнер свободен для того, чтобконцентрироваться на присоединении диаграммы зависимостей.
Примечание
Кроме соблюдения принципа единичной ответственности, такая концепция разделениемонстрирует, что вы можете заменить этот специализированный контейнениверсальным DI-контейнером, поскольку WCF-специфичный код отсутствует.
Метод ResolveProductManagementService связывает экземпляр с Poor Man's DI, чтродемонстрировано ниже.
Листинг 7-9: Преобразование ProductManagementService
1. public IProductManagementService ResolveProductManagementService()
2. {
3. string connectionString =
4. ConfigurationManager.ConnectionStrings
5. ["CommerceObjectContext"].ConnectionString;
6. ProductRepository repository =
7. new SqlProductRepository(connectionString);
8. IContractMapper mapper = new ContractMapper();
9. return new ProductManagementService(repository,
10. mapper);
11. }
Строка 6-7: Создает репозиторий товаров
Строка 8: Создает преобразователь контрактов
257
В некотором смысле, когда дело доходит до преобразования диаграммы зависимостейасто бывает выгодно вернуться назад. Вы знаете, что вам нужно вернуть экземпляр
ProductManagementService с экземпляра ми ProductRepository и IContractMapper.
Экземпляр IContractMapper легко создать, но для того, чтобы создать
ProductRepository нужно потрудиться побольше.
Вам хотелось бы использовать SqlProductRepository, но для этого вам нужна строкоединения, которую вы можете прочитать из файла web.config.
Если вы хотите разместить сервис в вашем собственном приложении, то сейчас вы можетто сделать путем создания нового экземпляра класса CommerceServiceHostFactory ызова его метода CreateServiceHost с корректными параметрами. Метод вернекземпляр CommerceServiceHost, который вы можете открыть, и будет выполнятстальную часть работы за вас, а также размещать ProductManagementService.
Тем не менее, если вы хотите разместить сервис на IIS, то вы должны выполнить еще одиаг.
Хостинг ProductManagementService в IIS
В IIS мы не создаем новые экземпляры CommerceServiceHostFactory вручную. Вместтого мы должны сообщить IIS о том, чтобы он сделал это за нас. Это может быть сделан .svc файле путем добавления атрибута Factory:
<%@ ServiceHost=""
Factory = "Ploeh.Samples.CommerceService.CommerceServiceHostFactory,
?Ploeh.Samples.CommerceService"
Service = "Ploeh.Samples.CommerceService.ProductManagementService"
%>
Данный .svc файл дает IIS указание использовать CommerceServiceHostFactory всякиаз, когда ему нужно создавать экземпляр класса ProductManagementService. То, чтассматриваемый ServiceHostFactory имеет конструктор по умолчанию, являетссловием, но в данном примере это именно так.
Разрешение DI в W CF сложнее, нежели это должно было быть, но, по крайней мере, этозможно, и конечного результата вполне достаточно. Мы можем использовать любоелаемый DI-контейнер, и завершаем работу, приобретая правильный Composition Root.
Некоторые фреймворки не предоставляют нам подходящие швы, которые позволили бам такую роскошь. Тем не менее, до того, как мы рассмотрим один такой известныреймворк, давайте расслабимся и рассмотрим более простой фреймворк.
258
7.4. Построение WPF приложений
Если вы думали, что создавать WCF сервис было сложно (как думал и я), то вы оценитето создавать Windows Presentation Foundation (WPF) приложение почти настолько жросто, как и консольное приложение.
Точка входа в W PF приложение является довольно очевидной и не сложной, и, несмотра то, что она не предоставляет швов, которые явно предназначены для разрешения DIы можем с легкостью сформировать приложение любым предпочитаемым нампособом.
WPF композиция
Точка входа в W PF приложение определяется в его классе App. Как и большинство другилассов WPF, этот класс разбит на два файла: App.xam l и App.xaml.cs. Мы можепределить, что происходит на стадии начальной загрузки в обоих файлах в зависимостт наших потребностей.
При создании нового WPF проекта в Visual Studio файл App.xam l определяет атрибут
StartupUri, который устанавливает, какое окно демонстрируется при запускриложения – в данном примере Window1:
<Application x:Class="MyWpfApplication.App"
xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
StartupUri="Window1.xaml">
</Application>
Смысл данного стиля объявления заключается в том, что объект Window1 создается емонстрируется без какого-либо дополнительного контекста. Когда вы хотите добавитависимости к окну, наиболее подходящим может стать более явный подход. Вы можетдалить атрибут StartupUri и присоединить окно с помощью переопределения метода
OnStartup. Это позволяет вам полностью присоединить первое окно до того, как онудет продемонстрировано, но вам придется за это заплатить: вы должны не забыть явнызвать метод Show для окна.
Метод OnStartup, таким образом, становится Composition Root приложения. Вы можетспользовать DI-контейнер или Poor Man's DI для создания окна. В следующем примерспользуется Poor Man's DI для того, чтобы проиллюстрировать, что вам не приходитсолагаться на возможности какого-либо конкретного DI-контейнера.
Пример: присоединение ценного клиента управления товарами
В предыдущем примере разрабатывался веб-сервис, который мы можем использовать длправления каталогом товаров в шаблонном приложении Commerce. В данном примеры создадим WPF приложение, которое использует этот веб-сервис для управлениоварами. Рисунок 7-10 демонстрирует скриншот этого приложения.
259
Рисунок 7-10: Главное окно приложения Product Management – это список товаров. Вожете добавлять новые товары, редактировать существующие или удалять их. Пробавлении или редактировании товаров используется модальное окно редактирования.
Все операции реализуются посредством вызова соответствующей операции для веб-
сервиса управления товарами из раздела 7.3.2.
Приложение реализует Model View ViewModel (MVVM) подход и содержит три уровняоторые продемонстрированы на рисунке 7-11. Обычно мы держим ту составляющую, оторой находится большая часть логики, изолированно от других модулей – в данноримере PresentationLogic.ProductManagementClient – это humble-исполнитель
(humble executable), который выполняет несколько большую работу, нежели простпределяет пользовательский интерфейс и делегирует реализацию другим модулям.
260
Рисунок 7-11: Приложение состоит из трех отдельных блоков. Блок
ProductManagementClient – исполняемый, и включает в себя пользовательскинтерфейс, реализованный в XAML без выделенного кода (code-behind). Библиотека
PresentationLogic содержит ViewModels и опорные классы, а библиотека
ProductWcfAgent включает в себя Adapter между пользовательско й абстракцией
IProductManagementAgent и конкретным WCF прокси, который используется длзаимодействия с веб-сервисом управления товарами. Стрелки-указатели зависимостезначают, что ProductManagementClient выступает в роли Composition Root, посколькн соединяет вместе остальные модули.
Благодаря подходу MVVM мы передаем ViewModel в свойство DataContext главногкна, а механизм связывания данных и движок шаблонизации данных заботятся орректном представлении данных, как только мы вплетаем новые ViewModels илзменяем данные существующих ViewModels.
MVVM
Model View ViewModel (MVVM) – это паттерн проектирования, для которого отличнодходит WPF. Он разделяет код пользовательского интерфейса на три отдельнытветственности.
Model – это основополагающая модель приложения. Ею часто, но не всегда, являетсоменная модель. Она часто состоит из POCO-объектов. В текущем примере доменнаодель реализуется в веб-сервисе, поэтому на данном уровне у вас нет истиннооменной модели. Тем не менее, приложение функционирует с абстракциямиаходящимися поверх прокси веб-сервиса, и это и есть ваша Model. Обратите внимание но, что Model обычно выражается UI-нейтральным способом. Это не предполагает, что
Model будет раскрыта напрямую пользовательским интерфейсом, поэтому она наскрывает никакой WPF-специфичной функциональности.
View – это рассматриваемый нами пользовательский интерфейс. В WPF мы можефициально выразить View в XAML и использовать механизм связывания данных вижок шаблонизации данных для представления данных. Можно выразить Views беспользования выделенного кода.
261
ViewModel – мост между View и Model. Каждый ViewModel – это класс, которыреобразовывает и раскрывает Model конкретным специфическим способом. В WPF этзначает, что ViewModel может раскрывать списки как ObservableCollections, и томодобное.
Внедрение зависимостей в главный ViewModel
MainWindow содержит только XAML разметку и не содержит никакого пользовательскогыделенного кода. Зато он использует механизм связывания данных для отображенианных на экране и управления пользовательскими командами. Для того чтобы этозволить мы должны передать MainWindowViewModel в его свойство DataContext.
MainWindowViewModel раскрывает такие данные, как список товаров, а также командоздания, обновления или удаления товара. Возможность такой функциональностависит от сервиса, который обеспечивает доступ к каталогу товаров: абстракция
IProductManagementAgent.
Помимо IProductManagementAgent для MainWindowViewModel также необходим сервисоторый он может использовать для того, чтобы контролировать его оконную среду
(windowing environment), например, демонстрацию модальных диалоговых окон. Этависимость называется IWindow.
MainWindowViewModel использует паттерн Constructor Injection со следующей сигнатуроонструктора:
public MainWindowViewModel(IProductManagementAgent agent, IWindow window)
Для соединения приложения мы должны создать MainWindowViewModel и передать его войство DataContext экземпляра MainWindow.
С оединение MainWindow и MainW indowViewModel
Данному примеру придает остроты тот факт, что для корректной реализации IWindow, ваужен указатель на реальное WPF окно (MainWindow); но для ViewModel необходим
IWindow, а свойство DataContext экземпляра MainWindow должно быть ViewModel.
Другими словами, вы получаете циклическую зависимост ь.
В главе 6 мы имели дело с циклическими зависимостями и прошлись по соответствующеасти этого конкретного примера, поэтому я не буду повторять это в данной главе.
Достаточно сказать, что вводится MainWindowViewModelFactory, который являетстветственным за создание экземпляров MainWindowViewModel.
Вы используете эту фабрику в рамках реализации IWindow под названием
MainWindowAdapter для того, чтобы создать MainWindowViewModel и передать его войство DataContext экземпляра MainWindow:
var vm = this.vmFactory.Create(this);
this.WpfWindow.DataContext = vm;
Переменная члена vmFactory – это экземпляр IMainWindowViewModelFactory, и вередаете в его метод Create экземпляр содержащегося класса, который реализует
262
IWindow. Итоговый экземпляр ViewModel затем передается в DataContext WpfWindowоторый является экземпляром MainWindow.
Примечание
Я не рассматриваю детали, поскольку мы рассматривали их в главе 6. Вернитесь к этолаве и прочтите раздел о циклических зависимостях, если вам нужно освежить в памято, что сейчас происходит.
Подсказка
Для механизма связывания WPF данных необходимо, чтобы мы передавали зависимость
(ViewModel) в свойство DataContext. По моему мнению, это неправильное использование
Property Injection, поскольку это сигнализирует о том, что зависимость являетсеобязательной, а это абсолютно не так. Тем не менее, WPF 4 вводит нечто, имеющеазвание XamlSchemaContext, который может использоваться в качестве шва, который, вою очередь, дает нам большую гибкость в тех ситуациях, когда дело доходит доздания экземпляров Views на основании разметки.
Рисунок 7-12 демонстрирует окончательную диаграмму зависимостей приложения.
Рисунок 7-12: Диаграмма зависимостей MainWindowAdapter, который является основныбъектом приложения. MainWindowAdapter использует MainWindowViewModelFactory длоздания соответствующего ViewModel и передачи его в MainWindow. Для того чтобоздать MainWindowViewModel фабрике нужно передать WcfProductManagementAgent во
ViewModel. Этот "посредник" является адаптером между IProductManagementAgent и
WCF прокси. Он требует, чтобы ProductChannelFactory создал экземпляры WCF прокси также IClientContractMapper, который может выполнять преобразование между
ViewModels и WCF контрактами данных.
Теперь, когда вы идентифицировали все строительные блоки приложения, вы можеткомпоновать их. Для того чтобы сохранить Poor Man's DI код симметричным, используя
263
при этом DI-контейнер, я реализовал это в виде Resolve метода специализированногласса контейнера. В следующем листинге продемонстрирована реализация.
Листинг 7-10: Композиция главного окнublic IWindow ResolveWindow()
{
IProductChannelFactory channelFactory =
new ProductChannelFactory();
IClientContractMapper mapper =
new ClientContractMapper();
IProductManagementAgent agent =
new WcfProductManagementAgent(
channelFactory, mapper);
IMainWindowViewModelFactory vmFactory =
new MainWindowViewModelFactory(agent);
Window mainWindow = new MainWindow();
IWindow w =
new MainWindowAdapter(mainWindow, vmFactory);
return w;
}
В конечном итоге вы возвращаете экземпляр IWindow, реализованный
MainWindowAdapter, а для этого вам нужны WPF Window и
IMainWindowViewModelFactory. Первым окном, которое вы должны продемонстрироватользователям, должно быть MainWindow, поэтому именно его вы и передаете в
MainWindowAdapter.
MainWindowViewModelFactory использует паттерн Constructor Injection для запроса
IProductManagementAgent, поэтому вы должны скомпоновать
WcfProductManagementAgent с двумя его зависимостями.
Окончательный MainWindowAdapter, возвращаемый из метода, обертывает MainWindowоэтому, когда мы вызываем метод Show, он делегирует полномочия методу Show
MainWindow. Это именно то, что вы и будете делать в Composition Root.
Реализация Composition Root
Теперь, когда вы знаете, как подключить приложение, вам нужно всего лишь сделать это равильном месте. Как описывалось в предыдущем разделе, вам для начала нужнткрыть App.xaml и удалить атрибут StartupUri, поскольку вы хотите самостоятельнвным образом компоновать начальное окно запуска.
После того, как вы это сделали, вам нужно только переопределить метод OnStartup в
App.xam l.cs и вызвать контейнер.
Листинг 7-11: Реализация WPF Composition Roorotected override void OnStartup(StartupEventArgs e)
{
base.OnStartup(e);
var container =
new ProductManagementClientContainer();
container.ResolveWindow().Show();
}
264
В данном примере вы используете специализированный
ProductManagementClientContainer, но вы также могли использовать и универсальный
DI-контейнер, например, Unity или StructureMap. Вы просите контейнер преобразоваткземпляр IWindow, а затем вызвать его метод Show. Возвращаемый экземпляр IWindow –
это MainWindowAdapter, когда вы вызываете его метод Show, он вызывает метод Shoнкапсулированного MainWindow, который становится причиной того, что желаемое окнемонстрируется пользователю.
WPF предлагает простое место для Composition Root. Все, что вам нужно сделать –
удалить StartupUri из App.xaml, переопределить OnStartup в App.xaml.cs и скомпоноватам приложение.
До настоящего момента вы встречались с примерами, в которых фреймворкредоставляют швы, позволяющие нам перенять жизненный цикл экземпляров ключевыбъектов (веб-страниц, экземпляров сервисов, окна и других). Во многих случаях этовольно просто; но даже когда это настолько усложняется, как например, в WCF, мы всще можем достичь цели и реализовать подлинный механизм внедрения зависимостей, нодвергая при этом риску наши принципы.
Некоторые фреймворки, тем не менее, не предоставляют нам такой роскоши.
265
7.5. Построение ASP.NET приложений
Некоторые фреймворки настаивают на создании и управлении жизненным циклоаписанных нами классов. Самый популярный фреймворк – ASP.NET (Web Forms, ротивоположность MVC).
Примечание
Некоторые другие фреймворки, разделяющие эту особенность, – это Microsoft
Management Console (MMC), управляемый SDK, и такая недавняя разработка, как
PowerShell.
Наиболее очевидным симптомом таких фреймворков является то, что, чтобы им подойтиаши классы должны обладать конструктором по умолчанию. В ASP.NET, напримерюбой реализуемый нами класс Page должен обладать непараметризованныонструктором. Мы не можем использовать Constructor Injection в рамках этиреймворков, поэтому давайте рассмотрим наши возможности.
ASP.NET композиция
Паттерн Constructor Injection был бы предпочтительным, поскольку он позволял бдостовериться, что наши классы Page будут правильно инициализиро ваться совместно х зависимостями. Так как это невозможно, мы должны выбирать между следующимльтернативными вариантами:
? Перемещать и дублировать наши Composition Root'ы в пределах каждого класса
Page.
? Использовать Service Locator для того, чтобы преобразовать все зависимости ределах каждого класса Page.
Тем не менее, не забывайте о том, что Service Locator – это анти-паттерн, поэтому такоариант не желателен. Наилучшая альтернатива – пойти на компромисс в вопросасположения нашего Composition Root.
В идеале, мы бы предпочли сценарий, продемонстрированный на рисунке 7-13, протором мы имеем всего один Composition Root для приложения, но в ASP.NET этевозможно, поскольку мы не можем компоновать экземпляры Page извне. Другимловами, фреймворк Web Forms вынуждает нас компоновать приложение в пределааждого Page.
Рисунок 7-13: В идеальном мире нам хотелось бы уметь компоновать объекты Page из
Com position Root приложения. При получении запроса мы должны уметь использоватпределенную конфигурацию зависимостей для того, чтобы скомпоноватоответствующий объект Page. Тем не менее, это невозможно, поскольку ASP.NET
управляет жизненным циклом объектов Page от нашего имени.
266
Примечание
До настоящего времени я говорил только об объектах Page, но ASP.NET требует, чтобольшинство объектов обладали конструкторами по умолчанию в случае, если мы хотиспользовать фреймворк. Еще одним примером является Object Data Sources. Обсуждениемеющее место в данном разделе, в равной степени хорошо применяется ко всестальным типам, которые должны обладать конструктором по умолчанию.
Чтобы обратиться к этой проблеме, мы должны подвергнуть риску наши идеалы, номпромисс в вопросе расположения наших Composition Root'ов кажется мне болеезопасным, чем позволить Service Locator вступить в игру.
По существу мы преобразуем каждый Page в Com position Root, как этродемонстрировано на рисунке 7-14. Принцип единичной ответственности напоминаеам о том, что каждый класс должен иметь только одну ответственность; теперь, когда мспользуем Page для того, чтобы скомпоновать все необходимые зависимости, молжны делегировать ответственность за реализацию реализат ору (implementer). Такоодход эффективно преобразует Page в humble-объект ("скромный" объект), раскрываругие члены, такие, как обработчики события нажатия кнопки только для того, чтобелегировать полномочия реализатору преобразованного Page.
Рисунок 7-14: В ASP.NET мы можем использовать точку входа в приложение
(global.asax) для того, чтобы конфигурировать зависимости, но потом до того, как мможем продолжить композицию, нам придется ждать, пока фреймворк не создаст новыбъект Page. В пределах каждого Page мы можем использовать сконфигурированныависимости для того, чтобы скомпоновать реализатор, который реализует все поведениласса Page.
Различие между вариантом перемещения Com position Root в каждый класс и вариантоспользования Service Locator – трудно уловимо. Разница заключается в том, чтлагодаря Service Locator мы можем преобразовывать зависимости каждого класса Page ндивидуальном порядке, и использовать их напрямую в пределах класса Page. Кабычно бывает с Service Locator, он склонен к размытию фокуса класса. Кроме тогоовольно заманчиво сохранить контейнер и использовать его для того, чтобреобразовать остальные зависимости как надо.
Чтобы противодействовать этой тенденции, важно использовать наш контейнер толькля преобразования реализатора, а затем – забыть о нем. Это позволяет науководствоваться подходящими DI-паттернами (например, Constructor Injection) длстальной части кода приложения.
267
Несмотря на то, что это только теория, вы расслабитесь, услышав, что это легкеализовать. Лучше всего это иллюстрируется на примере.
Пример: подключение CampaignPresenter
Шаблонное приложение Commerce, которое вы знаете и любите, поддерживает такиозможности, как скидки на т овары и список рекомендуемых товаров, но до настоящегомента вы не обеспечивали потребителей приложением, которое управляло бы этимспектами. В данном примере мы рассмотрим, как компоновать ASP.NET приложение
(продемонстрировано на рисунке 7-15), которое позволяет потребителю обновлять данныб акциях для товара.
Рисунок 7-15: Приложение CampaignManagement позволяет промышленным потребителяедактировать данные об акциях (Featured (Рекомендуемые) и Discount Price (Цена скидкой)) для товара. Это ASP.NET приложение, построенное с элементом управления
GridView, привязанным к элементу управления ObjectDataSource.
Говоря простыми словами, это приложение состоит из единственного элементправления, привязанного к ObjectDataSource. Источник данных – это класс конкретногриложения, который делегирует свое поведение доменной модели и, в конечном счетеередает его в библиотеку доступа к данным, которая хранит данные в базе данных SQL
Server.
Вы все еще можете использовать global.asax для конфигурирования зависимостей, но волжны отложить компоновку приложения до тех пор, пока не будут созданы Page и его
ObjectDataSource. Конфигурирование зависимостей схоже с предыдущими примерами.
Конфигурирова ние зависимосте й в ASP.NET
В ASP.NET точкой входа в приложение является файл global.asax, и, несмотря на то, чты ничего не можете компоновать в этой точке, вы можете создать свой mise en placeодготавливая все для запуска приложения:
protected void Application_Start(object sender, EventArgs e)
{
this.Application["container"] =
new CampaignContainer();
}
268
Единственное, что вы здесь делаете, – создаете ваш контейнер и сохраняете его в
Application Context, поэтому вы можете использовать его, когда вам это нужно. Этозволяет вам совместно использовать контейнер в рамках отдельных веб-запросовоторые являются существенными, если вам нужно сохранить некоторые зависимости нремя жизненного цикла процесса (более подробно о жизненных циклах мы поговорим лаве 8).
Примечание
Как и во всех остальных примерах данной главы, я использую Poor Man's DI для тоготобы продемонстрировать основные рассматриваемые принципы. CampaignContainer –
это пользовательский класс, созданный специально для этого примера, но вы можетегко заменить его выбранным вами DI-контейнером.
Большинство различных Page и объектов источников данных могут совместнспользовать один и тот же контейнер посредством обращения к Application Context. Тее менее, этот подход несет за собой опасность неправильного использования его ачестве Service Locator, поскольку любой класс может потенциально получить доступ к
Application Context. Таким образом, важно делегировать реализацию классам, которые ногут получить доступ к Application Context. На практике это означает делегированиолномочий классам, реализованным в других отдельных библиотеках, которые нсылаются на ASP.NET.
Примечание
Мы можем также продолжить свой путь слегка дисциплиниро ванно, сдерживая себя обращения к Application Context, за исключением реализации Composition Root. Этожет хорошо подходить в тех случаях, когда все разработчики имеют опыт в написанилабо связанного кода; но если мы думаем, что некоторые члены команды могут не донца понимать рассматриваемую проблему, мы можем удачно защитить код посредствоспользования отдельных библиотек. Раздел 6.5 описывает, как это сделать.
В текущем примере вы будете делегировать всю реализацию отдельной библиотекогики отображения для того, чтобы убедиться, что никакие классы не обращаютсапрямую к Application Context. Вы не позволяете библиотеке ссылаться на какую-либборку ASP.NET (например, System.Web).
Рисунок 7-16 демонстрирует частичное представление архитектуры приложения.
Основной момент – это тот факт, что вы используете классы центральной частриложения (Default Page и CampaignDataSource) в качестве Composition Root'овоторые преобразуют классы уровня "Логика представления" совместно с иависимостями.
269
Рисунок 7-16: Центральная часть приложения CampaignManagement – это единственнаоставляющая приложения, ссылающаяся на ASP.NET. Класс CampaignDataSource имееонструктор по умолчанию, но действует как Composition Root или humble-объектоторый делегирует все вызовы метода CampaignPresenter. Обычно стрелки обозначаюказатели, а центральная часть приложения ссылается на все остальные модулриложения, поскольку она соединяет их вместе. Как модуль логики представления, так одуль доступа к данным ссылаются на библиотеку доменной модели. Не всассматриваемые классы продемонстрированы на этом рисунке.
Вооруженные знанием диаграммы зависимостей приложения, мы теперь можееализовать Composition Root для кадра, продемонстрированного на рисунке 7-15.
Компоновка ObjectDataSource
Default Page, продемонстрированный на рисунке 7-15, состоит из элемента управления
GridView и связанного с ним элемента управления ObjectDataSource. Как и в случае лассами Page, класс, используемый для ObjectDataSource также должен обладатонструктором по умолчанию. Для достижения этой цели вы специально создаете классродемонстрированный в следующем листинге.
270
Листинг 7-12: Компоновка Presenter в качестве источника данных
1. public class CampaignDataSource
2. {
3. private readonly CampaignPresenter presenter;
4. public CampaignDataSource()
5. {
6. var container =
7. (CampaignContainer)HttpContext.Current
8. .Application["container"];
9. this.presenter = container.ResolvePresenter();
10. }
11. public IEnumerable<CampaignItemPresenter> SelectAll()
12. {
13. return this.presenter.SelectAll();
14. }
15. public void Update(CampaignItemPresenter item)
16. {
17. this.presenter.Update(item);
18. }
19. }
Строка 9: Формирует Presenter
Строка 13, 17: Делегирует полномочия Presenter
Класс CampaignDataSource имеет конструктор по умолчанию, поскольку того требует
ASP.NET. Близкий по духу принципу Fail Fast (принцип быстрого отказа), оезамедлительно пытается извлечь контейнер из Application Context и преобразоваткземпляр CampaignPresenter, который будет выступать в роли реальной реализации.
Все члены класса CampaignDataSource делегируют вызов преобразованномредъявителю, таким образом, действуя как humble-объект.
Примечание
Для приверженцев паттернов проектирования класс CampaignDataSource очень похоибо на Decorator, либо на Adapter. Он не реализует строго типизированный интерфейс, нбертывает соответствующую реализацию в класс, который соответствует требованиямредъявляемых ASP.NET.
Вам может быть интересно, что мы приобретаем благодаря этому дополнительномровню преобразования. Если вы привыкли к разработке через тестирование, то этолжно быть вам понятно: HttpContext.Current недоступен во время модульногестирования, поэтому вы не можете выполнить модульное тестирование
CampaignDataSource. Это важная причина того, почему вы должны сохранять его hum ble-
объектом.
Несмотря на то, что эта конструкция, в лучшем случае, неудобна, она позволяет вауководствоваться соответствующими DI-паттернами из класса CampaignPresenter и альнейшем проходить уровни приложения один за одним.
271
Компоновка Presenter
Я не буду знакомить вас с подробной информацией о CampaignPresenter, но стоиассмотреть сигнатуру его конструктора, поскольку он использует Constructor Injection:
public CampaignPresenter(CampaignRepository repository,
IPresentationMapper mapper)
Зависимостями CampaignPresenter являются абстрактный класс CampaignRepository нтерфейс IPresentationMapper. Как раз то, что делают эти абстракции, менее важноем то, как вы их компонуете. Это является задачей CampaignContainer из следующегистинга. Вы можете вспомнить, что вы конфигурировали его в global.asax егистрировали в Application Context.
Листинг 7-13: Преобразование CampaignPresenter
1. public CampaignPresenter ResolvePresenter()
2. {
3. string connectionString =
4. ConfigurationManager.ConnectionStrings
5. ["CommerceObjectContext"].ConnectionString;
6. CampaignRepository repository =
7. new SqlCampaignRepository(connectionString);
8. IPresentationMapper mapper =
9. new PresentationMapper();
10. return new CampaignPresenter(repository, mapper);
11. }
Строка 6-7: Создает репозиторий
Строка 8-9: Создает преобразователь
Строка 10: Формирует Presenter
Ответственность метода ResolvePresenter – скомпоновать экземпляр
CampaignPresenter. Из конструктора вы знаете, что для него нужен CampaignRepositoryоэтому вы преобразовываете его в экземпляр SqlCampaignRepository. Другоависимостью является IPresentationMapper, и вы преобразуете ее в конкретный класс
PresentationMapper.
Вооружившись всеми необходимыми зависимостями, вы можете впоследствии вернутовый экземпляр CampaignPresenter.
Использование механизма внедрения зависимостей в рамках ASP.NET невозможно.
Главным недостатком использования каждого Page и источника данных объекта в видбъединенного Com position Root и humble-объекта является то, что для этого необходимублирование большинства членов класса.
Обратили ли вы внимание на то, как каждый член CampaignDataSource делегирует своеализацию схожему по названию методу CampaignPresenter? Вам придется повторятту идиому кода на протяжении всего ASP.NET приложения. Для каждого обработчикобытия нажатия кнопки вам необходимо определить и поддерживать в работоспособноостоянии связанный метод класса Presenter и тому подобное.
272
Как мы уже обсуждали в главе 3, я приравниваю понятие Com position Root к такомонятию Бережливой разработки программного обеспечения (Lean Software
Developm ent), как последний ответственный момент . В рамках таких фреймворков, как
ASP.NET MVC и W CF, мы можем отложить композицию приложения вплоть до точкхода в приложение, но в ASP.NET так не делается. Не важно, как упорно мы стараемсяы можем отложить только принятие решений о композиции объектов, пока нтолкнемся с требованием о необходимости наличия конструктора по умолчанию.
Потом это становится "самым возможным местом", в котором мы можем компоноватбъекты. Несмотря на то, что мы считаем, что пришли к компромиссу, мы все ещледуем всеобщему духу Composition Root. Мы компонуем иерархии объектов настольклизко к верхним уровням приложения, насколько это возможно, и разрешаем корректные
DI-паттерны как здесь, так и на более низких по иерархии уровнях.
ASP.NET все еще предоставляет нам небольшую роскошь: мы можем использовать одикземпляр контейнера в рамках Application Context. Некоторые фреймворки не допускаюаже это.
273
7.6. Построение PowerShell cmdlets
Некоторые фреймворки совсем не предоставляют швов, которые позволяют направлять жизненным циклом основных элементов фреймворка. Windows PowerShelвляется одним из таких фреймворков.
Примечание
Прочитайте этот раздел, даже если вы не интересуетесь PowerShell. Я выбрал еголавным образом, в качестве примера последнего испытания механизма внедрениависимостей. Я также мог остановить свой выбор на Managed MMC SDK, но он в столногих других моментах не приятен для использования, что я предпочел использовать ачестве примера PowerShell.
Важным элементов PowerShell является cmdlet (предполагаю, что это слово произноситсак commandlet, но я видел только, что он пишется как cmdlet). Вы можете считать cmdleродвинутой утилитой командной строки.
cmdlet – это класс, унаследованный от Cmdlet, и он должен иметь конструктор пмолчанию. Как и для ASP.NET это требование эффективно исключает любоспользование Constructor Injection. Решение проблемы тоже аналогично: мы перемещаем
Composition Root в конструктор каждого cmdlet. Единственное отличие – отсутствуестроенный Application Context, поэтому мы должны прибегнуть к самому низшемниверсальному деноминатору: статическому классу.
Примечание
Я предпочитаю code sm ell (гнилой код) любому использованию ключевого слова staticо по сравнению с анти-паттернами code sm ell'ы указывают только на потенциальныедостатки проектирования. В некоторых особых случаях использование подобных идиоправдано, и это именно тот случай.
Вас может заинтересовать то, как это все отличается от анти-паттерна Service Locator. Ка для ASP.NET главное отличие заключается не в структуре кода, а в использованиаттерна. Вместо того чтобы пытаться использовать статический Service Locator ачестве виртуального ключевого слова new, для каждого cmdlet мы используем еголько один раз. Чтобы защитить себя в дальнейшем от неправильного использования, можем сделать Composer внутренним и использовать его только для преобразования типоз различных сборок, как это продемонстрировано на рисунке 7-17.
274
Рисунок 7-17: Когда нет выхода для статического контейнера, мы можем сделать егнутренним и переместить в корневую сборку приложения. Все методы Resolvозвращают классы, которые определены в других сборках. Таким образом, как тольконтейнер преобразовал реализатор, ни один из классов преобразованной иерархиависимостей не имеет доступа к статическому контейнеру, поскольку все они находятса пределами центральной сборки приложения, а контейнер находится внутри.
Результатом преобразования диаграммы зависимостей является класс, определенный ругой сборке, и этот класс не имеет доступа к статическому контейнеру, поскольку оаходится внутри центральной сборки приложения. Реализатору cmdlet необходимспользовать соответствующие DI-паттерны, как например, Constructor Injection, для тоготобы применять любые зависимости, и мы эффективно защищаем себя от угроз Service
Locator'а.
Давайте рассмотрим пример, который иллюстрирует этот принцип.
Пример: построение cmdlet'ов управления корзиной
Этот пример возвращает нас к шаблонному коммерческому приложению. Как ольшинство других коммерческих приложений, это приложение имееункциональность корзины покупок. Среди пользователей общепринятой является такаитуация: добавлять элементы в свою корзину покупок, но потом покидать сайт и никогдольше сюда не заходить.
Несмотря на то, что хранение в эти дни обходится дешево, заинтересованные сторонроекта попросили, чтобы вы предоставили им гибкую возможность очищать осиротелыорзины на основании различных критериев. Они хотят иметь возможность выбиратсиротелые корзины на основании того, когда они в последний раз обновлялись. Еслорзина содержит значительное количество товаров, то ее не следует удалять (или, можеыть, ей необходимо предоставить более длительный льготный период), но общеоличество должно быть рассчитано согласно всем текущим бизнес-правилам.
Кажется, что API написания сценариев отлично подошло бы для этого, посколькдминистратор смог бы определять и составлять расписание простых скриптов очистки.
PowerShell здесь наиболее подходит благодаря своей продвинутой функциональностильтрации и транспортировки.
275
Вы можете реализовать желаемое API с помощью двух cmdlet'ов: один – для того, чтобзвлечь все корзины, а другой – для удаления корзины данного пользователя. Следующиистинг является примером того, как это могло бы выглядеть в интерактивной сессии.
Листинг 7-14: Удаление корзин, хранящихся более одного месяца
1. PS C:\> Get-Basket
2. LastUpdated Owner Total
3. ----------- ----- -----
4. 19.03.2010 20:5... ploeh 89,4000
5. 22.01.2010 19:5... ndoh 199,0000
6. 21.03.2010 09:1... fnaah 171,7500
7. PS C:\> $now = [System.DateTime]::Now
8. PS C:\> $month = [System.TimeSpan]::FromDays(30)
9. PS C:\> $old = $now - $month
10. PS C:\> Get-Basket | ? { $_.LastUpdated -lt $old } |
11. Remove-Basket
12. PS C:\> Get-Basket
13. LastUpdated Owner Total
14. ----------- ----- -----
15. 19.03.2010 20:5... ploeh 89,4000
16. 21.03.2010 09:1... fnaah 171,7500
17. PS C:\>
18.
Строка 5: Старая корзина
Строка 7-9: Рассчитывает дату закрытия
Строка 10-11: Удаляет старые корзины
Перед тем как вы начнете удалять корзины, вам хотелось бы просмотреть текущиорзины системы. Вы можете использовать пользовательский cmdlet Get-Basket длого, чтобы перечислить все корзины. Обратите внимание на то, что каждая корзина имеери свойства, которые сообщают вам о том, когда корзина в последний раз обновляласьто является владельцем корзины, а также об общей стоимости (включая скидки)
корзины.
Текущей датой выполнения этой конкретной сессии была 22 марта 2010 года. Обратитнимание на то, что второй корзине уже более 30 дней. Теперь вы можете рассчитать датакрытия на основании текущей даты и использовать ее в выражении фильтра. Вы можетдалить все старые корзины путем передачи результата Get-Basket в фильтр, а затеередавая результат отфильтрованных корзин в cmdlet Remove-Basket. Если бы вахотели выполнить фильтрацию по свойству Total, то вы также смогли бы это сделатем же способом.
В итоге, вы перечисляете все корзины, чтобы удостовериться, что все старые корзиндалены.
Примечание
Не переживайте, если не поняли всех деталей выражения фильтра. Это книга не о
PowerShell, поэтому я не буду задерживаться на этой теме.
276
Для продвижения этого API написания сценариев вам необходимо реализовать двользовательских cmdlet'а. Поскольку одним из требований является то, что Totaолжен принимать во внимание все соответствующие бизнес-правила, вам необходимомпоновать cmdlet'ы в рамках уровня Domain Model.
Построение GetBasketCmdlet
Давайте рассмотрим, как реализуется cmdlet Get-Basket. Remove-Basket реализуетсохожим способом, поэтому я не буду рассматривать его реализацию.
Для того чтобы избежать соблазна статического контейнера, вы будете реализовыватолноценный мост между cmdlet'ом PowerShell и Domain Model в отдельной библиотекеоторая носит название BasketPowerShellLogic. Рисунок 7-18 демонстрирует, каомпонуется приложение в пределах библиотек.
Рисунок 7-18: Библиотека BasketPowerShell содержит только инфраструктуруеобходимую для того, чтобы осчастливить PowerShell – это humble-объект. Как только
BasketContainer преобразовал BasketManager, все дальнейшие реализации происходят ругих сборках. Класс BasketManager не имеет доступа к внутреннему BasketContainerо использует IBasketService из Domain Model. Обычно стрелки обозначают указатели.
Не все рассматриваемые классы продемонстрированы на рисунке.
Примечание
Если вы думаете, что рисунок 7-18 очень похож на рисунок 7-16, то вы начинаетонимать паттерн.
Примечание
Вы можете вспомнить IBasketService из главы 2, раздела 2.3.2.
277
Класс GetBasketCmdlet должен иметь конструктор по умолчанию для того, чтобоответствовать PowerShell, поэтому вы используете его в качестве Composition Root ставляете его в виде hum ble-объекта. Следующий листинг демонстрирует только тоасколько он "скромен".
Листинг 7-15: Реализация GetBasketCmdlet
1. [Cmdlet(VerbsCommon.Get, "Basket")]
2. public class GetBasketCmdlet : Cmdlet
3. {
4. private readonly BasketManager basketManager;
5. public GetBasketCmdlet()
6. {
7. this.basketManager =
8. BasketContainer.ResolveManager();
9. }
10. protected override void ProcessRecord()
11. {
12. var baskets =
13. this.basketManager.GetAllBaskets();
14. this.WriteObject(baskets, true);
15. }
16. }
Строка 7-8: Composition Root
Строка 12-13: Делегирование полномочий реализатору
В требуемом конструкторе по умолчанию вы используете статический контейнер длого, чтобы преобразовать BasketManager, который выступает в роли реализации.
BasketManager использует Constructor Injection для запроса экземпляра IBasketService.
К настоящему моменту вы должны уже хорошо знать этот паттерн, а также реализацию
BasketContainer, продемонстрированну ю в следующем листинге.
Листинг 7-16: Преобразование BasketManager
1. internal static BasketManager ResolveManager()
2. {
3. BasketRepository basketRepository =
4. new SqlBasketRepository(
5. BasketContainer.connectionString);
6. DiscountRepository discountRepository =
7. new SqlDiscountRepository(
8. BasketContainer.connectionString);
9. BasketDiscountPolicy discountPolicy =
10. new RepositoryBasketDiscountPolicy(
11. discountRepository);
12. IBasketService basketService =
13. new BasketService(basketRepository,
14. discountPolicy);
15. return new BasketManager(basketService);
16. }
Строка 1: Внутренний метод
Строка 15: Возвращает basket manager
278
Метод, так же, как и весь класс, является внутренним, что делает возможным вызов его из
GetBasketCmdlet, как это продемонстрировано в листинге 7-15, но невозможно случайнспользовать его из BasketManager или из его зависимостей.
Теперь реализация метода должна быть вам понятной. И снова я считаю, что проще всегтойти от результата. Для класса BasketManager необходим экземпляр IBasketService, оэтому вы используете класс BasketService (других реализаций, которые вы могли быбрать, у вас нет).
Для BasketService необходимы BasketRepository и BasketDiscountPolicy. Для
BasketDiscountPolicy вы используете RepositoryBasketDiscountPolicy. Для этогласса требуется еще одна абстракция репозитория, а для этих двух репозиториев вспользуете реализации на основе SQL Server.
Реализация BasketManager является стандартной, поэтому я не буду ее показывать. Всето она делает – выражает необходимые операции в терминах доменной модели.
Remove-Basket cmdlet руководствуется тем же паттерном: он использует статический, ннутренний BasketContainer для того, чтобы преобразовать экземпляр BasketManager, отом делегировать реализацию преобразованному экземпляру. Оба cmdlet'а выступают оли сочетания Composition Root и hum ble-объекта.
Класс BasketManager реализуется в другой сборке. Как только код уходит от cmdlet'овиск, что какая-либо из основополагающих реализаций будет использовать статическионтейнер в качестве Service Locator, исчезает, поскольку он является внутренним птношению к сборке, содержащей cmdlet'ы.
Примечание
Очевидно, основополагающий код ничего не будет делать случайно, но разработчикишущий код, может. Мы защищаем статический контейнер от остальной части кода длого, чтобы защитить себя от совершения ошибок.
Фреймворк, подобный PowerShell, является самым DI-недружественным. Использованиростой технологии превращения каждого элемента фреймворка в Composition Root umble-объект дает вам простой способ решения этой проблемы.
279
7.7. Резюме
Композиция объектов– один из трех важных аспектов механизма внедрения зависимостей
(двумя другими являются управление жизненным циклом и перехват). В данной главе родемонстрировал то, как компоновать приложения из слабо связанных модулей вножестве различных сред.
Некоторые фреймворки облегчают этот процесс. При написании консольных приложени Windows клиентов (WPF или Windows Forms) мы более или менее напрямуонтролируем то, что происходит в точке входа в приложение. Это обеспечивает наазличными и легко реализуемыми Composition Root в точке входа.
Другие фреймворки, например, ASP.NET MVC и WCF, заставляют нас поработатемного усерднее, но они все же предоставляют швы, которые мы можем использоватля того, чтобы определить то, как приложение должно быть скомпоновано. ASP.NET
MVC уже был создан с замыслом механизма внедрения зависимостей, поэтомостроение приложения такой же простой процесс, как и реализация пользовательского
IControllerFactory и регистрация его с помощью фреймворка. Кажется, что в WCF шоаходится почти случайно, но, несмотря на то, что это более обходной путь, нежелеализация единичного интерфейса, мы все еще можем достичь всех ценных свойстеханизма внедрения зависимостей, которые только могли бы пожелать.
Остальные фреймворки являются явно DI-недружественными и требуют от наспользования конструктора по умолчанию для соответствия им. ASP.NET (Web Form s)
является самым известным из них, но еще одними примерами являются также и
PowerShell, и Managed MMC SDK. Эти фреймворки управляют жизненными цикламлассов, которые мы предоставляем, поэтому единственный вариант – рассматриватаждый класс как отдельный Com position Root. Это требует много затрат, поэтому я личнредпочитаю использовать DI-дружественные фреймворки, если у меня есть выбор.
Без композиции объектов нет и механизма внедрения зависимостей, но вы, возможно, еще осознали полностью роль жизненного цикла объектов, когда мы переносили созданибъектов из используемых классов. Вам может показаться само собой разумеющимся, чтнешний объект, выполняющий вызов, (чаще всего DI-контейнер) создает новыкземпляры зависимостей – но когда высвобождаются внедряемые зависимости? И чтсли внешний объект, выполняющий вызов, решит не создавать новые экземпляры всремя, а вместо этого передаст вам существующий экземпляр? Это темы обсуждения длледующей главы.
280
8. Жизненный цикл объектов
Меню:
? Управление жизненным циклом зависимостей
? Устраняемые зависимости
? Singleton
? Transient
? Per Graph
? Web Request Context
? Pooled
Истечение срока действия основательно влияет на большинство продуктов и напитков, носледствия сильно различаются. Лично я считаю 12-месячный Gruyere (швейцарскиыр) гораздо более интересным, нежели 6-месячный Gruyere, но предпочитаю, чтобспарагус был свежее 12-месячного и 6-месячного Gruyere. В большинстве случаеценить точный возраст элемента довольно просто; но в определенных случаях этороцесс становится очень сложным. Истечение срока действия наиболее значимо, когдело касается вина (см. рисунок 8-1).
Рисунок 8-1: Вино, сыр и аспарагус. Несмотря на то, что, если смешать эти ингредиенты получим не совсем хороший результат, возраст этих ингредиентов значительно влияеа их общее качество.
281
С годами вина становятся лучше – до тех пор, пока они не станут слишком старыми и нотеряют свой аромат. Это зависит от множества факторов, включая происхождение рожай вина. Несмотря на то, что я интересуюсь винами, я даже и не надеюсь, что смогпределить, когда вино достигнет своего полного расцвета. В этом вопросе я полагаюсь нкспертов: на книги – дома и на сомелье – в ресторанах. Они разбираются в винах лучшеня, так как это их специальность, поэтому всякий раз, когда я им доверяюсь в вопросыбора вина, я с удовольствием позволяю им взять все под свой контроль.
За исключением того случая, когда вы перешли к данной главе, не читая при этом ндной из предыдущих глав, вы понимаете, что возможность уйти от контроля являетслючевой концепцией механизма внедрения зависимостей. Это проблема инверсиправления, но она подразумевает больше, чем просто позволение кому-то отобратеализацию необходимой абстракции. Когда мы позволяем Composer (Компоновщик)
создавать зависимость, мы также должны принять тот факт, что не сможеонтролировать ее жизненный цикл.
Поскольку сомелье хорошо знает содержания винных подвалов ресторана и можеринять гораздо более информативное решение, нежели бы это сделали мы, способностонтролировать жизненный цикл зависимостей мы должны с наибольшеффективност ью доверять Composer (Компоновщик), чем потребителю. Компоновка правление компонентами – это единичная ответственность.
О пределение
Composer – в том смысле, в котором я его использую здесь, это унифицированный терминбозначающий любой объект или метод, который компонует зависимости. Чаще всего это
DI-контейнер, но может быть и любым методом, который используется в Poor Man's DIапример, метод Main консольного приложения.
В данной главе мы будем рассматривать процесс управления жизненным циклоависимостей. Понимание этой темы важно, поскольку точно так же, как вы можетриобретать неудовлетворительный опыт при употреблении вина неправильного возрастаы можете получить ухудшенное выполнение, неправильно сконфигурировав жизненныикл зависимостей. Даже хуже того, вы можете получить аналог испортившегосродукта для механизма управления жизненным циклом: утечки ресурсов. Пониманиринципов корректного управления границами жизненных циклов компонентов должнать вам возможность принимать правильные решения и корректно конфигурироваташи приложения.
Примечание
На всем протяжении данной главы я использую термины тип ст иля существованиятратегия жизненного цикла, границы жизненного цикла и другие редко встречающиесочетания взаимозаменяемо.
Как иллюстрирует рисунок 8-2, мы начнем с общего введения к концепции, за которыледует обсуждение устраняемых зависимостей. Первая часть главы предназначена длого, чтобы предоставить вам всю теоретическую информацию и необходимые ваедущие принципы для того, чтобы принимать умное, взвешенное решение по поводонфигурации границ жизненного цикла ваших собственных приложений.
282
Рисунок 8-2: Полная структура данной главы. Мы начнем с общего обсуждения процессправления жизненным циклом зависимостей, включая конкретное обсуждение работы страняемыми объектами. Нам необходимы эти фундаментальные знания для того, чтобффективно обсуждать универсальные паттерны небольшого каталога стилеуществования, рассматриваемого далее. Мы начнем с рассмотрения некоторыниверсальных и очень полезных паттернов и закончим кратким обзором некоторыолее экзотичных стилей существования для того, чтобы дать вам ощущение широтанной темы.
После этого мы будем использовать остальную часть главы для рассмотрения различнытратегий жизненного цикла. Эта часть книги принимает форму каталога доступнытилей существования. В большинстве случаев один из этих шаблонных паттернов стилеуществования будет отлично подходить для решения конкретной задачи, поэтомаблаговременное понимание этих стилей снабжает вас достаточными знаниями для тоготобы справляться со многими сложными ситуациями. Когда мы закончим изучение этолавы, вы должны будете хорошо разбираться в управлении жизненном циклом и ниверсальных жизненных циклах.
Для начала давайте рассмотрим жизненный цикл объектов и то, каким образом он бщем смысле относится к механизму внедрения зависимостей.
8.1. Управление жизненным циклом зависимостей
8.2. Работа с устраняемыми зависимостями
8.3. Каталог стилей существования объектов
8.4. Резюме
283
8.1. Управление жизненным циклоависимостей
До настоящего момента мы, главным образом, обсуждали то, как механизм внедрениависимостей позволяет нам компоновать зависимости. В предыдущей главассматривался этот вопрос чрезвычайно подробно, но как я говорил в разделе 1-4омпозиция объектов является всего лишь одним из аспектов механизма внедрениависимостей. Управление жизненным циклом объектов является еще одним егспектом.
Примечание
В .NET жизненный цикл объекта достаточно прост: объект создается, используется ничтожается сборщиком мусора (garbage collector). Присутствие IDisposable слегка вссложняет, но жизненный цикл от этого не становится более сложным. При обсуждениизненного цикла объектов мы говорим о том, как мы управляем жизненными цикламбъектов.
В первый раз, когда я познакомился с идеей о том, что в сферу механизма внедрениависимостей входит управление жизненным циклом, я не понимал глубокой связи междомпозицией объектов и жизненном циклом объектов. В конце концов, я это осознал, то оказалось довольно просто, поэтому давайте рассмотрим это вместе с вами.
В данном разделе я буду знакомить вас с механизмом управления жизненным циклом и ем, как применить его к зависимостям. Мы начнем с рассмотрения общего случаомпоновки объектов и того, как компоновка влияет на жизненные циклы зависимостей.
От этой темы мы перейдем к изучению того, как DI-контейнеры могут управлятизненным циклом зависимостей. Несмотря на то, что большинство из примеровляются специализированным кодом, который имеет дело с конкретнымонфигурациями, мы также сделаем краткий обзор шаблонного DI-контейнера для тоготобы получить представление о том, как может выглядеть конфигурация жизненногикла.
Для начала мы исследуем, почему композиция объектов влияет на жизненный цикл.
Знакомство с механизмом управления жизненным циклом
Когда мы принимаем тот факт, что нам следует выбросить из головы нашизиологические потребности для того, чтобы контролировать зависимости и, кроме тогоапрашивать их с помощью Constructor Injection или одного из других DI-паттернов, молжны выбросить это из головы окончательно. Для того чтобы понять, почему, массмотрим этот вопрос постепенно. Давайте начнем с обзора того, что означаетандартный жизненный цикл объекта для зависимостей. Вы уже должны это знать, нотерпите, пока я не пройду следующую половину страницы, и не установлю контекст.
Простой жизненный цикл зависимосте й
Вы знаете, что механизм внедрения зависимостей подразумевает, что мы позволяеторонним объектам выступать для нас в роли необходимых нам зависимостей. Это такжзначает, что мы должны позволить им управлять жизненными циклами зависимостей.
284
Проще всего понять это, когда дело доходит до создания объекта. Ниже приведерагмент кода Composition Root шаблонного приложения Commerce (окончательныример вы можете увидеть в листинге 7-3).
var discountRepository =
new SqlDiscountRepository(connectionString);
var discountPolicy =
new RepositoryBasketDiscountPolicy(discountRepository);
Надеюсь, это очевидно, что класс RepositoryBasketDiscountPolicy не контролирует тоогда создается discountRepository. В данном случае это, скорее всего, происходит ределах той же миллисекунды; но для чистоты эксперимента мы могли бы вставитызов Thread.Sleep между этими двумя строками кода для того, чтобродемонстрировать, что мы можем условно разделить их на промежутки времени. Этыло бы достаточно непонятно для исполнения, но вы все поняли.
Потребители не контролируют создание своих зависимостей, но что насчет уничтожения?
Как правило, мы не контролируем то, когда в .NET уничтожаются объекты. Сборщиусора (garbage collector) собирает неиспользуемые объекты, но до тех пор, пока мы нудем работать с устраняемыми объектами, мы не сможем явно уничтожить объект.
Примечание
Я использую термин уст раняемый объект (disposable object) в качестве условногбозначения экземпляро в объектов типов, которые реализуют интерфейс IDisposable.
Объекты уничтожаются сборщиком мусора, когда они выходят за рамки областрименения. Наоборот, они действуют, пока кто-нибудь еще ссылается на них. Несмотра то, что потребитель не может явно уничтожить объект, он может сохранять объектродолжая ссылаться на него. Именно это мы и делаем при использовании Constructor
Injection, поскольку мы сохраняем зависимость в приватном поле. Но как демонстрируеисунок 8-3, когда потребитель выходит за рамки области применения, то же самое можеделать и зависимость.
Рисунок 8-3: Кто бы ни внедрял зависимость в потребителя, он решает, когда создаетста зависимость, но потребитель может сохранять зависимость, продолжая ссылаться нее. Когда потребитель выходит за границы области применения, зависимость можедовлетворять условиям, необходимым для работы сборщика мусора.
Даже когда потребитель выходит за границы области применения, зависимость можеуществовать, если другие объекты содержат ссылку на нее. В противном случае онудет уничтожена сборщиком мусора. Поскольку вы являетесь опытным .NET
разработчиком, это довольно не ново для вас, но сейчас обсуждение станет для вас болентересным.
285
Усложнение жизненного цикла зависимости
До настоящего момента наш анализ жизненного цикла зависимостей был обыденным, ны можем добавить в него некоторую сложность. Что происходит, когда для более чедного потребителя необходима одна и та же зависимость? Один из вариантов –
дополнить каждого потребителя своим собственным экземпляром, как этродемонстрировано в следующем листинге.
Листинг 8-1: Компоновка с помощью различных экземпляров одной и той жависимости
1. var repositoryForPolicy =
2. new SqlDiscountRepository(connectionString);
3. var repositoryForCampaign =
4. new SqlDiscountRepository(connectionString);
5. var discountPolicy =
6. new RepositoryBasketDiscountPolicy(
7. repositoryForPolicy);
8. var campaign =
9. new DiscountCampaign(repositoryForCampaign);
Строка 6-7, 9: Внедряет соответствующий репозиторий
В данном примере для двоих потребителей необходим экземпляр DiscountRepositoryоэтому вы присоединяете два отдельных экземпляра с одинаковой строкой соединения.
Теперь вы способны передать repositoryForPolicy в новый экземпляр
RepositoryBasketDiscountPolicy, а repositoryForCampaign в новый экземпляр
DiscountCampaign.
Когда дело доходит до жизненных циклов каждого репозитория из листинга 8-1, то правнению с предыдущим примером ничего не изменилось. Каждый из них выходит замки области применения и уничтожается сборщиком мусора, когда потребителыходит за рамки области применения. Это может происходить в разное время, нитуация лишь в малой степени отличается от той, что была до этого.
Несколько другой была бы ситуация, если бы оба потребителя были обязаны совместнспользовать одну и ту же зависимость, как это продемонстрировано в примере:
var repository =
new SqlDiscountRepository(connectionString);
var discountPolicy =
new RepositoryBasketDiscountPolicy(repository);
var campaign = new DiscountCampaign(repository);
Вместо создания двух различных экземпляров SqlDiscountRepository, вы создаетдиничный экземпляр, который внедряете в оба потребителя. Оба потребителя сохраняюсылку для последующего использования.
Примечание
Потребители совершенно не осведомлены о том, что зависимость используется имовместно. Поскольку они оба принимают любую передаваемую им зависимость, длазмещения этого изменения в конфигурации зависимости не нужно никакоодификации исходного кода. Это результат принципа подстановки Барбары Лисков.
286
Принцип подстановки Барбары Лисков
Как утверждалос ь ранее, принцип подстановки Барбары Лисков является теоретической бстрактной сущностью. Но в объектно-ориентированном программировании мы можеерефразировать этот принцип следующим образом: Мет оды, использующ ие абст ракцииолжны уметь использовать любой унаследованный класс, ничего при этом не зная о нем.
Другими словами, мы должны уметь заменять абстракцию произвольной реализацией, нзменяя при этом точность системы.
Ситуация, связанная с жизненным циклом зависимости repository, отчетливзменилась по сравнению с предыдущим примером. Оба потребителя должны выйти замки области применения до того, как repository сможет приобрести право бытничтоженным сборщиком мусора, и сделать они это могут в разное время. Ситуацитановится менее предсказуемой, когда зависимость достигает момента завершенивоего жизненного цикла, и эта особенность только усиливается при увеличении числотребителей.
При достаточном количестве потребителей, скорее всего, поблизости всегда будеаходиться один из них, который сохраняет зависимость "живой". Это может казатьсроблемой, но такое редко случается: вместо множества схожих экземпляров, мы имееолько один, который сохраняет память. Это настолько завидное качество, что мормализуем его в паттерне стиля существования Singleton. Несмотря на их схожесть, нутайте его с паттерном проектирования Singleton. Более подробно этот вопрос массмотрим в разделе "Singleton".
Ключевым моментом, который стоит принять во внимание, является тот факт, что
Composer обладает большей степенью влияния на жизненный цикл зависимостей, нежелюбой единичный потребитель. Composer решает, когда создаются зависимости, и нсновании своего выбора, использовать ли экземпляры совместно или нет, определяетыходит ли зависимость за рамки области применения с единственным потребителем, илсе потребители должны выйти за рамки области применения до того, как могут бытсвобождены зависимости.
Это сравнимо с посещением ресторана в компании хорошего сомелье. Сомелье проводиначительную часть дня, управляя винным подвалом и совершенствуя его содержимоеокупая новые вина, пробуя вино из доступных бутылок для отслеживания того, каазвивается это вино, а также, работая с шеф-поварами, чтобы определить оптимальнооответствие подаваемым блюдам. При ознакомлении с винной картой мы видим только, что сомелье посчитал нужным представить к продаже. Мы вольны выбрать вино оответствии с нашим личным вкусом, но мы не допускаем, что знаем больше сомелье ыборке вин ресторана, и о том, как эти вина сочетаются с блюдами.
Сомелье будет часто принимать решение о хранении большого количества бутылок ранилище на протяжении многих лет; и как вы увидите в следующем разделе, Composeожет принять решение о хранении экземпляро в "живыми", продолжая поддерживатсылки на эти экземпляры.
Управление жизненным циклом с помощью контейнера
В предыдущем разделе объяснялось, как мы можем варьировать композициависимостей для того, чтобы влиять на их жизненный цикл. В данном разделе мы будеассматривать то, как DI-контейнер может обращаться к этим вариациям.
287
Примечание
В данном разделе обсуждаются принципы, лежащие в основе управления жизненнымиклами с помощью DI-контейнера, поэтому я не буду подробно рассматриватонкретные контейнеры. Как и на протяжении всей части 3, я использую Poor Man's DI
для иллюстрации этих сущностей.
Мы начнем с рассмотрения того, как контролировать жизненный цикл зависимостей омощью пользовательских контейнеров, а затем перейдем к легко реализуемому примерадания стилей существования в реальном DI-контейнере.
Управление стилями существования с помощью специализированного контейнера
В главе 7 мы создали специализированные контейнеры для построения приложений.
Одним из таких контейнеров был CommerceServiceContainer. Листинг 7-9 демонстрируееализацию его метода ResolveProductManagementService; и, как показывает рисунок 8-
4, этот метод является единственным кодом в данном классе.
Рисунок 8-4: Вся реализация класса CommerceServiceContainer в настоящий моменасполагается в методе ResolveProductManagementService. Метод Release абсолютничего не делает, кроме того, в классе нет ни полей, ни свойств. Если вам интересноочему здесь присутствует метод Release, то мы вернемся к этому вопросу в разделе
"Управление устраняемыми зависимостями".
Как вы можете помнить из листинга 7-9, метод Resolve создает полноценную диаграммависимостей, каждый раз, когда он вызывается. Другими словами, каждая зависимоствляется приватной по отношению к рассматриваемому IProductManagementService, акие-либо связи отсутствуют. Когда экземпляр IProductManagementService выходит замки области применения (что происходит всякий раз, когда сервис отвечает на запрос)се зависимости также выходят за рамки области применения. Это часто называют стилеуществования Transient (кратковременным), но подробнее о нем мы поговорим в разделе
"T ransient".
Давайте проанализируем диаграмму объектов, созданную CommerceServiceContainer родемонстрированную рисунком 8-5, на факт существования возможности дловершенствования.
288
Рисунок 8-5: Диаграмма объектов, созданная CommerceServiceContainer. Каждыозданный экземпляр ProductManagementService содержит свой собственный
ContractMapper и свой собственный SqlProductRepository, который, в свою очередьодержит собственную строку соединения. Зависимости, показанные справа, являютсеизменными.
Класс ContractMapper является совершенно не сохраняющим свое состояние сервисомоэтому нет необходимости создавать новый экземпляр всякий раз, когда нам нужнбслужить запрос. Строка соединения также, скорее всего, не изменяется, поэтому можем также решить повторно использовать ее в рамках запросов.
Класс SqlProductRepository, с другой стороны, полагается на Entity Framework Object
Context, и считается хорошим тоном использовать для каждого запроса новый экземпляр.
При данной конкретной конфигурации наилучшая реализация CommerceServiceContaineнова использовала бы те же самые экземпляры как ContractMapper, так и строкоединения, при создании новых экземпляров SqlProductRepository. Короче говоря, валедует сконфигурировать ContractMapper и строку соединения таким образом, чтобни использовали стиль существования Singleton и SqlProductRepository в виде
Transient. Следующий листинг демонстрирует, как реализовать данное изменение.
Листинг 8-2: Управление жизненным циклом с помощью контейнера
1. public partial class LifetimeManagingCommerceServiceContainer :
2. ICommerceServiceContainer
3. {
4. private readonly string connectionString;
5. private readonly IContractMapper mapper;
6. public LifetimeManagingCommerceServiceContainer()
7. {
8. this.connectionString =
9. ConfigurationManager.ConnectionStrings
10. ["CommerceObjectContext"].ConnectionString;
11. this.mapper = new ContractMapper();
12. }
13. public IProductManagementService
14. ResolveProductManagementService()
15. {
16. ProductRepository repository =
17. new SqlProductRepository(
18. this.connectionString);
19. Return new ProductManagementService(
20. repository, this.mapper);
21. }
22. }
Строка 8-11: Создает Singleton зависимости
Строка 16-18: Создает Transient зависимость
289
Поскольку вы хотите повторно использовать строку соединения и ContractMapper амках всех запросов, вы сохраняете их в приватных полях и инициализируе те онструкторе. Ключевое слово readonly обеспечивает дополнительную гарантию тогото, будучи единожды заданными, эти Singleton экземпляры остаются неизменными и ногут быть заменены, но кроме этой дополнительной гарантии, readonly никоим образое требуется при реализации стиля существования Singleton.
Каждый раз, когда контейнер просят создать новый экземпляр, он создает Transienкземпляр SqlProductRepository с помощью Singleton строки соединения. В конечночете, контейнер использует этот Transient repository вместе с Singleton mapper длого, чтобы скомпоновать и вернуть экземпляр ProductManagementService.
Примечание
Код в листинге 8-2 функционально эквивалентен коду из листинга 7-9, но только слегколее эффективен.
Продолжая ссылаться на создаваемые им зависимости, контейнер может сохранять их изнеспособном состоянии столь долго, сколько он того хочет. В предыдущем примерн создает обе зависимости, как только они инициализиру ются, но он мог использовать и
Lazy инициализацию.
Данный пример должен дать вам представление о том, как DI-контейнеры управляюизненными циклами. Поскольку DI-контейнер является повторно используемоиблиотекой, мы не можем изменять его исходный код каждый раз, когда нам хочетсереконфигурировать стиль существования. В следующем разделе мы вкратцассмотрим то, как конфигурировать стили существования для шаблонного контейнера.
Управление стилем существования с помощью Autofac
Время от времени на протяжении этой книги я делаю передышку от Poor Man's DI, чтобредоставить пример того, как мы можем достичь результата с помощью шаблонного DI-
контейнера. Каждый DI-контейнер имеет свой собственный конкретный API длыражения множества различных признаков; но, несмотря на то, что детали различаютсяринципы остаются теми же. Это справедливо и для механизма управления жизненныиклом.
Примечание
Даже термин "управление жизненным циклом" не является вездесущим. Например,
Autofac называет этот процесс Областью применения экземпляра (Instance Scope).
В данном разделе мы вкратце будем рассматривать конфигурирование жизненных цикло помощью Autofac.
Примечание
Нет какой-то конкретной причины того, почему для данного примера я предпочел Autofaругим DI-контейнерам. Таким же образом я мог выбрать и любой другой DI-контейнер.
Следующий листинг демонстрирует, как сконфигурировать Autofac с помощью простых
Transient зависимостей аналогично примеру из листинга 7-9.
290
Листинг 8-3: Конфигурирование Autofac с помощью Transient зависимостеar builder = new ContainerBuilder();
builder.RegisterType<ContractMapper>()
.As<IContractMapper>();
builder.Register((c, p) =>
new SqlProductRepository(
ConfigurationManager
.ConnectionStrings["CommerceObjectContext"]
.ConnectionString))
.As<ProductRepository>();
builder.RegisterType<ProductManagementService>()
.As<IProductManagementService>();
var container = builder.Build();
Одной из особенностей Autofac является то, что вы не конфигурируете сам контейнер, онфигурируете ContainerBuilder и используете его для создания контейнера правершении конфигурации.
Самая простая форма регистрации – это когда вам нужно определить толькреобразование между абстракцией и конкретным типом, например, преобразование
IContractMapper в ContractMapper. Обратите внимание на то, что конкретный тип указаеред абстракцией, что является порядком, противоположным тому, которыспользуется большинством DI-контейнеров.
Несмотря на то, что Autofac так же, как и другие DI-контейнеры поддерживаевтоматическую интеграцию, внедрение таких примитивных типов, как строки, всегдредставляет собой особый случай, поскольку здесь может потенциально использоватьсножество различных строк. В данном случае вы имеете всего одну строку соединенияо вам нужно еще передать ее в SqlProductRepository, который вы на данный моменегистрируете. Вы можете сделать это с помощью лямбда-выражения, которое будеыполняться при запросе типа ProductRepository.
Использование лямбда-выраже ний – одна из заявок Autofac на успех. Несмотря на то, чтольшинство DI-контейнеров на данный момент обладают похожим свойством, Autofaыл одним из первых контейнеров, познакомивших нас с лямбда-выражениями. Вожете использовать лямбда, чтобы указать, как создается класс SqlProductRepository что еще более специфично, вы вытягиваете параметр конструктора connectionStrinз конфигурации приложения.
Преимущество использования лямбда-выражений заключается в том, что они безопаснтносительно типов, поэтому вы получаете статическую верификацию создания
SqlProductRepository. Недостаток – вы не получаете автоматическу ю интеграциюоэтому до тех пор, пока вам не нужно явно указывать параметр конструктораредпочтительнее всего является более простое преобразование с помощью
RegisterType. Это и есть то, как вы преобразуете IProductManagementService в
ProductManagementService, поэтому он может воспользоваться преимущество втоматической интеграции.
Теперь вы можете использовать экземпляр container для создания новых экземпляров
IProductManagementService, подобных следующему:
var service = container.Resolve<IProductManagementService>();
291
Но постойте, а что насчет управления жизненным циклом? Большинство DI-контейнеробладают стилем существования по умолчанию. В случае Autofac используемый пмолчанию стиль называется Per Dependency, что то же самое, что и стиль существования
Transient. Поскольку он является используемым по умолчанию, вам не нужно былказывать его, но если вы захотите, то можете сделать это следующим образом:
builder.RegisterType<ContractMapper>()
.As<IContractMapper>()
.InstancePerDependency();
Обратите внимание на то, что вы используете свободный интерфейс регистрации для тоготобы определить област ь применения экземпляра (термин Autofac используемый вместермина "стиль существования") при помощи метода InstancePerDependency.
Также существует Single Instance Scope (единичная область применения), котораоответствует стилю существования Singleton. Вооружившись этими знаниями, вы можетоздать Autofac – аналог листинга 8-2:
builder.RegisterType<ContractMapper>()
.As<IContractMapper>()
.SingleInstance();
builder.Register((c, p) =>
new SqlProductRepository(connectionString))
.As<ProductRepository>();
builder.RegisterType<ProductManagementService>()
.As<IProductManagementService>();
Вы хотите, чтобы ContractMapper имел стиль существования Singleton, поэтому впределяете это путем вызова метода SingleInstance. Когда дело касается
SqlProductRepository, все становится немного сложнее, поскольку экземпляр
SqlProductRepository должен быть Transient, но внедренная строка соединения должныть Singleton. Вы можете достичь этого, извлекая connectionString из конфигурацириложения (не продемонстрировано, но похоже на то, как это делалось ранее) спользуя эту внешнюю переменную в рамках замыкания (closure), которое врименяете для определения конструктора. Поскольку connectionString являетснешней переменной, она остается неизменной в рамках множества вызовоонструктора. Обратите внимание на то, как безоговорочно вы сделали и
SqlProductRepository, и ProductManagementService, не указывая при этом стилуществования.
Несмотря на то, что этот пример описывает, как определять стили существования омощью Autofac, другие DI-контейнеры имеют для той же цели приблизительно такое API.
Возможность точной настройки стиля существования каждой зависимости важна с точкрения представления, но также важна и с точки зрения функционально сти. Напримераттерн проектирования Mediator (Посредник) полагается на совместно используемыиректор, посредством которого взаимодейству ют несколько компонентов. Это работаеолько, когда Mediator совместно используется рассматриваемыми сотрудниками.
До настоящего момента мы обсуждали то, как инверсия управления намекает на то, чтотребители не могут управлять жизненными циклами своих зависимостей, посколькни, очевидно, не контролируют процесс создания объектов, и поскольку .NET использует
292
механизм сборки мусора (garbage collection) пользователи не могут явным образоничтожать объекты.
Таким образом, вопрос "а как насчет устраняемых зависимостей?" остается без ответа.
Сейчас мы обратим свой взор к этому деликатно му вопросу.
293
8.2. Работа с устраняемымависимостями
Несмотря на то, что .NET – это управляемая платформа, имеющая сборщик мусора, онсе еще может взаимодействовать с неуправляемым кодом (unmanaged code). Когда этроисходит, .NET код взаимодействуе т с неуправляемой памятью, которая нничтожается сборщиком мусора. Для предотвращения утечки памяти нам нужееханизм, с помощью которого мы бы детерминированно выпускали неуправляемуамять. Это и является ключевой целью интерфейса IDisposable.
Вероятнее всего, что некоторые реализации зависимостей будут содержать в себеуправляемые ресурсы. К примеру, ADO.NET связи являются устраняемыми, посколькни стремятся использовать неуправляемую память, поэтому реализации, связанные азами данных, например, репозитории, скорее всего, сами являются устраняемыми.
Как нам следует моделировать устраняемые зависимости? Должны ли мы также позволятбстракциям быть устраняемыми? Все это могло бы выглядеть так:
public interface IMyDependency : IDisposable { }
Технически это возможно, но не особенно предпочтительно, поскольку являетсримером smell(дурно пахнущее)-проектиро вания, который указывает на leaky-
абстракцию ("дырявую" абстракцию).
Интерфейс …, в больш инстве случаев, не должен быт ь устраняемым. Не сущ ест вуепособа, с помощью которого т от, кт о определяет инт ерфейс, смог бы предвидеть всозможные реализации эт ого интерфейса – вы всегда можете столкнуться страняемой реализацией практ ически любого инт ерфейса.
Николас Блумхардт, участник форума Common Context Adapters
Если вы стремитесь добавить IDisposable в ваш интерфейс, то это возможно, посколькы имеете ввиду конкретную реализацию. Но вы не должны использовать это знание прроектировании интерфейса. Все это усложнило бы реализацию интерфейса для другилассов и внесло бы в абстракцию неопределенность. Кто отвечает за уничтоженистраняемых зависимостей? Может ли за это отвечать потребитель?
Использование устраняемых зависимостей
В целях рассуждений представьте себе, что у нас есть устраняемая абстракция, подобнабстрактному классу OrderRepository:
public abstract class OrderRepository : IDisposable
Как класс OrderRepository должен взаимодейство вать с зависимостью? Большинствуководств по проектированию (включая FxCop и встроенный в Visual Studio Code
Analysis) настаивало бы на том, что, если бы класс содержал устраняемый ресурс ачестве члена класса, то он сам должен был бы реализовывать IDisposable збавляться от ресурса, подобного следующему:
294
protected virtual void Dispose(bool disposing)
{
if (disposing)
{
this.repository.Dispose();
}
}
Но, оказывается, что это совсем плохая идея, поскольку член repository был внедреервоначально, и он может совместно использоваться другими потребителями, как этродемонстрировано на рисунке 8-6.
Рисунок 8-6: Единичный экземпляр SqlOrderRepository внедряется и в OrderService,  SupplierReorderPolicy. Эти два экземпляра используют одну и ту же зависимость.
Если OrderService уничтожит свой внедренный OrderRepository, то он разрушиависимость SupplierReorderPolicy, и когда SupplierReorderPolicy попытаетсспользовать эту зависимость, возникнет исключение.
Было бы менее опасным не удалять внедренный репозиторий, но это означает, что мы, пуществу, игнорируем тот факт, что абстракция является устраняемой. Другими словамибъявление абстракции как унаследованной от IDisposable не приносит никакой пользы.
Кроме того, могут встречаться сценарии, в которых нам нужно сообщать о начале кончании краткосрочных областей применения, а IDisposable иногда используется длтой цели. Перед тем, как рассмотреть то, как Composer может управлять жизненныиклом устраняемой зависимости, нам следует обсудить то, как работать с такимедолговечными устраняемыми объектами.
Создание недолговечных устраняемых объектов
Многие API стандартной библиотеки классов .NET используют IDisposable, чтобообщить о том, что конкретная область применения перестала существовать. Одним иамых выдающихс я примеров является WCF-прокси.
WC F-прокси и IDisposable
Все авто-генерируемые WCF-прокси реализуют IDisposable, поэтому важно не забыватызывать метод Dispose (или Close) для прокси, как только это становится возможным.
Многие связывания при отправке первого запроса автоматически создают сессию длервиса, и эта сессия задерживается в сервисе до тех пор, пока не заканчивается ее времяли до тех пор, пока она явным образом не уничтожается.
Если мы забудем уничтожить наши WCF-прокси после использования, количество сессиудет увеличиваться до тех пор, пока мы не достигнем лимита одновременных
295
соединений из одного и того же источника. Когда мы достигнем лимита, возникнесключение. Слишком большое количество сессий также привносит в сервис лишнюагрузку, поэтому уничтожение WCF-прокси по мере возможности является оченажным.
Чтобы быть полностью технически корректными, нам не приходится вызывать метод
Dispose для WCF-прокси. Использование метода Close приведет к тому же самомезультату.
Важно не забывать, что при использования IDisposable для таких целей не нужнказывать leak-абстракцию, поскольку эти типы не всегда в первую очередь являютсбстракциями. С другой стороны, некоторые из них являются leak-абстракциями; а в такилучаях, как должны мы поступать с ними?
К счастью, после уничтожения объекта мы не можем его заново использовать. Этзначает, что если мы хотим вызвать то же самое API снова, мы должны создать новыкземпляр. К примеру, это хорошо подходит, когда мы используем WCF-прокси или
ADO.NET команды: мы создаем прокси, вызываем его операции и избавляемся от негоак только работа с ним завершается. Как мы можем совместить это с механизмонедрения зависимостей, если мы считаем, что устраняемые абстракции являются leak-
абстракциями?
Как и всегда может быть полезным скрытие ненужных деталей в интерфейсе. Если мбратимся к WPF приложению из раздела 7.4, то в данном случае мы спрятали WCF-
прокси в интерфейсе IProductManagementAgent.
Примечание
Интерфейс IProductManagementAgent наиболее значителен в листинге 7-10, но если нрать во внимание этот листинг, мы не рассматривали этот интерфейс подробно. В
сущности, такой агент занимает такое же самое место, как и репозиторий, но много леазад я приобрел привычку называть компоненты доступа к данным Smart Clientгентами, а не репозиториями.
С точки зрения MainViewModel ниже приведено то, как вы удаляете товар:
this.agent.DeleteProduct(productId);
Вы просите внедренный agent удалить товар. MainViewModel может безопасно хранитсылку на агента, поскольку интерфейс IProductManagementAgent не унаследован от
IDisposable.
При рассмотрении WCF реализации этого интерфейса формируется другая картина. Нижриведена реализация метода DeleteProduct:
public void DeleteProduct(int productId)
{
using (var channel = this.factory.CreateChannel())
{
channel.DeleteProduct(productId);
}
}
296
Класс WcfProductManagementAgent не является изменчивым, но имеет внедреннубстрактную фабрику, которую вы можете использовать для создания канала. Канал – этще одно слово для обозначения WCF-прокси, и это еще и авто-генерируемый клиентскинтерфейс, который вы получаете бесплатно, когда создаете ссылку на сервис с помощью
Visual Studio или svcutil.exe. Поскольку этот интерфейс унаследован от IDisposable, вожете завернуть его в оператор using.
Вы используете канал для удаления товара. Когда вы покидаете область применениsing, канал уничтожается.
Но постойте! Не утверждал ли я, что устраняемые абстракции являются leaky-
абстракциями? Да, утверждал, но мне приходится сопоставлять прагматические сущност принципами. В данном случае WcfProductManagementAgent, абстрактная фабрика
IProductChannelFactory и IProductManagementServiceChannel определены в одной ой же WCF-специфичной библиотеке, выделенной на рисунке 8-7.
Рисунок 8-7: Помимо других типов библиотека ProductWcfAgent содержит реализацию
IProductManagementAgent и поддерживаемые им типы. WcfProductManagementAgenспользует IProductChannelFactory для создания экземпляро в
IProductManagementServiceChannel, которые являются устраняемыми. Несмотря на тото они могут рассматриваться, как leak-абстракции, они не "протекают" слишком далекооскольку все потребители и реализаторы находятся в той же самой сборки.
Каждый раз при вызове метода для класса WcfProductManagementAgent оезамедлительно открывает новый канал и уничтожает его после использования. Егизненный цикл весьма краток, поэтому я называю такую устраняемую абстракциедолговечным устраняемым объектом.
Обратите внимание на то, что недолговечный устраняемый объект никогда не внедряетс потребителя. Вместо него внедряется абстрактная фабрика, и вы используете этабрику для того, чтобы контролировать жизненный цикл недолговечных устраняемыбъектов.
Обобщая все выше сказанное, устраняемые абстракции являются leaky-абстракциями.
Иногда мы должны принимать такую "протечку" для того, чтобы избежать багов
(например, отвергнутые WCF соединения); но если мы так поступаем, то можем сделатсе возможное, чтобы эта "протечка" не распространилась по всему приложению.
297
На данный момент мы рассмотрели то, как использовать устраняемые зависимости.
Давайте обратим наше внимание на то, как мы можем обслуживать их и управлять имместо потребителей.
Управление устраняемыми зависимостями
Поскольку я столь непреклонно настаиваю на том, что устраняемые абстракции являютсeaky-абстракциями, можно сделать вывод, что абстракции не должны бытстраняемыми. С другой стороны, реализации иногда бывают устраняемыми, и если ме уничтожим их правильно, в нашем приложении будет происходить утечка ресурсов.
Кто-то должен их удалять.
Подсказка
Старайтесь реализовывать сервисы так, чтобы они не содержали ссылок на устраняемыбъекты, а создавали и уничтожали их по требованию, как это проиллюстрировано нисунке 6-3. Это упрощает процесс управления памятью, поскольку сервис может бытничтожен сборщиком мусора наряду с другими объектами.
Как всегда данная ответственность ложится на Composer (например, DI-контейнер).
Composer лучше всех остальных знает, в какой момент он создает устраняемый экземпляроэтому он также знает, что этот экземпляр необходимо уничтожить. Для Composer прощранить ссылку на устраняемый экземпляр и вызывать его метод Dispose в подходящиомент.
Проблема заключается в определении подходящего времени для уничтожения. Как мзнаем, в какой момент все потребители вышли за рамки области применения?
До тех пор, пока кто-нибудь не скажет нам, что все потребители вышли за рамки областрименения, мы это не узнаем, но чаще всего наш код располагается внутри некоторогода контекста с вполне определенным жизненным циклом и событиями, которые ообщают нам, в какой момент завершается конкретная область применения. Таблица 8-1
демонстрирует области применения технологий, которые мы рассматривали в главе 7.
Таблица 8-1: Точки входа и выхода для различных .NET Framework'ов
Технолог Точка входа Точка выхода
Консольн
приложен
Main Main
ASP.NET
MVC
IControllerFactory.CreateControer IControllerFactory.ReleaseControer
WCF IInstanceProvider.GetInstance IInstanceProvider.ReleaseInstance
WPF Application.OnStartup Application.OnExit
ASP.NET Constructors**, Page_Load IDisposable.Dispose**, Page_Unload
PowerShell Constructors** IDisposable.Dispose**
298
Мы можем использовать различные точки выхода для того, чтобы сообщить Composerто ему необходимо уничтожить все зависимости данного объекта. Поэтому задачтслеживания таких зависимостей и их стилей существования, а также принятие решенио вопросу, должны ли те или иные зависимости высвобождаться, остается в компетенции
Composer.
Высвобождение зависимостей
Высвобождение диаграммы объектов – это не то же самое, что и ее уничтожение. Этигнал, сообщающий Composer, что центральная часть диаграммы выходит за рамкбласти применения, поэтому если сама центральная часть реализует IDisposable, то онолжна быть уничтожена. Но зависимости этой центральной части могут использоватьсакже и другими центральными частями, поэтому Composer может принять решение охранении некоторых из них, поскольку он знает, что другие объекты все ещолагаются на эти зависимости. Рисунок 8-8 иллюстрирует данную последовательностобытий.
Рисунок 8-8: Когда Composer получает запрос о преобразовании объекта, он собирает всависимости запрашиваемого объекта. В данном примере запрашиваемый объект имеери зависимости, и две из них являются устраняемыми. Одна из этих устраняемыависимостей также используется и другими потребителями, поэтому она являетсовторно используемой, тогда как остальные зависимости проиллюстрированы только дном месте. При получении запроса о высвобождении объекта Composer уничтожаериватную устраняемую зависимость и разрешает неустранимой зависимости и самомбъекту выйти за рамки области применения. Единственной взаимосвязью с повторнспользуемой зависимостью остается тот факт, что она внедрена в запрашиваемыбъект; но так как она является повторно используемой, она пока не уничтожается.
299
Чтобы высвободить зависимости, Composer должен отследить все устраняемыависимости, которые он когда-либо обслуживал, и тех потребителей, которыспользуют эти зависимости, таким образом, чтобы он мог уничтожить их, когда будеысвобожден последний потребитель.
Подсказка
Если вы когда-либо работали со счетчиками референсов (или имели опыт работы агами, являющимися следствием плохой реализации), то вы оцените, каким сложныожет быть процесс сохранения обозначений для всех зависимостей и их потребителей.
Это именно тот момент, когда вам может пригодиться DI-контейнер, поскольку он береаботу обо всем этом на себя. Используйте DI-контейнер, а не разрабатывайте свообственный код отслеживания жизненного цикла. Реализация процесса управлениизненным циклом DI-контейнером гарантированно является более протестированнойежели все то, что вы можете создать в пределах разумных временных рамок.
Давайте вернемся к примеру WCF сервиса из раздела "Управление жизненным циклом омощью контейнеров". Оказывается, в листинге 8-2 есть баг, потому что, каемонстрирует рисунок 8-9, SqlProductRepository реализует IDisposable.
Рисунок 8-9: SqlProductRepository реализует IDisposable, потому что содержистраняемый ресурс. Он также наследуется от абстрактного класса ProductRepositoryоторый не реализует IDisposable.
Код из листинга 8-2 создает новые экземпляры SqlProductRepository, но никогда нысвобождает эти экземпляры. Это будет приводить к утечке ресурсов, поэтому давайтстраним этот баг с помощью новой версии специализиро ванного контейнера.
Для начала учтите, что контейнер должен уметь обслуживать множество одновременныапросов, поэтому ему приходится связывать каждый экземпляр SqlProductRepository оздаваемым им IProductManagementService. Контейнер использует
Dictionary<IProductManagementService, SqlProductRepository>, называемыепозиториями, для того, чтобы отслеживать эти связи. Следующий листинемонстрирует, как контейнер преобразовывает запросы экземпляров
IProductManagementService.
Листинг 8-4: Связывание устраняемых зависимостей с разрешенной центральной частьublic IProductManagementService ResolveProductManagementService()
{
var repository = new SqlProductRepository(this.connectionString);
var srvc = new ProductManagementService(repository, this.mapper);
lock (this.syncRoot)
{
this.repositories.Add(srvc, repository);
}
return srvc;
}
300
Метод начинается с преобразования всех зависимостей. Оно аналогично реализации иистинга 8-2. Но перед тем как вернуть разрешенный сервис, контейнер должеспомнить связь между сервисом и репозиторием.
В WCF приложении присутствует только один экземпляр контейнера, и поскольку, скоресего, он будет получать одновременные запросы, вам необходимо заблокировать словареред тем, как добавить в него репозиторий. Добавление элементов в словарь не являетсолностью безопасной операцией, поэтому вам необходимо выполнить блокировку, чтоббедиться, что все репозитории сохранены для последующих даже внутреннидновременных вызовов.
Если вы обратитесь снова к листингу 7-7, вы заметите, что реализация IInstanceProvideже вызывает метод Release для контейнера. До настоящего момента вы неализовывали этот метод, полагаясь на то, что сборщик мусора выполнит эту работу, нля устраняемых зависимостей существенно, чтобы вы осознали эту возможностничтожения. Ниже приведена эта реализация.
Листинг 8-5: Высвобождение устраняемых зависимостей
1. public void Release(object instance)
2. {
3. var srvc = instance as IProductManagementService;
4. if (srvc == null)
5. {
6. return;
7. }
8. lock (this.syncRoot)
9. {
10. SqlProductRepository repository;
11. if (this.repositories.TryGetValue(srvc, out repository))
12. {
13. repository.Dispose();
14. this.repositories.Remove(srvc);
15. }
16. }
17. }
Строка 13: Уничтожает репозиторий
Строка 14: Удаляет репозиторий из словаря
Поскольку метод Release принимает любые типы объектов, вам для начала потребуетсраничный оператор (Guard Clause), чтобы убедиться, что instance является
IProductManagementService.
Параллельные цепочки могут вызывать метод Release одновременно, поэтому вы должнще раз сериализовать обращение к словарю repositories, чтобы убедиться в том, чтараллельные цепочки не искажают состояние этого словаря. Если бы репозитории ныли удалены из словаря, то это могло бы привести к утечке памяти.
Переменная srvc выступает в роли ключа к словарю, поэтому вы можете использовать еля поиска устраняемой зависимости. Когда вы найдете такую зависимость, вы можетничтожить ее и удалить из словаря, чтобы удостовериться в том, что контейнер нставляет ее "живой".
301
Примеры, продемонстрированные в листингах 8-4 и 8-5, используются специально длаботы с одной конкретной устраняемой зависимостью: SqlProductRepository. Довольнанально было бы, если бы мы расширили код для того, чтобы иметь возможностаботать с зависимостями любого вида, но после этого ситуация усложнилась бы.
Представьте, что вам приходится работать с многочисленными устраняемымависимостями одного и того же объекта, или вложенными устраняемыми зависимостямиричем часть из них должны быть Singleton'ами, а некоторые должны быть Transient – то мы еще даже не начинали обсуждать более сложные стили существования!
Подсказка
Окажите себе самому услугу и воспользуйтесь DI-контейнером вместо того, чтобытаться решить все эти проблемы в пользовательском коде. Единственная причинаочему я привожу этот пользовательский код, – объяснить принципы управлениизненным циклом.
DI-контейнеры могут работать со сложными сочетаниями стилей существования, редлагают возможности (например, метод Release) для явного высвобождениомпонентов после завершения работы с ними. Мы должны не забывать использовать этетоды для того, чтобы избежать утечки памяти, особенно в тех случаях, когда одна илолее одной зависимости из сконфигурированных являются устраняемыми.
На данный момент мы обсудили в некоторых подробностях механизм управлениизненным циклом. Будучи потребителями, мы не можем управлять жизненным циклонедренных зависимостей; эта ответственность ложится на плечи Composer, которыожет выбрать между двумя вариантами: разделить один экземпляр между многимотребителями или наделить каждого потребителя своим собственным приватныкземпляром. Эти Singleton и Transient стили существования являются всего лишь самымниверсальными представителями огромного набора стилей существования, ставшуюся часть главы мы будем использовать для рассмотрения каталога стратегиизненного цикла.
302
8.3. Каталог стилей существованибъектов
Теперь, когда в предыдущих разделах мы рассмотрели принципы, лежащие в основеханизма управления жизненным циклом, мы потратим оставшуюся часть главы нассмотрение паттернов универсальных стилей существования.
Примечание
Я буду использовать аналогичные примеры в рамках всего раздела. Но для того чтобозволить нам с вами сконцентрироваться на самых главных моментах, я буду составлятоверхностные иерархии и иногда игнорировать проблему, связанную с устраняемымависимостями, для того, чтобы избежать этой дополнительно й сложности.
Поскольку вы уже сталкивались и с Singleton, и с T ransient, мы начнем с этих стилеуществования, а затем раскроем остальные типы. По мере того, как мы будеродвигаться по этим стилям существования, мы будем переходить от общепринятытилей существования к более экзотичным, как это описано в таблице 8-2.
Таблица 8-2: Паттерны стилей существования, рассматриваемые в данном разделе
Название Описание
Singleton Один экземпляр постоянно повторно используется
Transient Всегда используются новые экземпляры
Per Graph Один экземпляр повторно используется в пределах каждой диаграммбъектов
Web Request
Context
В большинстве случаев для одного веб-запроса используется одикземпляр каждого типа
Pooled Используются экземпляры из пула готовых объектов
Lazy Зависимость, требующая больших затрат, создается и используется амедленно м темпе
Future Зависимость станет доступна в будущем
Несмотря на то, что вы можете использовать такие стили существования, как Pooledовольно редко, хорошо бы о них все-таки знать, а этот список должен дать вам хорошередставление о широком ряде доступных стилей существования. По сравнению с болеложными стилями существования, Singleton может казаться более приземленным, но онем не менее, является универсальной и уместной стратегией жизненного цикла.
Singleton
В этой книге мы время от времени косвенным образом использовали стиль существования
Singleton. Его название одновременно является и достаточно понятным, и несколькапутанным. Оно имеет множество смыслов, поскольку результирующее поведениохоже на паттерн проектирования Singleton, но структура отличается.
303
Предупреждение
Не путайте стиль существования Singleton с паттерном проектирования Singleton.
В пределах области применения одного Composer компонент со стилем существования
Singleton ведет себя приблизительно как Singleton. Всякий раз, когда потребителыполняет запрос компонента, используется один и тот же экземпляр.
Но на этом схожесть заканчивается. Потребитель не может обратиться к зависимости с
Singleton областью применения посредством статического члена, и если мы просим двазных Composer'а передать нам экземпляр, то мы получим два разных экземпляра.
Подсказка
Используйте стиль существования Singleton всякий раз, когда это можно сделать.
Поскольку используется только один экземпляр, стиль существования Singleton сновном потребляет минимальное количество памяти. Единственный момент, когда тае происходит, – это когда экземпляр редко используется, но потребляет чрезмернооличество памяти. В таких случаях стиль существования Lazy с примыкающикземпляром Transient может стать наилучшей конфигурацией (но я долго пытался найтазумные примеры таких ситуаций).
Когда использовать Singleton
При возможности используйте стиль существования Singleton. Главной проблемойоторая может не дать вам использовать Singleton, может стать то, что компоненвляется потоко-безопасным. Поскольку экземпляр Singleton используется совместнотенциально большим количеством потребителей, он должен уметь управлятдновременными обращениями.
Все сервисы, которые не сохраняют свое состояние, по определению являются потоко-
безопасными, как и неизменные типы, и очевидные классы, специально созданныотоко-безопасными. В таких случаях нет причины не делать их Singleton'ами.
Вдобавок к аргументу об эффективности, некоторые зависимости могут работать так, като было задумано, только если они используются кем-то совместно. Например, этасается реализаций паттерна проектирования Circuit Breaker, а также кэшей оперативноамяти. В этих случаях то, что реализации являются потоко-безопасными, как раз-такущественно.
Давайте поближе рассмотрим репозиторий, находящийся в оперативной памяти.
Пример: Использование потоко-безопасного репозитория, находящегося перативной памяти
Давайте еще раз обратим наше внимание на реализацию ICommerceServiceContaineаким образом, как это описано в разделах "Пример: подключение сервиса управлениродуктами", "Управление жизненным циклом с помощью контейнера" и "Управленистраняемыми зависимостями". Вместо использования ProductRepositoryазирующегося на SQL Server, мы могли бы решить, использовать потоко-безопаснуеализацию в оперативной памяти. Для того чтобы хранилище данных, находящееся в
304
оперативной памяти, имело какой-либо смысл, оно должно совместно использоватьссеми запросами, поэтому оно должно быть потоко-безопасным, как этроиллюстрировано на рисунке 8-10.
Рисунок 8-10: Когда составные экземпляры ProductManagementService, идущитдельными потоками, обращаются к совместно используемому ресурсу, напримераходящемуся в оперативной памяти ProductRepository, мы должны убедиться, чтовместно используемый ресурс является потоко-безопасным.
Вместо явной реализации такого репозитория, как Singleton, мы можем использоватонкретный класс и соответствующим образом его ограничить. Единственное требование
– он должен быть потоко-безопасным.
Листинг 8-6 демонстрирует, как контейнер может возвращать новые экземпляры всякиаз, когда его просят разрешить IProductManagementService, в то время, как
ProductRepository используется всеми экземплярами совместно.
Листинг 8-6: Управление Singleton'ами
1. public class SingletonContainer : ICommerceServiceContainer
2. {
3. private readonly ProductRepository repository;
4. private readonly IContractMapper mapper;
5. public SingletonContainer()
6. {
7. this.repository =
8. new InMemoryProductRepository();
9. this.mapper = new ContractMapper();
10. }
11. public IProductManagementService
12. ResolveProductManagementService()
13. {
14. return new ProductManagementService(
15. this.repository, this.mapper);
16. }
17. public void Release(object instance) { }
18. }
305
Строка 3-4: Экземпляр ы Singleton
Строка 7-9: Создает Singleton'ы
Строка 14-15: Создает сервис
Строка 17: Ничего не делает
Жизненный цикл Singleton довольно легко реализовать: вы храните ссылку на каждуависимость на протяжении всего жизненного цикла контейнера. Обратите внимание но, что вы используете ключевое слово readonly, чтобы убедиться, что вы не можетлучайно изменить ссылки поздней датой. Строгой необходимости в этом для реализацитиля существования Singleton нет, но это обеспечивает некоторую дополнительну езопасность, цена которой – написание восьми букв.
Всякий раз, когда контейнер просят разрешить экземпляр IProductManagementServiceн создает Transient экземпляр с внедренными в него Singleton'ами. В данном примере epository, и mapper являются Singleton'ами, но при желании вы можете смешиваттили существования.
Стиль существования Singleton – один из самых простых для реализации стилей. Все, чтля него нужно, – хранить ссылку на объект и использовать этот же объект каждый разогда его запрашивают. Экземпляр не выходит за рамки области применения до тех порока не выйдет за рамки области применения Composer. Когда это происходит, Composeолжен избавиться от объекта, если он принадлежит к устраняемому типу.
Еще одним простым для реализации стилем существования является стиль Transient.
Transient
Стиль существования Transient включает в себя возврат нового экземпляра всякий разогда этот экземпляр запрашивается. До тех пор пока возвращаемый экземпляр неализует IDisposable, следить не за чем. Наоборот, когда экземпляр реализует
IDisposable, Composer должен иметь его ввиду и явным образом избавляться от негоогда его просят высвободить подходящую диаграмму объектов.
Стоит заметить, что в настольных и простых приложениях мы стремимся разрешатолноценную иерархию объектов всего единожды: при запуске приложения. Это означаетаже для Transient компонентов, что будет создано только несколько экземпляров, и чтни могут существовать длительно е время. В худшем случае, когда на одну зависимостриходится только один потребитель, конечный результат разрешения диаграммстинных Transient компонентов эквивалентен разрешению диаграммы истинных
Singleton'ов или любого их сочетания. Это все потому, что диаграмма разрешается всегишь раз, поэтому разницы в поведении никогда не возникает.
Когда использовать Transie nt
Стиль существования Transient – самый безопасный из всех стилей существования, но в те время и один из самых не эффективных, поскольку он может привести к тому, чтудет создано и уничтожено сборщиком мусора бесчисленное множество экземпляров, о время как одного экземпляра было бы достаточно. Но если вы сомневаетесь насчет
306
потоковой безопасности компонента, стиль существования Transient безопасен, посколькаждый потребитель имеет свой собственный экземпляр зависимости.
В большинстве случаев мы можем безопасно менять стиль существования Transient накой контекстно-ограниченный стиль существования, как Web Request Context, отором доступ к зависимости также гарантированно сериализируется, но это зависит ореды выполнения (использование Web Request Context в настольных приложениях нмеет смысла).
Пример: разрешение разнообразных репозиториев
Ранее в этой главе вы видели несколько примеров использования стиля существования
Transient. В листинге 8-2 repository создается и внедряется в методе, выполняюще азрешение, а контейнер не содержит ссылок на него. Затем в листингах 8-4 и 8-5 ввидели, как работать с устраняемым Transient компонентом.
В этих примерах вы могли заметить, что mapper повсюду остается Singleton'ом. Этстинный, не сохраняющий свое состояние сервис, поэтому нет необходимости создаватовый экземпляр для каждого вновь созданного ProductManagementService. Чтействительно заслуживает внимания, так этот тот факт, что вы можете сочетатависимости с различными стилями существования.
Когда разнообразным компонентам нужна одна и та же зависимость, каждый из этиомпонентов получает отдельный экземпляр этой зависимости. Следующий листинемонстрирует метод, который выполняет разрешение ASP.NET MVC контроллера.
Листинг 8-7: Разрешение Transient DiscountRepositorys
1. public IController ResolveHomeController()
2. {
3. var connStr = ConfigurationManager
4. .ConnectionStrings["CommerceObjectContext"]
5. .ConnectionString;
6. var discountCampaign =
7. new DiscountCampaign(
8. new SqlDiscountRepository(connStr));
9. var discountPolicy =
10. new RepositoryBasketDiscountPolicy(
11. new SqlDiscountRepository(connStr));
12. return new HomeController(
13. discountCampaign, discountPolicy);
14. }
Строка 8: Новый экземпляр SqlDiscountRepository
Строка 11: Еще один экземпляр SqlDiscountRepository
Как для класса DiscountCampaign, так и для класса RepositoryBasketDiscountPolicужна зависимость DiscountRepository. В случае, когда DiscountRepository является
Transient, каждый потребитель получает свой собственный приватный экземпляр, поэтому
DiscountCampaign получает один экземпляр, а RepositoryBasketDiscountPolicy –
другой.
Стиль существования Transient означает, что каждый потребитель получает приватныкземпляр зависимости даже в тех случаях, когда разнообразные потребители в одной и
307
той же диаграмме объектов обладают одной и той же зависимостью (как в случае истингом 8-7). Если множество потребителей совместно используют одну и ту жависимость, то данный подход будет неэффективным, но если реализация являетсотоко-безопасной, то в этом случае наиболее эффективный стиль существования
Singleton не подходит. В таких ситуациях может больше подойти стиль существования Per
Graph.
Per Graph
Singleton – это наиболее эффективный стиль существования, а Transient – самыезопасный, но можем ли мы разработать такой стиль существования, который сочетал б себе преимущества этих двух стилей? Несмотря на то, что мы не можем получить самоучшее от этих двух стилей, в некоторых случаях имеет смысл распределить единичныкземпляр по всей единичной разрешенной диаграмме. Мы можем рассматривать это, каекоторого рода локально-ограниченный Singleton. Мы можем использовать общикземпляр в рамках единичной диаграммы объектов, но не разделяем этот экземпляр ругими диаграммами.
Каждый раз при разрешении диаграммы объектов мы создаем только один экземпляаждой зависимости. Если эта зависимость используется несколькими потребителями, оназделяют между собой один и тот же экземпляр; но при разрешении новой диаграммбъектов мы создаем новый экземпляр.
Когда использовать Per Graph
В большинстве случаев мы можем использовать стиль существования Per Graph там, гдогли бы использовать и Transient. Обычно мы допускаем, что поток, разрешающииаграмму объектов, также является единственным потребителем этой диаграммбъектов. Даже когда рассматриваемая зависимость не является потоко-безопасной, можем использовать стиль существования Per Graph, поскольку общий экземпляовместно используется только потребителями, которые проходят по одному и тому жотоку.
В редких случаях, когда один или более одного потребителя проносятся по новыотокам и используют зависимость из этих потоков, Transient все еще остается самыезопасным стилем существования, но такое случается редко. Могут встречаться и такиитуации, когда зависимость представляет собой изменчивый ресурс, а для каждоготребителя необходимо его собственное приватное состояние. В этом случае Transienудет корректным жизненным циклом, поскольку он дает гарантию того, что экземплярикогда не будут использоваться коллективно.
По сравнению с Transient, при использовании Per Graph не возникает никакиополнительных издержек, поэтому мы часто можем использовать его в качестве замены
Transient. Несмотря на то, что издержки отсутствуют, нам также не гарантировано акое-либо преимущество. Мы получаем только некоторое усиление эффективности лучае, если диаграмма единичного объекта содержит многочисленных потребителедной и той же зависимости. В этом случае мы можем разделить экземпляр между этимотребителями; но если совместно используемые зависимости отсутствуют, то будеечего делить, и поэтому не будет никаких преимуществ.
308
Примечание
В большинстве случаев Per Graph лучше Transient, но не многие DI-контейнеры егоддерживают.
В случаях, когда реализация является потоко-безопасной, наиболее эффективныариантом все еще остается стиль существования Singleton.
Пример: Совместное использование Repository в рамках диаграммы
В листинге 8-7 вы видели, как каждый потребитель получал свой собственный приватныкземпляр SqlDiscountRepository. Этот класс не является потоко-безопасным, поэтомам не следует конфигурировать его в виде Singleton. Но вы не рассчитываете на то, чтазнообразные потоки будут обращаться к индивидуальным экземплярам
HomeController, поэтому разделение экземпляра SqlDiscountRepository между двумотребителями будет безопасным. Следующий листинг демонстрирует, как создатдиничный экземпляр Per Graph в методе ResolveHomeController.
Листинг 8-8: Разрешение единичного per graph repository
1. public IController ResolveHomeController()
2. {
3. var connStr = ConfigurationManager
4. .ConnectionStrings["CommerceObjectContext"]
5. .ConnectionString;
6. var repository =
7. new SqlDiscountRepository(connStr);
8. var discountCampaign =
9. new DiscountCampaign(repository);
10. var discountPolicy =
11. new RepositoryBasketDiscountPolicy(repository);
12. return new HomeController(discountCampaign, discountPolicy);
13. }
Строка 6-7: Совместно используемый экземпляр SqlDiscountRepository
Строка 8-11: Внедрение совместно используемого экземпляра
Вместо того чтобы создавать отдельные экземпляр ы для всех потребителей, вы создаетдин экземпляр, который можете разделить между всеми потребителями. Вы внедряеттот единственный экземпляр как в DiscountCampaign, так и в
RepositoryBasketDiscountPolicy. Обратите внимание на то, что по сравнению с
Singleton'ами, в которых совместно используемый экземпляр является приватным членоонтейнера, экземпляр repository является локальным по отношению к методу
ResolveHomeController; при следующем вызове метода будет создан новый экземпляр, атем он будет разделен между двумя потребителями.
Стиль существования Per Graph является хорошей альтернативой стилю Transient в телучаях, когда единственной причиной отказа от использования Singleton является тоакт, что реализация не потоко-безопасна. Несмотря на то, что Per Graph предлагает елом удобное решение для разделения зависимостей в рамках четко определенныраниц, существуют другие, более специализиро ванные альтернативы.
309
Web Request Context
Как пользователям приложения нам хотелось бы получать ответ от этого приложения каожно быстрее, даже в тех случаях, когда в это же самое время оно используется ругими пользователями. Нам бы не хотелось, чтобы наш запрос был поставлен в очередаряду с запросами всех остальных пользователей. Возможно, нам пришлось брезмерно долго ждать ответа, если бы перед нашим запросом было бы много другиапросов.
Чтобы решить эту проблему, веб-приложения управляют запросами одновременно. .NET
инфраструктура защищает нас от этого, позволяя каждому запросу выполняться в своеобственном контексте и со своим собственным экземпляром Controller (если вспользуете ASP.NET MVC) или Page (если вы используете ASP.NET Web Forms).
В связи с параллельным выполнением зависимости, которые не являются потоко-
безопасными, не могут использоваться как Singleton'ы. С другой стороны, использованих в виде Transient может быть неээфективным или даже совершенно проблематичным ех случаях, если нам нужно разделить зависимость между различными потребителями амках одного и того же запроса.
Несмотря на то, что ASP.NET движок не гарантирует, что один запрос будет выполнятьссключительно в одном потоке, он гарантирует, что код выполняется последовательно.
Это означает, что если мы хотим разделить зависимость только в рамках одного запросао потоко-безопасность в данном случае не является проблемой.
Рисунок 8-11 демонстрирует, как работает стиль существования Web Request Context.
Зависимости ведут себя как Singleton'ы в пределах одного запроса, но не разделены междапросами. Каждый запрос имеет свой собственный набор связанных зависимостей.
Рисунок 8-11: Стиль существования Web Request Context указывает на то, что мы создаее более одного экземпляра на один запрос. Экземпляр DiscountRepository совместнспользуется BasketDiscountPolicy и DiscountCampaign, но только в рамках запроса 1.
Запрос 2 использует ту же самую конфигурацию, но экземпляр ы ограничены этиапросом.
Любые устраняемые компоненты должны быть уничтожены после окончания запроса.
Когда использовать Web Request Context
Очевидно, что стиль существования Web Request Context имеет смысл только в веб-
приложении. Даже в пределах веб-приложения он может быть использован только в
310
запросах. Несмотря на то, что запросы составляют большую часть веб-приложения, стоитметить, что если мы проносимся по исходному потоку с целью асинхронной обработкио этот стиль существования не применим, поскольку исходный поток не будеинхронизироваться с веб-запросом.
Стиль существования Web Request Context предпочтительнее Transient, но стилуществования Singleton все еще более эффективен. Используйте Web Request Contexолько в тех ситуациях, в которых Singleton не работает.
Примечание
Если вы следуете общему совету разрешать только одну диаграмму объектов для одногеб-запроса, то стили существования Web Request Context и Per Graph функциональнквивалентны.
Подсказка
Если вам когда-нибудь понадобится сформировать в веб-запросе Entity Framework
ObjectContext, то самый лучший для этого стиль существования – Web Request Context.
Экземпляры ObjectContext не являются потоко-безопасными, но в данном случае ндин веб-запрос должен быть только один ObjectContext.
Не все DI-контейнеры поддерживают данный стиль существования, поэтому очевидно можем использовать его только, если он доступен.
Подсказка
Некоторые DI-контейнеры позволяют вам создавать свои собственные расширения стилеуществования, поэтому, возможно, это вариант в тех случаях, если выбранный вамонтейнер не поддерживает стиль существования Web Request Context. К тому же этожет быть не тривиальной затеей.
Что касается других стилей существования, то мы можем сочетать стили существованияапример, таким образом, что некоторые из них конфигурируются как Singleton'ы, ругие совместно используются в рамках веб-запросов.
Пример: компоновка HomeController с Repository, разделенным между веб-
запросами
В данном примере вы увидите, как компоновать ASP.NET MVC экземпляр
HomeController с зависимостями, если для двух этих зависимостей необходим
DiscountRepository. Эта ситуация обрисована на рисунке 8-11: для HomeControlleужны BasketDiscountPolicy и DiscountCampaign, а для этих двух зависимостей, в свочередь, нужен DiscountRepository.
Примечание
Шаблонный код данного раздела сложнее того, что гарантируется одноразовыешением. Я не думаю, что вам когда-нибудь придется писать пользовательский код
311
жизненного цикла Web Request Context, подобный данному, но мне хочется показать вамак он работает. Вместо написания такого кода используйте DI-контейнер, которыоддерживает этот стиль существования.
Вам хотелось бы использовать совместный SqlDiscountRepository, но так как этот класе является потоко-безопасным, вы не можете коллективно использовать его в качестве
Singleton. Вместо этого вы будете использовать его совместно в рамках каждого веб-
запроса. Специализированный контейнер компонует экземпляры HomeController так, като продемонстрировано в следующем листинге.
Листинг 8-9: Компоновка HomeController
1. public IController ResolveHomeController()
2. {
3. var discountPolicy =
4. new RepositoryBasketDiscountPolicy(
5. this.ResolveDiscountRepository());
6. var campaign = new DiscountCampaign(
7. this.ResolveDiscountRepository());
8. return new HomeController(
9. campaign, discountPolicy);
10. }
Строка 5,7: Делегирует резолюцию репозитория
Строка 8-9: Возвращает сформированный HomeController
На данный момент с большинством операторов этого метода вы должны быть ужнакомы. Единственное, что стоит отметить, – это то, что вы делегируете резолюцию
DiscountRepository отдельному методу. Данный метод гарантирует, что на один веб-
запрос разрешается хотя бы один экземпляр.
При запросе разрешения DiscountRepository контейнер должен проверить, существуеи уже экземпляр, связанный с веб-запросом. Если он существует, то возвращаетсанный экземпляр; иначе экземпляр создается и связывается с веб-запросом перед темак будет возвращен. Как показывает следующий листинг, в ASP.NET (как в MVC, так и в
Web Forms) вы можете использовать текущий HttpContext для поддержания этой связи аботоспособном состоянии.
Листинг 8-10: Разрешение зависимости, ограниченной контекстом веб-запроса
1. protected virtual DiscountRepository ResolveDiscountRepository()
2. {
3. var repository = HttpContext.Current
4. .Items["DiscountRepository"]
5. as DiscountRepository;
6. if (repository == null)
7. {
8. var connStr = ConfigurationManager
9. .ConnectionStrings["CommerceObjectContext"]
10. .ConnectionString;
11. repository = new SqlDiscountRepository(connStr);
12. HttpContext.Current
13. .Items["DiscountRepository"] = repository;
14. }
15. return repository;
16. }
312
Строка 3-5: Выполняет поиск репозитория в контексте запроса
Строка 12-13: Сохраняет репозиторий в контексте запроса
Особенностью стиля существования Web Request Context является повторноспользование экземпляров уже связанных с текущим запросом, поэтому первое, чтеобходимо сделать, – проверить, существует ли уже необходимый экземпляр. Если оуществует, то вы можете его вернуть. Если экземпляр не найден, то вы должны создатго и связать с текущим веб-запросом перед тем, как вернуть этот экземпляр.
При первом вызове метода ResolveDiscountRepository он создает репозиторий вязывает его с запросом таким образом, чтобы каждый последующий вызов повторнспользовал один и тот же экземпляр.
При завершении запроса вы могли бы оставить устраняемую зависимость в веб-запросето привело бы к утечке памяти, поэтому при завершении запроса вы должны убедитьсще и в том, что все зависимости высвобождены. Один из способов осуществления этого –
зарегистрировать пользовательский IHttpModule, который присоединяется к событию
EndRequest для того, чтобы надлежащим образом уничтожить все устраняемыависимости. В следующем листинге продемонстрирован пример реализации.
Листинг 8-11: Высвобождение устраняемых зависимостей, ограниченных контекстоеб-запроса
1. public class DiscountRepositoryLifestyleModule : IHttpModule
2. {
3. public void Init(HttpApplication context)
4. {
5. context.EndRequest += this.OnEndRequest;
6. }
7. public void Dispose() { }
8. private void OnEndRequest(object sender, EventArgs e)
9. {
10. var repository = HttpContext.Current
11. .Items["DiscountRepository"];
12. if (repository == null)
13. {
14. return;
15. }
16. var disposable = repository as IDisposable;
17. if (disposable != null)
18. {
19. disposable.Dispose();
20. }
21. HttpContext.Current
22. .Items.Remove("DiscountRepository");
23. }
24. }
Строка 10-11: Выполняет поиск репозитория в контексте запроса
Строка 16-20: Уничтожает репозиторий
Строка 21-22: Удаляет репозиторий из контекста запроса
При завершении веб-запроса вы предпринимаете попытку поиска репозитория в контекстапроса. При обнаружении репозитория вы можете уничтожить его, если это можно
313
сделать. Независимо от того, является ли этот репозиторий устраняемым или нет, волжны не забыть удалить его из контекста запроса.
Стиль существования Web Request Context связывает зависимость с текущим запросомохраняя и извлекая этот запрос посредством HttpContext.Current. Данный примеродемонстрировал специализированное решение, но методика может быть обобщенаким образом, чтобы произвольное количество зависимостей множества различныипов можно было связывать с контекстом запроса. Это относится к сфероответствующего DI-контейнера.
Вариация: Session Request C ontext
Редко встречающейся вариацией стиля существования Web Request Context являетстиль существования, при котором область применения жизненного цикла зависимостевязана не с конкретным запросом, а с сессией. Это намного более экзотичный стилуществования, и если вы решите его использовать, то вам следует делать это резвычайной осторожностью.
С технической точки зрения может показаться, что он похож на Web Request Context, наиболее важное отличие заключается в том, что, несмотря на то, что HTTP-запрос имееполне определенный жизненный цикл, сессии не обладают таким определенныизненным циклом. Сессия в редких случаях заканчивается явным образом, а чаще всегавершается после некоторого периода бездействия. Это означает, что все зависимостиарегистрированные данным образом, вероятнее всего, длительное время сохраняютсам, где они не используются. Все это время они занимают память, что может сильновлиять на производительность приложения.
Предупреждение
Используйте стиль существования Session Request Context только, если он ваействительно необходим. Вероятнее всего, использование данного стиля понизироизводительно сть вашей системы.
Подсказка
Если вам нужно привязать некие зависимости к сессии, то вам лучше сконфигурироватх с помощью Web Request Context и посредством фабрики, которая присоединяеаждый экземпляр на основании соответствующего ключа сессии. Данный подхоозволяет вам более явным образом управлять жизненным циклом зависимости, несмотра то, что она все еще связана с сессией.
Еще одна проблема, с которой мы сталкиваемся, – это то, что состояние сессии можеыть сохранено во внешнем хранилище, например на отдельном сервере сессий или на
SQL Server session state. При таких конфигурациях должны быть сериализованы всанные сессии, а также зависимости, на которые оказывается влияние. Сериализация типожет быть так же проста, как и наделение этого типа атрибутом [Serializable], нуществует еще кое-что, что мы должны не забыть сделать.
В целом, я считаю Session Request Context непривлекательным и не припомню, чтобогда-либо видел, как он используется.
314
Вариация: Thread C ontext
Еще одна, более привлекательная вариация стиля существования Web Request Context, –
это ассоциирование зависимости с конкретным потоком. Сущность остается той же: аждом потоке управление зависимостью ведется как с Singleton, но для каждого потокуществует свой экземпляр зависимости.
Данный подход наиболее полезен в сценариях, при которых мы проносимся пногочисленным эквивалентным рабочим потокам и используем начало каждого потока ачестве Composition Root. Эта ситуация проиллюстрирована на рисунке 8-12.
Рисунок 8-12: Когда приложение незамедлительно проносится по некоторому количествараллельных задач и разрешает зависимости в рамках каждого потока, мы можеспользовать стиль существования Thread Context для того, чтобы убедиться, что любыависимости, не являющиеся потоко-безопасными, могут быть разделены между любыоличеством потребителей одного и того же потока. Каждый поток имеет свообственные экземпляры.
Чтобы реализовать стиль существования Thread Context, мы можем поискатапрашиваему ю зависимость в Thread Local Storage (TLS). Если мы ее там обнаружим, тожем повторно ее использовать; иначе, мы создаем эту зависимость и сохраняем ее в
TLS.
Между тем, как Session Request Context может быть совершенно опасным, а Thread
Context – слегка экзотичным, стиль существования Web Request Context полезен. Оозволяет нам разделять зависимости в пределах веб-запроса, не беспокоясь при этом ом, являются ли они потоко-безопасными. Web Request Context – это нечто среднеежду Singleton и Transient.
Web Request Context является более эффективной альтернативой стиля существования
Transient, но мы можем использовать его только в веб-приложениях. Если мы имееависимости, для управления которыми требуются большие затраты, в других типариложений, то мы можем обратиться к другим возможностям оптимизации.
Pooled
Иногда для создания компонентов необходимы большие затраты. Универсально е решенитой проблемы – возможность легкого доступа к пулу уже созданных компонентов.
Хорошо известный пример – подключения баз данных, которые практически всегдаходятся в пуле. Мы автоматически применяем организацию пулов подключений баанных, и можем использовать ту же самую технологию, если у нас есть пользовательскиомпоненты, создание которых требует больших затрат.
315
Несмотря на то, что общая концепция объектов в пуле должна быть вам знакома, аблице 8-3 перечислены некоторые вариации реализации.
Таблица 8-3: Варианты реализации пулов объектов
Вариант Описание
Подготовка пула
Как мы подготавливаем пул? Создаем ли мы все объекты в пуларанее или наполняем его постепенно по мере поступлениапросов?
Для того чтобы заполнить пул заранее, необходимо, чтобы мнали, по крайней мере, первоначальный размер пула.
Возможно это тоже затратная операция, поскольку целью пулвляется обеспечение легкого доступа к объектам, требующиольших затрат. Но преимущество такого подхода заключается ом, что объекты становятся доступными для быстрого доступа.
Может быть, есть возможность предварительно заполнить пул исходного потока таким образом, чтобы он мог начать бытолезным объектам во время его наполнения.
В противном случае мы можем начать с пустого пула и заполнятго постепенно по необходимости. Это приводит к тому, что ачале время доступа замедляется, но такой подход может помочранить пул в нужном размере.
Минимальный размер
Мы можем решить проблему подготовки пула путем вводастраиваемого минимального размера. Если мы задаеинимальный размер, отличающийся от нуля, то перед тем, кабъекты смогут его использовать, пул должен заполниться дтого размера. С другой стороны, при минимальном размереавном нулю, объекты могут начать использовать его, как толькн начнет заполняться.
Максимальныазмер Каков максимальный размер пула?
Поведение пула простижениаксимальногазмера
Что происходит, когда мы достигаем максимального размера пула?
Позволяем ли мы пулу вырасти в размере? Если мы позволим емто сделать, то мы рискуем попасть в ситуацию, когда у наакончится память. Если не позволим, то, как, в таком случае, молжны обрабатывать дополнительные запросы объектов?
Один из вариантов – заблокировать вызов до тех пор, пока объеке станет доступным. Но если мы это сделаем, то мы должны, прайней мере, предоставить вызывающему оператору возможностказания задержки.
Еще один вариант – незамедлительно выдавать исключение.
Очистка пула
Сохраняем ли мы пул заполненным до того момента, кариложение начнет закрываться, или же мы начинаем очищать егосли замечаем, что он начинает превышать свой размер?
316
В таблице представлены все важные концепции, касающиеся пулов объектов. Но как лучае со стилем существования Web Request Context нам не следует разрабатывать свообственные пользовательские пулы объектов, а следует использовать те, которыредоставляются DI-контейнерами.
Примечание
Не все DI-контейнеры предоставляют стиль существования Pooled, поэтому очевидно, чты можем выбрать этот стиль существования только, если он поддерживается нашим DI-
контейнером.
При использовании стиля существования Pooled, предоставляемого DI-контейнером, всарианты, описанные в таблице 8-3, могут быть недоступны. Нам придется работатолько с тем, что доступно.
Когда использовать стиль существования Pooled
Стиль существования Pooled вступает в игру в тех ситуациях, когда у нас естпецифичные компоненты, часто используемые, но для создания которых необходимольшие затраты. Даже если создание компонента трудозатратно, нам все еще стоиредпочесть стиль существования Singleton, если это возможно, поскольку он позволяеам работать с единственным экземпляром и расплачиваться за создание объекта всегишь единожды.
Из этого следует, что организация пула применима только тогда, когда рассматриваемыомпонент не должен использоваться коллективно, что часто происходит в тех случаяхогда данный компонент не является потоко-безопасным. Если мы заглянем в веб-
приложение, то стиль существования Web Request Context мог бы стать разумнольтернативой; мы должны были понять, что стиль существования Pooled используетсне веб-приложений.
Обратите внимание на то, что тот факт, что рассматриваемый компонент можнспользовать повторно, является необходимым условием. Если этот компонент обладаебычным жизненным циклом, который исключает возможность повторногспользования, то мы не можем организовать его пул. Одним из примером этого является
WCF интерфейс ICommunicationObject, который имеет вполне определенный жизненныикл. Когда ICommunicationObject находится в состоянии Closed или Faulted, то оожет, по определению, никогда не покидать это состояние. Такой тип объекта нригоден для организации пула. Мы должны уметь возвращать объект обратно в пул ервоначальном состоянии.
Пример: Повторное использование затратных репозиториев
Однажды я работал над проектом, в котором нам нужно было из .NET кодзаимодействовать с мэйнфреймом. Ранее консультанты создали неуправляему ю COM
библиотеку, которая могла взаимодействовать с некоторой конечной точкой мейнфрейма мы решили обернуть эту библиотеку в управляемую сборку.
COM библиотека взаимодействовала с мейнфреймом посредством секретного протоколетевых соединений. Чтобы его использовать, нам приходилось открывать соединение роходить через квитирование установления связи. После открытия соединения мы могли
317
передавать сообщения с умеренной скоростью, но открытие соединения занимало многремени.
Давайте посмотрим, как создать пул экземпляров ProductRepository, которые могузаимодействовать посредством такого протокола. В проекте, в который я был вовлечены называли COM библиотеку Xfer (видовой), поэтому давайте создадим пул экземпляров
XferProductRepository.
Примечание
Как и в примере стиля существования Web Request Context, я не жду, что вы будетоздавать пользовательские системы управления жизненным циклов объектов в пуле.
Несмотря на то, что для управления пулами объектов вам следует использоватоответствующий DI-контейнер, я хочу вам показать упрощенный пример для того, чтобродемонстрировать, как это работает.
Предупреждение
Следующий пример не является потоко-безопасным. Я убрал из него код синхронизациитобы сохранить в примере разумный уровень сложности, а потоко-безопаснуеализацию я оставляю читателям для самостоятельной практики (всегда хотел тааписать).
Данный пример является еще одной вариацией ICommerceServiceContainer, несколькариаций которого вы уже видели в этой главе. В следующем листингродемонстрирована база контейнера.
Листинг 8-12: Схема базы для организации пула контейнерublic partial class PooledContainer : ICommerceServiceContainer
{
private readonly IContractMapper mapper;
private readonly List<XferProductRepository> free;
private readonly List<XferProductRepository> used;
public PooledContainer()
{
this.mapper = new ContractMapper();
this.free = new List<XferProductRepository>();
this.used = new List<XferProductRepository>();
}
public int MaxSize { get; set; }
public bool HasExcessCapacity
{
get
{
return this.free.Count + this.used.Count < this.MaxSize;
}
}
}
Несмотря на то, что вы планируете организовать пул экземпляров
XferProductRepository, вы все равно конфигурируете ContractMapper в виде Singletonоскольку он является сервисом, несохраняющим свое состояние.
Для отслеживания процесса организации пула вы используете две коллекции: в одной иих хранятся доступные репозитории, а другая содержит репозитории, которые
318
используются на текущий момент. При создании и освобождении компонентов веремещаете репозитории между этими двумя коллекциями.
Свойство MaxSize позволяет вам определить максимальный размер пула, а свойство
HasExcessCapacity по существу является инкапсулированным вычислением, которое вожете использовать в условных выражениях для определения того, превышаете ли во-прежнему размер пула.
При такой вариации пула вы будете наполнять пул постепенно, по мере поступлениапросов до тех пор, пока не превысите максимальный размер. Как демонстрируеледующий листинг, вы выдаете исключение, если превышаете максимальный размер се еще получаете запросы.
Листинг 8-13: Разрешение репозиториев из пула
1. public IProductManagementService ResolveProductManagementService()
2. {
3. XferProductRepository repository = null;
4. if (this.free.Count > 0)
5. {
6. repository = this.free[0];
7. this.used.Add(repository);
8. this.free.Remove(repository);
9. }
10. if (repository != null)
11. {
12. return this.ResolveWith(repository);
13. }
14. if (!this.HasExcessCapacity)
15. {
16. throw new InvalidOperationException(
17. "The pool is full.");
18. }
19. repository = new XferProductRepository();
20. this.used.Add(repository);
21. return this.ResolveWith(repository);
22. }
23. private IProductManagementService ResolveWith(
24. ProductRepository repository)
25. {
26. return new ProductManagementService(repository,
27. this.mapper);
28. }
Строка 4-9: При возможности выбирает из пула
Строка 10-13: Возвращает из пула
Строка 19-20: Добавляет новый репозиторий
Для того чтобы разрешить экземпляр IProductManagementService, вы начинаете работу роверки того, доступен ли повторно используемый репозиторий. Если он доступен, то выбираете репозиторий из коллекции свободных репозиториев и перемещаете его писок используемых. Если вы смогли найти повторно используемый репозиторий, то вожете незамедлительно вернуть сервис.
319
Если вы не можете найти доступный репозиторий в пуле, то существует две возможныричины такой ситуации: пул полностью заполнен и используются все репозитории, илы все еще заполняете пул. Если вы можете обойти граничный оператор, которыыполняет проверку заполненности пула, то вы создаете новый экземпляр репозитория обавляете его в коллекцию используемых репозиториев перед тем, как вернуткомпонованный сервис.
ResolveProductManagementService всего лишь перемещает репозитории из коллекциree в коллекцию used, поэтому важно освободить сервисы после использования. В
следующем листинге продемонстрировано, как это сделать.
Листинг 8-14: Возврат репозиториев в пул
1. public void Release(object instance)
2. {
3. var service = instance as ProductManagementService;
4. if (service == null)
5. {
6. return;
7. }
8. var repository = service.Repository
9. as XferProductRepository;
10. if (repository == null)
11. {
12. return;
13. }
14. this.used.Remove(repository);
15. this.free.Add(repository);
16. }
Строка 4-7, 10-13: Граничные операторы
Строка 14-15: Возвращает репозиторий в пул
Вернуть репозиторий в пул легко: вы перемещаете его из коллекции используемыепозиториев в коллекцию доступных репозиториев.
Обратите внимание на то, что, даже если этот пример может показаться сложным, я натронул несколько моментов:
? Пример определенно не является потоко-безопасным. Рабочая реализация должнозволять нескольким потокам разрешать и освобождать экземпляры параллельно.
? Поскольку класс XferProductRepository инкапсулирует неуправляемый код, оеализует IDisposable. Пока вы продолжаете повторно использовать экземплярыам не нужно их уничтожать, но вам точно следует это сделать в тех ситуацияхогда контейнер выходит за рамки области применения. Таким образом, саонтейнер должен реализовывать IDisposable и удалять все репозитории омощью метода Dispose.
Организация пула объектов – хорошо известный паттерн проектирования, но он частнкапсулируется в существующие API; например, ADO.NET использует пулоединений, но мы не сталкиваемся с ним явно. Только когда нам точно нужнптимизировать доступ к затратным ресурсам, стиль существования Pooled начинаеметь смысл.
320
Стиль существования Pooled помогает справиться с ситуацией, когда нам нужнптимизировать использование затратных ресурсов. Это самый последний иниверсальных типов стилей существования.
Другие стили существования
Типы стилей существования, рассматриваемые в данной главе, являются самымниверсальными типами, но ваши нужды могут быть более экзотичными, ассматриваемые стили могут не удовлетворять вашим нуждам. Когда я попал в такуитуацию, первой моей реакцией было чувство чрезвычайной гордости от того, что бнаружил редкий и очень краеугольный случай, который требовал от менспользования экзотического элемента из моего программистского инструментария.
Следующей моей реакцией было осознание того, что мой подход абсолютно неверен, сли я слегка изменю свою модель, то все можно будет вполне подогнать к стандартныаттернам. Такая реализация часто является ухудшением, но приводит к лучшему и болеегко сопровождаемому коду. Суть заключается в том, что если вы чувствуетеобходимость реализовать пользовательский стиль существования, то, прежде всего, ваеобходимо со всей серьезность пересмотреть вашу модель.
Было сказано, что некоторые DI-контейнеры предоставляют возможности расширяемостиоторые позволяют вам разрабатывать пользовательские стили существования. Давайткратце рассмотрим два, технически возможных, но довольно экзотичных стилуществования. В обоих случаях я предоставляю только краткую схему того, как работаы жизненный цикл. Я не отдаю под это целые разделы, поскольку мне было бы труднридумать разумный сценарий их применения.
Lazy
Стиль существования Lazy или Delayed – это Virtual Proxy более затратной зависимости.
Смысл в том, что если у нас есть требующая больших затрат зависимость, которую мы нланируем часто использовать, то мы можем отложить создание затратной зависимосто тех пор, пока она нам не понадобится. Рисунок 8-13 иллюстрирует, как можннедрить потребителя с легковесным дублером для существующей, более затратноеализации.
Рисунок 8-13: Потребителю необходима зависимость IService, но если он используету зависимость лишь в небольших фракциях своего жизненного цикла, то он можеолгое время просуществовать до того момента, когда ему понадобятся сервисы IService.
Когда он, в конце концов, вызывает IService.SelectItem(), LazyService использует егнедренный IServiceFactory для создания экземпляра другого IService. К данномоменту ExpensiveService еще не создан. При создании ExpensiveService всоследующие вызовы могут быть делегированы ему.
321
Имеет смысл использовать такой стиль существования только, если потребителспользует затратную зависимость лишь в небольших фракциях своего собственногизненного цикла, или если мы можем трезво предположить, что до момента вызовависимости пройдет значительное количество времени. Если зависимость вызываетсезамедлительно или часто, то Lazy Decorator ни на что не влияет, но используеополнительные ресурсы.
Если это возможно, требующая больших затрат зависимость должна регистрироваться как
Singleton, чтобы нам нужно было расплачиваться за ее создание лишь единожды. Если этевозможно по причинам потоко-безопасности, мы часто можем разрешить этоловоломку путем организации пула затратного компонента. Даже если чаще всего у наожет быть только один экземпляр, пул этого экземпляра в сочетании с задержкооступа предоставит нам сериализованный доступ к зависимости.
Стиль существования Lazy более интересен с технической точки зрения, нежелрактически полезная стратегия жизненного цикла; если вам интересно, то я даю ссылка рекомендуемую литературу, связанную с данной книгой. (Mark Seemann, "Rebuttal:
Constructor over-injection anti-pattern," 2010ttp://blog.ploeh.dk/2010/01/20/RebuttalConstructorOverinjectionAntipattern.aspx)
Future
Стиль существования Future даже более экзотичен. Смысл в том, что мы можем захотетспользовать зависимость, которая недоступна на данный момент, но которую мы будеспользовать, когда она станет доступной.
Наилучший способ реализации такого стиля существования похож на стилуществования Lazy: мы можем использовать Decorator, который делегирует полномочиервоначальной реализации до тех пор, пока нужная зависимость не станет доступной.
Рисунок 8-14 иллюстрирует концептуальное взаимодействие между компонентами.
Первоначальная реализация, используемая в качестве дублера до тех пор, пока Future
Decorator не дождется нужной зависимости, часто является приложением паттернроектирования Null Object.
322
Рисунок 8-14: Потребителю необходима зависимость IService, но DesiredServicожет быть еще недоступным. В этом случае мы можем инкапсулировать NullService иде дублера, который будет использоваться до тех пор, пока мы находимся "в ожидании
Годо". FutureService – это установленная машина, которая выполняет опрос с цельпределения того, стал ли доступным DesiredService. Когда DesiredServicедоступен, FutureService Decorator ничего не остается, как использовать резервнуеализацию, обеспечиваемую NullService. Когда DesiredService становитскончательно доступным, все последующие запросы направляются к нему.
Я должен согласиться, что я с трудом выжал из себя разумный пример того, когдависимость может стать доступной после того, как мы присоединили полноценнуиаграмму объектов. Это может казаться слегка похожим на ситуацию, когда молагаемся на внешний ресурс, например, базу данных или веб-сервис, но не забывайтето даже если действующий ресурс недоступен, все еще существует программнаависимость; например, веб-сервис может не работать, но WCF прокси, который мспользуем для взаимодействия с этим веб-сервисом все еще доступен.
Лучше мы будем иметь дело с недоступными внешними ресурсами, использующиматтерн Circuit Breaker, который мы рассмотрим в следующей главе. До тех пор, пока кто-
нибудь не предоставит мне разумный сценарий, я считаю стратегию жизненного цикла
Future как технически интересную.
На данный момент мы рассмотрели широкий спектр доступных стилей существованиависимостей – от универсальных до более экзотичных.
323
8.4. Резюме
Когда мы применяем инверсию управления к зависимостям, мы инвертируем управление только над выбором типа, но также над процессом управления жизненным циклом.
Когда потребитель больше не создает свои собственные зависимости, он уже не можеостановить, когда была создана зависимость, и была ли она разделена с другимотребителями.
Composer'ы могут принять решение, позволяющее множеству потребителей совместнспользовать один и тот же экземпляр, или позволяющие каждому потребителю обладатвоим собственным экземпляром. Кроме того, в игру вступают более продвинутытратегии.
Несмотря на то, что Composer'ы отлично управляют тем, когда создаются объектыправляемая модель памяти .NET подразумевает, что в большинстве случаев они лишлегка влияют на то, когда разрушаются объекты. Зависимости могут выйти за рамкбласти применения и быть утилизированы с помощью сборщика мусора. Но особоесто отведено компонентам, которые также реализуют IDisposable, поскольку молжны убедиться, что все неуправляемые ресурсы очищены – иначе наши приложенискоре начнут испытывать утечку памяти.
Равносильно вызову метода Resolve (или какое название он имеет) мы должны всегда набывать вызывать метод Release, когда разрешенная диаграмма объектов выходит замки области применения. Это дает Composer возможность уничтожить любыстраняемые компоненты, которые становятся неиспользуемыми.
Каждая диаграмма объектов может иметь смесь множества различных стилеуществования, и нам, кроме того, нужно следить за тем, являются ли компонентстраняемыми. Добавьте к этой смеси потоко-безопасность, и станет сложно отслеживатсе эти вещи. Именно здесь и расцветает только что распустившийся DI-контейнер, и этдна из причин того, что нам следует использовать DI-контейнер вместо Poor Man's DI.
Каждый из множества доступных DI-контейнеров предлагает свой собственныоступный стиль существования. Некоторые из них поддерживают только нескольктилей существования, другие DI-контейнеры поддерживают большинство или все стилуществования, но многие из них предоставляют возможности расширяемости, которыозволяют нам реализовывать свои собственные стили существования.
Самый безопасный стиль существования – Transient, так как экземпляры не делятся с кем-
либо еще. Т акже это самый неэффективный стиль существования, поскольку, скоресего, в оперативной памяти находится множество экземпляров одного и того же типа.
Наиболее эффективный стиль существования – Singleton, потому что в оперативноамяти находится всего один единственный экземпляр (то есть на один контейнер). Нля этого стиля необходимо, чтобы компонент был потоко-безопасным, поэтому не всегдсть возможность использовать данный стиль существования.
Стили существования Web Request Context и Pooled обеспечивают хорошую альтернативу
Singleton и T ransient, но в более ограниченных сценариях.
324
Возможны и более экзотичные стили существования. Стиль существования Future может ервого взгляда казаться отличным способом управления недоступными ресурсами, нак вы увидите в следующей главе, лучше мы обратимся к такой теме, как механизерехвата.
325
9. Механизм перехвата
Меню:
? Сквозные сущности
? Аспектно-ориентиро ванное программирование
? Динамический перехват
В кулинарии одно из самых интересных – это то, как мы можем смешивать между собоножество ингредиентов; некоторые из них сами по себе не очень вкусные, а их смесамного вкуснее. Часто мы начинаем с простого ингредиента, составляющего основлюда, а затем изменяем и приукрашиваем его до тех пор, пока, в конечном итоге, нолучим превосходное блюдо.
Представьте себе говяжью отбивную. Если бы мы находились в полном отчаянии, тогли бы съесть ее сырой, но в большинстве случаев мы бы предпочли ее пожарить. Тее менее, если мы просто шлепнем ее на горячую сковороду, то результат будет менеыдающимся. За исключением подгоревшего привкуса вы больше ничего ночувствуете.
К счастью, есть множество шагов, которые мы можем предпринять, чтобы повысить свовалификацию:
? Жарка отбивной в масле предотвратит мясо от подгорания, но вкус все равнстанется слабым.
? Добавление соли усилит вкус мяса.
? Добавление других специй, например, перца, сделает вкус мяса более богатым.
? Панировка отбивной в смеси из соли и специй не только добавит ей вкусовыачеств, но также придаст первоначальному ингредиенту новую структуру. Нанном этапе мы приближаемся к тому, что называется котлетой.
? Прорезание в отбивной кармашка и добавление в него ветчины, сыра и чеснокеред панировкой поднимет нас на пьедестал почета. Мы получили кордон блюамое превосходное блюдо.
Разница между подгоревшей отбивной и кордон блю значительна, но исходнынгредиент этих блюд один и тот же. Вариативность вызвана теми ингредиентамиоторые мы добавляем к первоначальному. Подав говяжью отбивную, мы можериукрасить ее, не изменяя при этом главный ингредиент, и создать другое блюдо.
С помощью слабого связывания мы можем выполнить аналогичный трюк при разработкрограммного обеспечения. Когда мы программируем на основе интерфейсов, мы можереобразовать или улучшить основную реализацию, завернув ее в другие реализацианного интерфейса. Вы уже видели часть этой методики в действии в разделе 8.3.6
"Другие стили существования", где мы использовали ее для изменения жизненного циклатратной зависимости, обертывая ее в Proxy.
Этот подход может быть обобщен, что предоставляет нам возможность перехватитапрос потребителя к сервису; именно это мы и будем рассматривать в данной главе.
Подобно говяжьей отбивной мы начинаем с основного ингредиента и добавляем большнгредиентов для его улучшения, но, не меняем при этом его первоначальную суть.
Механизм перехвата – одна из самых мощных возможностей, полученных нами благодаря
326
слабому связыванию. Он позволяет нам с легкостью применять принцип единичнответственности и концепцию разделения.
В предыдущих главах мы потратили множество усилий на перебрасывание нашего кода ту позицию, где он действительно слабо связан. В данной главе мы начнем пожинатреимущества данного вложения.
Рисунок 9-1 демонстрирует обзор структуры данной главы. После окончания изученилавы вы должны уметь использовать механизм перехвата для разработки слабвязанного кода согласно установленным принципам объектно-ориентированногроектирования. В частности вы должны приобрести способность успешно соблюдатонцепцию разделения и применять сквозные сущности, при этом сохраняя код тличном состоянии.
Рисунок 9-1: Вся структура данной главы достаточно линейна. Мы начнем знакомления с механизмом перехвата, включая пример. Далее мы перейдем к разговору квозных сущностях. Данный раздел главы не обременен теорией, но наполнеримерами, поэтому, если вы уже знакомы с данной темой, вы можете перейти прямо оследнему разделу, касающемуся аспектов. Этот раздел является кульминационноочкой главы, так как знакомит вас с усовершенствованной и, кроме того, гибкоонцепцией механизма перехвата.
Поскольку понять, как работает механизм перехвата, не сложно, мы начнем с небольшогримера для того, чтобы определить контекст. Для того чтобы полноценно оценитозможности, мы должны изучить некоторые связанные понятия, например, аспект но-
ориент ированное программирование (AOP) и SOLID принципы, и связать их с механизмоерехвата с помощью примеров. В конечном счете, вы увидите, как можно использовать
DI-контейнер для того, чтобы обобщить механизм перехвата и облегчить его применение.
Поскольку в основе механизма перехвата лежат хорошо известные паттернроектирования и принципы объектно-ориентированного проектирования, данная главаполнена различными примерами. Маршрут главы вполне прямолинеен, начинается водного примера и вырастает до более сложных понятий и примеров. Последнее и болеродвинутое понятие можно быстро объяснить с помощью абстракции, но, поскольку этонятие, скорее всего, будет вам понятно только на примере, глава завершаетсримером, занимающим несколько страниц, который демонстрирует, как все работает.
Но прежде чем мы до этого доберемся, мы должны начать с самого начала.
9.1. Знакомство с механизмом перехвата
9.2. Реализация сквозных сущностей
9.3. Объявление аспектов
9.4. Резюме
327
9.1. Знакомство с механизмом перехвата
Концепция механизма перехвата довольно проста: нам хотелось бы уметь перехватыватигнал между потребителем и сервисом, и исполнять некоторый код до или после вызованного сервиса. На рисунке 9-2 обычный сигнал от потребителя к сервисерехватывается посредником, который может исполнить свой собственный код до илосле передачи сигнала к фактическому сервису.
Рисунок 9-2: Механизм перехвата в двух словах. Мы можем сконвертировать простоигнал от потребителя к сервису в более сложное взаимодействие путем вставкрагмента кода посредника. Посредник получает первоначальный сигнал и передает его ействующую реализацию, при этом действуя на сигнал так, чтобы он выполнял то, чтму требуется делать.
В данном разделе мы собираемся познакомиться с механизмом перехвата и узнать, какибразом, по своей сути, он является приложением паттерна проектирования Decorator.
Если вы не знакомы с паттерном Decorator, то мы разберем его в рамках беседы, и когды это сделаем, вы должны будете получить хорошее понимание того, как он работает.
Мы начнем с рассмотрения простого примера, который демонстрирует паттерн, ерейдем к обсуждению, как механизм перехвата относится к паттерну Decorator.
Пример: реализация аудита
В данном примере мы будем реализовывать аудит для ProductRepository. Аудит – этниверсальный пример концепции сквозных сущностей: он может потребоваться, но нолжен оказывать влияние на основную функциональность чтения и редактированиоваров. Поскольку принцип единичной ответственности предполагает, что мы не должнозволять ProductRepository самому реализовывать аудит, использование паттерна
Decorator является наилучшим вариантом.
Реализация AuditingProductRepository
Реализовать аудит для ProductRepository мы можем путем введения нового класса
AuditingProductRepository, который обертывает другой ProductRepository и реализуеудит. Рисунок 9-3 иллюстрирует то, как типы связаны друг с другом.
328
Рисунок 9-3: AuditingProductRepository наследуется от абстрактного класса
ProductRepository и обертывает экземпляр любой другой реализации
ProductRepository. AuditingProductRepository делегирует всю работу расширенному
ProductRepository, но добавляет аудит на соответствующие места. Сможете ли ввидеть панировку?
Помимо расширенного ProductRepository для AuditingProductRepository также нужеервис, который реализует аудит. В следующем листинге роль такого сервиса играентерфейс IAuditor.
Листинг 9-1: Объявление AuditingProductRepository
1. public partial class AuditingProductRepository :
2. ProductRepository
3. {
4. private readonly ProductRepository
5. innerRepository;
6. private readonly IAuditor auditor;
7. public AuditingProductRepository(
8. ProductRepository repository,
9. IAuditor auditor)
10. {
11. if (repository == null)
12. {
13. throw new ArgumentNullException("repository");
14. }
15. if (auditor == null)
16. {
17. throw new ArgumentNullException("auditor");
18. }
19. this.innerRepository = repository;
20. this.auditor = auditor;
21. }
22. }
Строка 2, 4-5, 8, 19: Наследуется и обертывает ProductRepository
Строка 6, 9, 20: Сервис аудита
AuditingProductRepository наследуется от той же самой абстракции, которую оасширяет. AuditingProductRepository использует стандартный Внедрение онструктор (Constructor Injection) для запроса ProductRepository, который он можебернуть и которому он может делегировать свою основную реализацию. Помимасширенного репозитория для AuditingProductRepository также требуется IAuditorоторый он может использовать для отслеживания операций, реализованныасширенным репозиторием.
329
Следующий листинг демонстрирует шаблонные реализации двух методов
AuditingProductRepository.
Листинг 9-2: Реализация AuditingProductRepositorublic override Product SelectProduct(int id)
{
return this.innerRepository.SelectProduct(id);
}
public override void UpdateProduct(Product product)
{
this.innerRepository.UpdateProduct(product);
this.auditor.Record(
new AuditEvent("ProductUpdated", product));
}
Не для всех операций нужен аудит. Универсальным требованием является аудит всепераций Create, Update и Delete, и игнорирование операций Read. Поскольку метод
SelectProduct является истинной операцией Read, вы делегируете вызов расширенногепозитория и незамедлительно возвращаете результат.
Метод UpdateProduct, с другой стороны, должен подвергаться аудиту. Вы все ещелегируете реализацию расширенному репозиторию, но после того, как делегированныетод возвращается, вы используете внедренный IAuditor для отслеживания операции.
Decorator, подобно AuditingProductRepository, является своего рода панировкоовяжьей от бивной: он приукрашивает основной ингредиент, не изменяя его. Сама пебе панировка не является просто пустой оболочкой, а содержит собственный списонгредиентов. Настоящая панировка делается из панировочных сухарей и специй;
подобным образом AuditingProductRepository содержит IAuditor.
Обратите внимание на то, что внедренный IAuditor сам по себе является абстракциейто означает, что вы можете варьировать реализацию независимо от
AuditingProductRepository. Все, что делает класс AuditingProductRepository, –
координирует действия расширенного ProductRepository и IAuditor.
Вы можете создать любую реализацию IAuditor, какую только пожелаете, но реализацияснованная на SQL Server, – универсальный вариант. Давайте посмотрим, как вы можетодключить все соответствующие зависимости для выполнения этой работы.
Компоновка AuditingProductRepository
Несмотря на то, что многие приложения используют класс ProductRepository длзвлечения информации о товаре, и в связи с тем, что WCF веб-сервис CommerceServicз раздела 7.3.2 "Пример: подключение сервиса управления продуктами" раскрывает
CRUD-операции для Products, это подходящее место для начала работы.
В главе 8 вы видели несколько примеров того, как компоновать экземпляр
ProductManagementService. Листинги 8-4 и 8-5 предоставляли самую корректнуеализацию, но в следующем листинге мы проигнорируем тот факт, что
SqlProductRepository является устраняемым, для того, чтобы сконцентрироваться номпоновке Decorator'ов.
330
Листинг 9-3: Компоновка Decorator
1. public IProductManagementService ResolveProductManagementService()
2. {
3. string connectionString =
4. ConfigurationManager.ConnectionStrings
5. ["CommerceObjectContext"].ConnectionString;
6. ProductRepository sqlRepository =
7. new SqlProductRepository(connectionString);
8. IAuditor sqlAuditor =
9. new SqlAuditor(connectionString);
10. ProductRepository auditingRepository =
11. new AuditingProductRepository(
12. sqlRepository, sqlAuditor);
13. IContractMapper mapper = new ContractMapper();
14. return new ProductManagementService(
15. auditingRepository, mapper);
16. }
Строка 6-7: Внутренний ProductRepository
Строка 10-12: Decorator
Строка 14-15: Внедряет Decorator
Как и в листинге 7-9, поскольку вам хочется использовать ProductRepositoryазирующийся на SQL Server, вы создаете новый экземпляр SqlProductRepository. Нместо того, чтобы напрямую внедрять его в экземпляр ProductManagementService, вудете обертывать его в AuditingProductRepository.
Вы внедряете и SqlProductRepository, и базирующуюся на SQL Server реализацию
IAuditor в экземпляр AuditingProductRepository. Обратите внимание на то, как qlRepository, и auditingRepository объявлены в виде экземпляров
ProductRepository.
Теперь вы можете внедрить auditingRepository в новый экземпляр
ProductManagementService и вернуть его. ProductManagementService видит толькuditingRepository и ничего не знает о sqlRepository.
Предупреждение
Листинг 9-3 – это упрощенный пример, в котором игнорируются проблемы жизненногикла. Поскольку и SqlProductRepository, и SqlAuditor являются устраняемымипами, данный код станет причиной утечки ресурсов. Более корректной реализациеыла бы интерполяция листинга 9-3 с листингами 8-4 и 8-5 – но я уверен, вы поймете, чт данном случае реализация начнет усложняться.
Подсказка
Вместо того, чтобы вручную бороться с перестановкой местами композиции объектовправления жизненным циклом и механизма перехвата, используйте DI-контейнер.
Заметьте, что вы могли бы добавить поведение в ProductRepository, не изменяя при этосходного кода существующих классов. Для того чтобы добавить возможность аудита,
331
нам не пришлось изменять SqlProductRepository. Это желанное свойство, известное каринцип от крытости/закрытости.
О бязате льная пищевая аналогия
Думаю, это относится к покрытию говяжьей отбивной панировкой. Несмотря на то, чты изменили отбивную, мы оставили ее в том же размере вместо того, чтобы разрезать е потушить.
Теперь, когда вы увидели пример перехватывания конкретного SqlProductRepository омощью расширенного AuditingProductRepository, давайте немного вернемся назад зучим паттерны и принципы, лежащие в основе механизма перехвата.
Паттерны и принципы механизма перехвата
Как и в случае со многими другими DI-паттернами, паттерн Decorator является давним орошо описанным паттерном проектирования, который имел место еще за несколько лео появления механизма внедрения зависимости. Он является настолько фундаментальноастью механизма перехвата, что независимо от того, знаком ты с ним близко или нет, оарантированно о себе напоминает.
Вы могли заметить, что такие термины, как принцип единственной ответственности ринцип от крытости/закрытости, используются чаще обычного. Это составляющиасти пятиэлементного меню SOLID.
Все эти паттерны и принципы считаются ценным руководством по чистому коду.
Основная цель данного раздела – связать это заданное руководство с механизмонедрения зависимостей для того, чтобы продемонстрировать, что механизм внедрениависимостей является всего лишь средство достижения цели. Мы используем DI каредство разрешения поддерживаемого кода.
Все потребители зависимостей должны при вызове своих зависимостей соблюдатринцип подстановки Барбары Лисков. Это позволяет нам заменить первоначальнапланированну ю реализацию другой реализацией той же самой абстракции. Поскольку
Decorator реализует такую же абстракцию, как и класс, который он обертывает, мы можеаменить первоначальный класс на Decorator.
Именно это вы и делали в листинге 9-3, когда заменяли первоначальный
SqlProductRepository на AuditingProductRepository. Вы могли бы сделать это, нзменяя код ProductManagementService, так как ProductManagementService следуеринципу подстановки Барбары Лисков: ему нужен экземпляр ProductRepository, огда любая реализация будет выполнена.
Возможность расширения поведения класса без изменения его кода называется принципоткрыт ост и/закрытости, и является одним из пяти принципов, зашифрованныущностью под названием SOLID.
SOLID
Кому не хотелось бы создавать надежное программное обеспечение? Программнобеспечение, которое могло бы выдержать тест временем и остаться полезным для своих
332
пользователей, – стоящая цель; введение SOLID в качестве акронима разработкачественного программного обеспечения имеет смысл.
Decorator
Паттерн Decorator впервые был описан в книге "Паттерны проектирования". Цель этогаттерна – "динамически присоединить к объекту дополнительные ответственности.
Decorator'ы являются гибкой альтернативой деления на подклассы, которое выполняетсля расширения функциональности."
Работа Decorator заключается в обертывании одной реализации абстракции в другуеализацию. Объект, выполняющий обертывание, делегирует операции находящейся ем реализации, добавляя при этом поведение до или после вызова обернутого объекта.
Decorator может обертывать другой Decorator, который обертывает еще одного
Decorator'а, и т.д. Следующий рисунок демонстрирует, как Decorator'ы могут обертыватруг друга. В самом центре должна находиться независимая реализация, котораыполняет необходимую работу.
Decorator обертывает другого Decorator'а, обертывающего, в свою очередьамостоятельного компонента. Когда вызывается член самого дальнего Decorator'а, оелегирует сигнал обернутому им компоненту. Поскольку обернутый компонент сам пебе является Decorator'ом, он делегирует сигнал содержащемус я в нем компоненту. Праждом вызове Decorator имеет возможность использовать входное или выходноначение содержащегося в нем компонента для того, чтобы выполнить дополнительнуаботу
Когда в Decorator поступает вызов одного из членов реализуемой им абстракции, оожет просто делегировать вызов, ничего при этом не делая:
public string Greet(string name)
{
return this.innerComponent.Greet(name);
}
Кроме того, перед тем, как делегировать вызов, он может изменить входные данные:
public string Greet(string name)
{
var reversed = this.Reverse(name);
return this.innerComponent.Greet(reversed);
}
Похожим образом он может изменить возвращаемое значение перед тем, как его вернуть:
333
public string Greet(string name)
{
var returnValue = this.innerComponent.Greet(name);
return this.Reverse(returnValue);
}
Имея два предыдущих примера, мы можем обернуть последний из них редшествующий для того, чтобы создать комбинацию, которая изменяет как входныеак и выходные данные.
Decorator также может решить не вызывать приведенную ниже реализацию:
public string Greet(string name)
{
if (name == null)
{
return "Hello world!";
}
return this.innerComponent.Greet(name);
}
В данном примере граничный оператор предоставляет поведение по умолчанию длходных данных типа null, при котором обернутый компонент вообще не вызывается.
То, что отличает Decorator от любого класса, содержащего зависимости, – расширенныбъект реализует ту же самую абстракцию, что и Decorator. Это позволяет Composeаменить первоначальный компонент Decorator'ом, не изменяя при этом потребителя.
Расширенный объект часто внедряется в Decorator, объявленный в виде абстрактногипа, причем в этом случае Decorator должен соблюдать принцип подстановки Барбары
Лисков и относиться ко всем расширенным объектам одинаково.
В некоторых местах данной книги вы уже видели Decorator'ы в действии. В примераздела 9.1.1 "Пример: реализация аудита" использовался Decorator, как и в разделе 4.4.4.
Под акронимом SOLID мы понимаем пять принципов объектно-ориентированногрограммирования, которые оказываются полезными при написании поддерживаемогода. В таблице 9-1 перечислены эти принципы.
Таблица 9-1: Пять принципов SOLID
Принцип Описание Как связан с механизмонедрения зависимостей
Принцип единственнответственности (SRP)
Класс должен иметь толькдну ответственность. Оолжен выполнять толькдну задачу, но выполняте хорошо.
Противоположностьанного принципа являетснтипаттерн под названием
God Class, в котором одиласс может делать всеключая приготовлениофе.
Придерживаться данного принципожет быть сложновато, но одниз многочисленных преимуществ
Constructor Injection является тоакт, что данный принцитановится очевидным всякий разогда мы его не соблюдаем.
В примере раздела 9.1.1 "Пример:
реализация аудита", вы моглоблюдать принцип единственнответственности путем разделения
334
Принцип Описание Как связан с механизмонедрения зависимостетветственностей на отдельныипы: SqlProductRepositorмеет дело только с хранением звлечением данных о товарахогда как SqlAuditoконцентрирован на сохранениути аудита в базе данных.
Единственной ответственностьласса
AuditingProductRepositorвляется координация действий
ProductRepository и IAuditor.
Принциткрытости/закр ытости
(OCP)
Класс должен быть открыля расширяемости, накрыт для модификации.
Это означает, что должнрисутствовать возможностобавлять к существующемлассу поведение, нзменяя при этом код этогласса.
Этого не так просто достичьо принцип единственнответственности, по крайнере, упрощает данныроцесс, поскольку, чероще код, тем прощбнаружить потенциальные
"Швы".
Существует много способоделать класс расширяемымключая виртуальные методынедрение стратегий и применение
Decorator'ов – но детали не важныеханизм внедрения зависимостередоставляет даннуозможность, позволяя наомпоновать объекты.
Принцип подстановки
Барбары Лисков (LSP)
Клиент должен одинаковтноситься ко всееализациям абстракций.
Мы должны уметь заменятюбую реализацию другоеализацией, не разрушари этом потребителя.
Принцип подстановки Барбары
Лисков является основоеханизма внедрениависимостей. Если потребитель ноблюдает данный принцип, то ве можете заменять зависимости, ы теряем какие-то (если не все)
преимущества механизмнедрения зависимостей.
Принцип разделенинтерфейсов (ISP)
Интерфейсы должнроектироватьсифференцированно. У нает желания смешиватлишком большооличествтветственностей в однонтерфейсе, поскольктановится слишком тяжело
Поначалу, кажется, что принциазделения интерфейсов лиштдаленно связан с механизмонедрения зависимостей. Но оажен, поскольку интерфейсоторый моделирует все, включаухонную раковину, подталкиваеас в направлении конкретноеализации. Часто это попахивает
335
Принцип Описание Как связан с механизмонедрения зависимостего реализовывать.
Я считаю, что принциазделения интерфейсовляется концептуальносновой принципдинственнответственности. Согласнринципу ISP интерфейсолжны моделироватолько одну сущность, тогдак принцип SRP
утверждает, что реализациолжны иметь только однтветственность.[/p]
leaky-абстракцией и значительнсложняет процесс заменависимостей, посколькекоторые члены интерфейса могуе иметь смысла в контекстетличающемся от того, которыервоначально запускароектирование.
Принцип инверсиависимостей (DIP)
Еще один термин крылаторазы программирование нсновании интерфейсов, а на основании конкретноеализации.
Принцип инверсии зависимостей
(DIP) – это принцип, являющийсснованием механизма внедрениависимостей.
Примечание
Ни один из принципов, инкапсулированных в акрониме SOLID, не представлебсолютным образом. Они являются директивами, которые могут помочь нам в написаниистого кода. Для меня они являются целями, которые помогают мне решить, по какомаправлению я должен направить свои API. Я всегда радуюсь своему успеху, но бывает е радуюсь.
Decorator (и все паттерны проектирования в целом) и такие директивы, как SOLID
принципы, существовали на протяжении многих лет, и в целом их применение считалослаготворным. В данном разделе я попытался дать вам подсказку, как они связаны еханизмом внедрения зависимостей.
SOLID принципы релевантны на протяжении всех глав данной книги, и вы могламетить, что я то тут, то там упоминал о некоторых из них. Но только когда мриступаем к разговору о механизме внедрения зависимостей, и о том, как они связаны с
Decorator'ами, начинает проступать связь с SOLID. Некоторые из них более неуловимыо добавление поведения (например, аудита) с помощью Decorator является чистейширименением принципа открытости/закр ытос ти с не отстающим от него принциподинственной ответственности, так как принцип открытости/закр ытости позволяет наоздавать реализации, имеющие специально заданные области применения.
В данном разделе мы попутешествовали по паттернам и принципам для того, чтобонять взаимосвязь механизма внедрения зависимостей с другими установленнымирективами. Вооружившись этим дополнительным знанием, давайте вернемся к целанной главы, которая заключается в написании чистого и поддерживаемого кода вопрекротиворечивым и изменяющимся требованиям, и необходимости обращаться онцепции сквозных сущностей.
336
9.2. Реализация сквозных сущностей
Большинство приложений должно обращаться к аспектам, которые не связаны напрямуи с какой конкретной возможностью, а вместо этого обращаются к более широкоущности. Эти сущности часто касаются множества других несвязанных областей кодааходящихся даже в различных модулях и на различных уровнях. Поскольку онхватывают большую область базы кода, мы называем их сквозными сущност ями. В
следующей таблице приведены некоторые примеры. Данная таблица не являетссеобъемлющим списком всех доступных аспектов; это всего лишь наглядный пример.
Таблица 9-2: Универсальные примеры сквозных сущностей
Аспект Описание
Аудит
Любая операция, подразумевающая изменение данных, должнставлять путь аудита, включая временную отметкудентификатор пользователя, внесшего изменения, и информаци том, что изменилось. Пример этого вы видели в разделе 9.1.1
"Пример: реализация аудита".
Вход в систему
Слегка отличающийся от аудита вход в систему фокусируется написи событий, которые отражают состояние приложения. Этогут быть события, интересные IT -отделу, или, возможно, бизнес-
события.
Контролроизводительно сти
Слегка отличается от аспекта входа в систему, поскольку имееело больше с записью производительности, а не с конкретнымобытиями. Если у вас есть соглаш ения о качест вредоставляемых услуг (Service Level Agreements), которые нельзонтролировать посредством стандартной инфраструктуры, волжны реализовать пользовательский контролроизводительно сти. Пользовательские счетчикроизводительности Windows хорошо подходят для этого, но ваще нужно добавить некоторый код, который захватывает данные.
Безопасность Некоторые операции должно быть разрешено выполнять тольконкретным пользователям, и вы должны претворить это в жизнь.
Кэширование
Довольно часто вы можете увеличить производительность за счееализации кэшов, но другой причины, согласно котороонкретный компонент доступа к данным должен иметь дело тим аспектом, не существует. Возможно, вы захотите иметозможность разрешать и блокировать кэширование различныеализаций доступа к данным. Мы уже наблюдали намек неализацию кэширования с помощью Decorator'ов в разделе 4.4.4.
Обработка ошибок
Возможно, мы захотим обрабатывать определенные исключения ибо заносить их в лог, либо демонстрировать пользователообщение. Для того чтобы обрабатывать ошибки должныбразом, мы можем использовать обработчик ошибок Decorator.
Отказоустойчивость
Внешние ресурсы гарантированно время от времени будуедоступны. Вы можете реализовать паттерны отказоустойчивостиапример, Circuit Breaker, с помощью Decorator.
337
При рисовании диаграмм архитектуры многоуровневого приложения сквозные сущностаще всего представляются в виде вертикальных блоков, размещенных около уровней, като показано на рисунке 9-4.
Рисунок 9-4: Чаще всего мы представляем сквозные сущности на диаграммархитектуры приложения с помощью вертикальных блоков, которые охватывают всровни. В данном примере безопасность является сквозной сущностью.
В этом разделе мы рассмотрим некоторые примеры, которые иллюстрируют, как можем использовать механизм перехвата в форме Decorator'ов для реализации сквозныущностей. Мы выберем несколько аспектов из таблицы 9-2, чтобы попробоватеализовать их с помощью SOLID принципов, но рассмотрим только небольшое иоличество. Как и в случае со многими другими сущностями, механизм перехвата прощонять с помощью абстракции, но вся сложность заключается именно в деталях. Оринимает на себя воздействие, чтобы надлежащим образом впитать приемы, и лучше риведу вам слишком много примеров, нежели совсем мало. Когда мы закончим с этимримерами, вы должны будете приобрести ясную картину того, что такое механизерехвата, и как вы можете его применить.
Поскольку вы уже видели ознакомительный пример раздела 9.1.1 "Пример: реализациудита", мы рассмотрим более сложный пример, чтобы проиллюстриро вать, как можнспользовать механизм перехвата в рамках сколь угодно сложной логики. Как только мто сделаем, мы изучим пример, который приведет нас прямиком к более декларативномодходу.
Осуществление перехвата с помощью Circuit Breaker
Любое приложение, взаимодейству ющее с внешними ресурсами, может сталкиваться итуациями, когда ресурс недоступен. Разрываются сетевые соединения, переходят втономный режим базы данных, веб-сервисы засоряются DDos-атаками (Distributed
Denial of Service). В таких случаях приложение, передающее сигнал, должно уметосстанавливаться и незамедлительно решать проблему.
Большинство .NET API имеют время ожидания по умолчанию, гарантирующее, чтнешний вызов не заблокирует навсегда потребляющий поток. Однако в ситуации, когды только что получили исключение, касающееся времени ожидания, как вам относитьс следующему вызову ресурса, который является виновником возникшего исключения?
Попытаться ли вам вызвать ресурс снова? Поскольку время ожидания чаще всегказывает на то, что другая сторона либо находится в автономном режиме, либо засоренапросами, осуществление нового блокирующего вызова может стать не очень хорошей
338
идеей. Будет лучше допустить самое худшее и незамедлительно выдать исключение. Эт есть логическое обоснование паттерна Circuit Breaker.
Circuit Breaker – ст абильный пат терн, так как он добавляет устойчивость приложениюыстро прерываясь, вместо того, чтобы зависать и потреблять ресурсы во времависания. Это отличный пример нефункционального требования и истинной сквозноущности, поскольку этому паттерну приходится совсем немного работать с тоозможностью, которая реализуется с помощью внешнего вызова.
Сам по себе паттерн Circuit Breaker слегка сложный и его может быть сложнеализовывать, но нам нужно сделать эти вложения всего лишь раз. Мы даже могли бри желании реализовать его в повторно используемой библиотеке. Имея повторнспользуемый Circuit Breaker, мы можем с легкостью применить его к разнообразныомпонентам, используя паттерн Decorator.
C ircuit Breaker
Паттерн проектирования Circuit Breaker получил свое название от электрическогыключателя с таким же именем. Он создан для размыкания соединения при появлениеисправности с целью предотвращения распространения неисправности.
В прикладном программном обеспечении при возникновении таймаутов или похожишибок взаимодействия, ситуация может ухудшиться, если вы будете продолжатолбить упавшую систему. Если удаленная система засорена, множественные повторныызовы могут привести к падению системы – при этом пауза может дать системе шаносстановиться. На уровне осуществления вызова потоки, заблокировавшие ожиданиаймаутов, могут сделать приложение-по требитель не реагирующим на вызов. Лучшбнаружить разрыв взаимодействия и быстро прерваться на время.
Паттерн Circuit Breaker решает этот вопрос путем выключения выключателя прозникновении ошибки. Обычно в этот паттерн входит время ожидания, что заставляего повторить соединение через некоторое время; таким образом, он может автоматическосстанавливаться, когла удаленная система становится резервной.
Следующий рисунок иллюстрирует упрощенное представление переключения состояни Circuit Breaker.
Упрощенная диаграмма переключения состояний паттерна Circuit Breaker. Паттерн Circuit
Breaker начинается с состояния Closed, указывающего на то, что цепь закрыта, ообщения могут поступать. При возникновении ошибки отключается прерыватель, остояние переключается на Open. В данном состоянии прерыватель не позволяет ндного вызова удаленной системы; вместо этого он незамедлительно выдает исключение.
После таймаута состояние переключается на Half-Open (Полуоткрытое), при котороазрешается прохождение только одного удаленного вызова. При успешном выполнениостояние возвращается к Closed, но если вызов не проходит, прерыватель возвращается остоянию Open, начиная новый таймаут.
339
Вы можете захотеть сделать Circuit Breaker более сложным, нежели это описано здесь.
Для начала вы, возможно, не захотите выключать прерыватель всякий раз прозникновении случайной ошибки, а захотите использовать барьер. Во-вторых, волжны выключать прерыватель только при возникновении ошибок определенных типов.
Таймауты и исключения, касающиеся процесса взаимодействия, хорошо, но
NullReferenceException, скорее всего, указывает на баг, а не на скачкообразную ошибку.
Давайте рассмотрим пример, который демонстрирует, как паттерн Decorator можнспользовать для добавления поведения Circuit Breaker к существующему внешнемомпоненту. В этом примере мы будем концентрироваться на применении повторнспользуемого Circuit Breaker, а не на том, как он реализован.
Пример: Реализация C ircuit Breaker
В разделе 7.4.2 "Пример: присоединение ценного клиента управления товарами" моздали WPF приложение, которое взаимодействует с W CF сервисом при помощнтерфейса IProductManagementAgent. Несмотря на то, что мы возвращались к этомриложению в разделе 8.2.1 "Использование устраняемых зависимостей", мы никогда нзучали его подробно.
В предыдущих примерах вы использовали WcfProductManagementAgent, которыеализует интерфейс посредством вызова операций WCF сервиса. Поскольку даннаеализация не обладает возможностью явной обработки ошибок, любая ошибкзаимодействия будет передаваться вызывающему объекту.
Это отличная ситуация для Circuit Breaker. Вам хотелось бы незамедлительнрерываться, как только начинают возникать исключения; таким образом, вы не будетлокировать вызывающий поток и засорять сервис. Как демонстрирует рисунок 9-5, вачинаете с объявления Decorator'а для IProductManagementAgent и запроса необходимыависимостей посредством Constructor Injection.
340
Рисунок 9-5: CircuitBreakerProductManagementAgent – это Decorator для
IProductManagementAgent: обратите внимание на то, как он реализует интерфейс, а такжа то, что он содержит экземпляр, внедренный через конструктор. Еще одна зависимость
– ICircuitBreaker, которую мы можем использовать для реализации паттерна Circuit
Breaker.
Теперь вы можете обернуть любой вызов расширенного IProductManagementAgenодобно примеру, продемонстрированному в следующем листинге.
Листинг 9-4: Расширение с помощью Circuit Breakeublic void InsertProduct(ProductEditorViewModel product)
{
this.breaker.Guard();
try
{
this.innerAgent.InsertProduct(product);
this.breaker.Succeed();
}
catch (Exception e)
{
this.breaker.Trip(e);
throw;
}
}
Первое, что вам нужно сделать перед тем, как вы попытаетесь вызвать расширенноггента – проверить состояние Circuit Breaker. Метод Guard позволит вам пройти, если
Circuit Breaker находится в состоянии Closed или Half-Open, тогда как этот же метоыдаст исключение, если Circuit Breaker находится в состоянии Open. Это гарантирует, чты незамедлительно прерветесь, если у вас есть причины полагать, что вызов не приведе успешному завершению.
Если вы сможете пройти мимо метода Guard, то можете попытаться вызватасширенного агента. Обратите внимание на то, что вызов обернут в блок try: если вызое выполнится, вы отключаете прерыватель. В данном примере все просто, но астоящей реализации вам следует схватить и отключить прерыватель от выбора типсключений. Поскольку NullReferenceExceptions или похожие типы исключений редкказывают на скачкообразные ошибки, нет причины отключать прерыватель в такилучаях.
341
Как при состоянии Closed, так и при состоянии Half-Open, отключение прерывателернет нас в состояние Open. При состоянии Open время ожидания определяет, когда мернемся к состоянию Half-Open.
Наоборот, вы вызываете Circuit Breaker в случае успешного вызова. Если вы ужаходитесь в состоянии Closed, вы в нем и остаетесь. Если вы находитесь в состоянии
Half-Open, вы переходите обратно к состоянию Closed. При нахождении Circuit Breaker остоянии Open невозможно сигнализировать об успешном выполнении, поскольку метод
Guard будет гарантировать, что вы никогда не зайдете так далеко.
Все остальные методы IProductManagementAgent выглядят также с одной лишь разницейаключающейся в методе, который они вызывают для innerAgent, и дополнительнотроке кода для метода, который возвращает значение. Вы можете увидеть даннуариацию внутри блока try метода SelectAllProducts:
var products = this.innerAgent.SelectAllProducts();
this.breaker.Succeed();
return products;
Поскольку вы должны сигнализировать Circuit Breaker об успехе, вам приходитсохранять возвращаемо е значение расширенного агента перед тем, как вернуть самоггента; но это единственное отличие между методами, которые возвращают значение, етодами, не возвращающими значение.
На данном этапе вы оставили реализацию ICircuitBreaker открытой, но реальнаеализация является полностью повторно используемым комплексом классоврименяющих паттерн проектирования "Состояние" (State). Рисунок 9-6 демонстрируеключенные в этот комплекс классы.
Рисунок 9-6: Класс CircuitBreaker реализует интерфейс ICircuitBreaker путерименения паттерна State. Все три метода реализованы путем делегирования полномочилену State, подразумевающему возможность реконфигурации, который изменяетсодобно переходам состояний от одного к другому.
342
Несмотря на то, что в этой книге мы не собираемся погружаться вглубь реализации
CircuitBreaker, важно, что вы можете выполнить перехват с помощью условно сложногода.
Подсказка
Если вы интересуетесь реализацией класса CircuitBreaker, то она доступна в кодерисоединенном к данной книге.
Чтобы скомпоновать ProductManagementAgent с помощью добавленноункциональности, вы можете обернуть ее в другой реализации:
var timeout = TimeSpan.FromMinutes(1);
ICircuitBreaker breaker = new CircuitBreaker(timeout);
IProductManagementAgent circuitBreakerAgent =
new CircuitBreakerProductManagementAgent(wcfAgent, breaker);
В листинге 7-10 вы компоновали WPF приложение из нескольких зависимостей, включакземпляр WcfProductManagementAgent. Вы можете дополнить эту переменную wcfAgenутем внедрения ее в экземпляр CircuitBreakerProductManagementAgent, которыеализует тот же интерфейс. В данном кокретном примере вы создаете новый экземпляласса CircuitBreaker всякий раз при разрешении зависимостей, а это соответствуетилю существования Transient.
В WPF приложении, в котором вы разрешаете зависимости всего лишь раз, использование
Transient Circuit Breaker не является проблемой, но в целом это не есть оптимальный стилуществования для такой функционально сти. На другой стороне будет только один веб-
сервис. Если данный сервис станет недоступным, Circuit Breaker должен прервать всопытки подключения к этому сервису. Если используется несколько экземпляров
CircuitBreakerProductManagementAgent, то это должно выполняться для каждого иих.
Более компактный IC ircuitBreaker
Как представлено в данном разделе, интерфейс ICircuitBreaker содержит три члена:
Guard, Succeed и Trip. В альтернативно м определении интерфейса мог использоватьстиль передачи продолжений для того, чтобы сократить объем до нескольких единождспользуемых методов:
public interface ICircuitBreaker
{
void Execute(Action action);
T Execute<T>(Func<T> action);
}
Это позволило бы нам более сжато применять ICircuitBreaker в каждом методеодобно тому, как это показано ниже:
public void InsertProduct(ProductEditorViewModel product)
{
this.breaker.Execute(() =>
this.innerAgent.InsertProduct(product));
}
343
Я решил использовать более явную и старомодную версию ICircuitBreaker, посколькне хочется, чтобы вы могли сконцентрироваться на текущей теме – механизм перехвата.
Несмотря на то, что лично мне нравится стиль передачи продолжений, я считаю лямбда женерики по-своему продвинутыми тематиками, и думаю, что в данном контексте оногли бы скорее отвлечь наше внимание, нежели стать полезными.
Предпочтем ли мы, в конечном итоге, одно определение интерфейса другому, не меняеезультат текущей главы.
Это очевидный случай для задания стиля существования Singleton для CircuitBreaker, накже это означает, что CircuitBreaker должен быть потоко-безопасным. Согласно своеущности CircuitBreaker сохраняет состояние; потоко-безопасность должна бытеализована явным образом. Это делает реализацию даже более сложной.
Несмотря на сложность CircuitBreaker, вы с легкостью можете перехватить экземпляр
IProductManagementAgent с помощью Circuit Breaker. Хотя первый пример механизмерехвата в разделе 9.1.1 "Пример: реализация аудита" был довольно простым, пример
Circuit Breaker демонстрирует, что вы можете перехватить класс с помощью сквозныущностей, чья реализация просто более сложна, чем первоначальная реализация.
Паттерн Circuit Breaker гарантирует, что приложение незамедлительно прервет своыполнение вместо того, чтобы связывать драгоценные ресурсы; но в идеале приложение будет полностью разрушено. Для того чтобы справиться с данной проблемой, вожете реализовать некоторые виды обработки ошибок с помощью механизма перехвата.
Обработка исключений
Вероятно, зависимости время от времени выдают исключения. Даже написанныаилучшим образом код будет (и должен) выдавать исключения, если сталкивается итуациями, с которыми не может справиться. Клиенты, использующие внешние ресурсыопадают в данную категорию. Класс, подобный классу WcfProductManagementAgent иаблонного WPF-приложения, является одним из примеров таких зависимостей. Еслеб-сервис недоступен, агент начинает выдавать исключения.
Circuit Breaker не изменяет этому фундаментально му свойству. Несмотря на то, что оерехватывает WCF клиента, он все равно выдает исключения.
Вместо сбоя приложения, вы могли бы выбрать возможность предоставления окнообщения, которое сообщало бы вам о том, что операция не выполнилась, и что ваеобходимо повторить попытку позднее.
Вы можете использовать механизм перехвата для того, чтобы добавить обработку ошибо стиле SOLID. Вы не хотите нагружать зависимость обработкой ошибок. Посколькависимость должна рассматриваться как повторно используемый компонент, которыожно использовать во множестве различных сценариев, было бы невозможно добавить аму зависимость стратегию обработки исключений, которая бы подходила для всеценариев. Если бы вы так сделали, то это противоречило бы принципу единственнответственности.
344
Используя механизм перехвата для обработки исключений, вы соблюдаете принциткрытости/закр ытости. Это позволяет вам реализовать самую лучшую стратегибработки ошибок для любой конкретной ситуации. Давайте рассмотрим пример.
Пример: обработка исключений
В предыдущем примере вы обертывали WcfProductManagementAgent в Circuit Breaker длспользования в клиентском приложении Product Management , впервые введенном азделе 7.4.2 "Пример: присоединение ценного клиента управления товарами". Circuit
Breaker справляется с ошибками, определяя, что клиент незамедлительно прервет своыполнение, но он все равно будет выдавать исключения. Оставшись необработаннымти ошибки приведут к сбою приложения, поэтому вам следует реализовать Decoratorоторый знает, как обрабатывать некоторые из этих ошибок. При выдаче исключениолжно всплывать сообщение, как это показано на рисунке 9-7.
Рисунок 9-7: Приложение Product Management обрабатывает исключения, касающиесзаимодействия, путем предоставления пользователю сообщения. Обратите внимание, чт данном примере сообщение об ошибке порождается Circuit Breaker, а нышеупомянутым нарушением взаимодействия.
Реализовать такое поведение легко. Таким же образом, как вы делали это в разделе 9.2.1
"Осуществление перехвата с помощью Circuit Breaker", вы добавляете новый класс
ErrorHandlingProductManagementAgent, который дополняет интерфейс
IProductManagementAgent. Следующий листинг демонстрирует шаблон одного иетодов данного интерфейса, но все эти методы похожи друг на друга.
345
Листинг 9-5: Обработка исключений
1. public void InsertProduct(ProductEditorViewModel product)
2. {
3. try
4. {
5. this.innerAgent.InsertProduct(product);
6. }
7. catch (CommunicationException e)
8. {
9. this.AlertUser(e.Message);
10. }
11. catch (InvalidOperationException e)
12. {
13. this.AlertUser(e.Message);
14. }
15. }
Строка 5: Делегирует полномочия расширенному агенту
Строка 9, 13: Предупреждает пользователя об опасности
Метод InsertProduct – это представитель целостной реализации класса
ErrorHandlingProductManagementAgent. При возникновении исключения вы пытаетесызвать расширенного агента и предупредить пользователя об опасности с помощьообщения об исключении. Обратите внимание, что вы обрабатываете толькпределенный набор известных исключений, потому что пресекать все исключения былы опасно.
Предупреждение пользователя об опасности включает в себя форматирование строки емонстрацию этой строки пользователю посредством метода MessageBox.Show.
И снова вы добавили функциональность к первоначальной реализации
(WcfProductManagementAgent) путем реализации Decorator'а. Вы строго соблюдаете каринцип единственной ответственности, так и принцип открытости/закр ытостиоследовательно добавляя новые типы вместо модификации существующего кода. К
настоящему моменту вы должны были уже начать видеть паттерн, который подразумеваеолее общую систематизацию, нежели Decorator.
Для данной сквозной сущности реализация, основанная на Decorator, склонна овторяемости. Реализация Circuit Breaker включает в себя применение одного и того жаблона кода ко всем методам интерфейса IProductManagementAgent. Если бы вы хотелобавить Circuit Breaker в другую абстракцию, то вам пришлось бы применить этот жамый код еще и к другим методам. Несмотря на то, что шаблоны отличаются, то жамое справедливо и для кода обработки исключений, который мы только чтассматривали.
Для того чтобы закрепить этот вопрос, давайте вкратце рассмотрим реализацию аспектезопасности. Данный аспект будет предполагать более общий подход к компоновкквозных сущностей, который мы в дальнейшем рассмотрим в разделе 9.3.
346
Добавление функциональности обеспечения безопасности
Безопасность – это еще одна универсальная сквозная сущность. Мы хотели бы, насколькто возможно, обезопасить наши приложения от несанкционированного доступа к важноункциональности.
Примечание
Безопасность – это обширная тема для обсуждения, которая охватывает множествбластей, включая раскрытие важной информации и взлом сетей. В данном разделе ишь вкратце коснусь такой темы, как авторизация – т.е. возможность убедиться в томто только авторизованные пользователи (или системы) могут выполнять определенныействия.
Аналогично тому, как мы использовали Circuit Breaker, нам хотелось бы перехватитызов метода и проверить, должен ли этот вызов быть разрешен. Если не должен, тместо разрешения вызова будет выдано исключение. Принцип тот же: разницаключается в критерии, который мы используем для определения обоснованностызова.
Универсальный подход к реализации логики авторизации – применить защиту нсновании ролей с помощью Thread.CurrentPrincipal. Вы могли бы начать с Decorator'а
SecureProductRepository. Поскольку, как вы уже видели в предыдущих разделах, всетоды похожи друг на друга, следующий листинг демонстрирует всего лишь реализациаблонного метода.
Листинг 9-6: Явная проверка авторизациublic override void InsertProduct(Product product)
{
if (!Thread.CurrentPrincipal.IsInRole("ProductManager"))
{
throw new SecurityException();
}
this.innerRepository.InsertProduct(product);
}
Метод InsertProduct начинается с граничного оператора, который явным образоызывает Thread.CurrentPrincipal и запрашивает, обладает ли он ролью
ProductManager. Если он не обладает данной ролью, то он незамедлительно выдаесключение. Только если вызываемый IPrincipal имеет требуемую роль, вы позволяетму обойти граничный оператор и вызвать расширенный репозиторий.
Примечание
Запомните, что Thread.CurrentPrincipal – это пример паттерна Ambient Context.
То, что Thread.CurrentPrincipal инкапсулируется в классе
System.Security.Permissions.PrincipalPermission, является всеобщей идиомоодирования; поэтому вы могли бы написать предыду щий пример более сжато:
347
public override void InsertProduct(Product product)
{
new PrincipalPermission(null, "ProductManager").Demand();
this.innerRepository.InsertProduct(product);
}
Класс PrincipalPermission инкапсулирует запрос о том, имеет ли текущий IPrincipaпределенную роль. Вызов метода Demand приведет к выдаче исключения, если
Thread.CurrentPrincipal не имеет ролей ProductManager. Данный примеункционально эквивалентен листингу 9-6.
Когда единственное, что вы требуете, – чтобы текущий IPrincipal имел определенну оль, вы можете перейти к чисто декларативному стилю:
[PrincipalPermission(SecurityAction.Demand, Role = "ProductManager")]
public override void InsertProduct(Product product)
{
this.innerRepository.InsertProduct(product);
}
Аттрибут PrincipalPermission предлагает ту же самую функциональность, что и класс
PrincipalPermission, но раскрывается в виде атрибута. Поскольку .NET Frameworонимает этот атрибут, где бы он его ни встречал, он выполняет соответствующеребование PrincipalPermission.
На данном этапе наличие отдельного Decorator только с целью применения атрибутыглядит слегка уничтожающим. Почему бы не применить атрибут напрямую к самомервоначальному классу? Несмотря на то, что это кажется довольно привлекательнымуществует несколько причин, почему вы можете не захотеть поступить именно так:
? Использование атрибутов исключает более сложную логику. Что если бы вахотели разрешить большинству пользователей обновлять описание товаров, нбновлять цену – только ProductManager'ам? Такая логика может быть выражена мперативном коде, но с помощью атрибутов сделать это легко не получится.
? Что если бы вы захотели убедиться, что правила разрешения доступа используютсезависимо от того, какую реализацию ProductRepository вы используете?
Поскольку атрибуты конкретных классов не могут повторно использоваться амках реализаций, это привело бы к нарушению принципа "не повторяйся".
? Вы не смогли бы варьировать логику обеспечения безопасности независимо от
ProductRepository.
Однако идея обращения к сквозным сущностям в декларативной манере не нова.
Поскольку она часто применяется в аспектно-ориентированно м программировании, онодходит нам только в том плане, что мы более близко рассматриваем саму эту идею и тоак она приводит нас к слабо связанному механизму перехвата.
348
9.3. Объявление аспектов
В предыдущих разделах мы рассматривали паттерны механизма перехвата и то, как оногут помочь вам обратиться к сквозным сущностям с помощью SOLID принципов. В
разделе 9.2.3 "Добавление функциональности обеспечения безопасности" вы увидели, каожно было сократить объем реализации такого аспекта, как проверка безопасности, дисто декларативного подхода.
Применение атрибутов для объявления аспектов является универсальным приемоспектно-ориентированного программирования (AOP). Но сколь заманчивым бы он назался с первого взгляда, использование атрибутов сопровождается некоторого родстроенными проблемами, которые делают применение атрибутов менее чем идеальныешением. Первую часть данного раздела я буду использовать для того, чтобы дать обзотой сущности и ее малоизвестных недостатков.
Примечание
Я периодически использую термин атрибут аспекта, обозначающий пользовательскитрибут, реализующий или выражающий аспект.
Поскольку мы, в сущности, отбросили в сторону идею об использовании атрибутов длбъявления аспектов, остальную часть данной главы мы проведем за рассмотрениеинамического перехвата с помощью DI-контейнера, который предоставляет лучшультернативу.
Использование атрибутов для объявления аспектов
Атрибуты имеют общую с Decorator'ами черту: несмотря на то, что они могут добавлятли подразумевать изменение поведения члена, сигнатуру они оставляют неизменной. Каы видели в разделе 9.2.3 "Добавление функционально сти обеспечения безопасности", вожете заменить явный, императивный код авторизации на атрибут. Вместо того чтобаписать одну или более одной строки явного кода, вы могли бы достичь того жезультата, применяя атрибут [PrincipalPermission].
Довольно заманчиво было бы экстраполировать эту концепцию в другие сквозныушности. Было бы это здорово, если бы вы могли отметить метод или класс атрибутом
[HandleError] или даже пользовательским атрибутом [CircuitBreaker], и, такибразом, применить аспект при помощи единственной строки декларативного кода?
Возможно, это было бы здорово, но существует несколько проблем, связанных с данныодходом, которые вы должны понять.
В первую очередь это проблема, которая вырастает из того факта, что атрибуты, пвоему существу, являются пассивными. Несмотря на то, что определениользовательского атрибута и применение его столь же просто, как наследование класст System.Attribute и наделение других классов пользовательским атрибутом, оаходится там, ничего при этом не делая.
Но подождите! Разве атрибут [PrincipalPermission] не изменил поведение метода? Дато так, но этот атрибут (и некоторые другие атрибуты, доступные в стандартной
349
библиотеке классов) – особенный. .NET Framework понимает этот атрибут и влияет него, но .NET Framework не будет так делать для всякого пользовательского атрибутаоторый вам захотелось бы ввести.
Если вы хотите разрешить пользовательским атрибутам изменять поведение приложенияо у вас есть два варианта:
? Изменить шаг компиляции
? Ввести пользовательский хост рабочей среды
Давайте вкратце исследуем каждый вариант.
Модификация компиляции
Работа одного из самых популярных фреймворков аспектно-ориентированногрограммирования, PostSharp, заключается именно в разрешении вам добавлятользовательские атрибуты в код. Эти атрибуты должны наследоваться от специальногтрибута, который определен в PostSharp SDK, предоставляющем виртуальные методыоторые вы можете переопределить для того, чтобы задать желаемое вами поведениспекта. Затем вы можете применить эти атрибуты к своим классам или членам класса.
Рисунок 9-8 демонстрирует, что случится потом.
Рисунок 9-8: Работа PostSharp заключается в добавлении шага посткомпиляции послого, как будет завершена обычная компиляция. Поскольку пользовательские PostSharтрибуты в вашем коде трактуются обычным компилятором (например, csc.exe) так жеак и любые другие атрибуты, выходной результат – это обычная сборка с пассивнымтрибутами. В PostSharp входит шаг посткомпиляции, на котором PostSharp собираекомпилированну ю сборку и чередует код ваших пользовательских атрибутов напрямую трибутивным кодом. Результатом является новая .NET сборка с вложенными аспектами.
PostSharp полагается на посткомпиляцию для того, чтобы преобразовать пассивнытрибуты в активный код. PostSharp процессор присматривает за атрибутаминаследованными от PostSharp атрибутов, и чередует код этих атрибутов с кодомасширенным этими атрибутами. Результат – новая сборка, в которой соответствующиод аспекта чередуется с первоначальным кодом.
Эта сборка – абсолютно обычная сборка, которая запускается всюду, где запускается весстальной .NET код. Для этого не требуется никакой специальной рабочей среды.
Среди преимуществ данного подхода можно отметить тот факт, что для него не требуетсикак особых усилий с вашей стороны. Механизм внедрения зависимостей не необходимотя и не исключается. Я уверен, что есть и другие преимущества.
Один из недостатков данного подхода – тот факт, что запускаемый код отличается оаписанного вами кода. Если вы захотите отладить код, то вам нужно будет выполнитсобые шаги, и, несмотря на то, что поставщик с радостью предоставляет средства,
350
позволяющие вам выполнить только отладку, он к тому же направляет вас к антипаттерну
Vendor Lock-In.
Но самый большой недостаток заключается в использовании самих атрибутов. Этоедостаток идет в одном ряду с использованием пользовательского хоста для активацитрибутов. Давайте сделаем обзор данного варианта перед тем, как рассмотретедостатки атрибутов.
Использование пользовательского хоста
Еще один вариант активации атрибутов заключается в требовании, чтобы весь коктивировался или инициализировался при помощи пользовательского хоста илабрики. Такая фабрика смогла бы проверять все атрибуты классов, которые оннициализирует, и действовать соответствующим образом.
Мы знаем данный прием из многочисленных .NET технологий, которые полагаются нтрибуты. Примерами этого приема являются:
? В WCF входит множество атрибутов, например, [ServiceContract],
[OperationContract] и т.д. Эти атрибуты приобретают поведение только, когды размещаете сервис в экземпляре ServiceHost (то же самое для вас делает и IIS).
? ASP.NET MVC дает вам возможность указать, какой HTTP verbs вы допустите трибутом [AcceptVerbs], а также дает вам возможность обрабатыватсключения с помощью атрибута [HandleError], и еще несколько другиозможностей. Это возможно, поскольку ASP.NET MVC – это один большоользовательский хост, и он управляет жизненными циклами своих контроллеров.
? Все .NET фреймворки модульного тестирования, о которых я осведомленспользуют атрибуты для идентификации тестовых сценариев. Фреймвородульного тестирования инициализиру ет тестовые сценарии и интерпретируетрибуты, чтобы указать, какой из тестов необходимо выполнить.
Компоновка объектов с помощью DI-контейнера аналогична этим примерам. Поскольку
DI-контейнер инициализирует экземпляры включенных в него классов, он имееозможность просматривать каждый класс в поисках пользовательских атрибутов.
Вас не должно удивлять то, что многие DI-контейнеры обладают возможностями, которыозволяют вам делать именно это. Если вы уже решили использовать DI-контейнеролжны ли вы идти до конца и определять, и применять пользовательские атрибуты?
Я могу подразумевать только одно преимущество, которое такое поведение дает наасательно динамического перехвата: поскольку атрибут очень легко обнаружить, дажсли он предлагает достаточно привлекательный уровень преобразования данных, вы всавно получаете ценный намек на то, что что-то происходит, нежели тот намек, которыает рассматриваемое вами тело метода.
Но есть и недостатки применения сквозных сущностей с помощью атрибутов. Этедостатки являются общими для пост-компиляции и пользовательских хостов.
Недостатки атрибутов аспектов
Насколько бы привлекательной ни казалась возможность реализации аспектов в видользовательских атрибутов, существуют некоторые недостатки такого подхода.
351
Во-первых, атрибуты компилируются совместно с кодом, который они расширяют. Этзначает, что вы не сможете так просто изменить ход своих мыслей. Рассмотрим ачестве примера процесс обработки ошибок. В разделе 9.2.2 "Обработка исключений" видели, как можно использовать паттерн проектирования Decorator для того, чтобеализовать обработку ошибок для любого IProductManagementAgent. Интересно то, чтпомянутый выше WcfProductManagementAgent ничего не знает об
ErrorHandlingProductManagementAgent. Как проиллюстрировано на рисунке 9-9, онеализованы даже в разных библиотеках.
Рисунок 9-9: Как ErrorHandlingProductManagementAgent, так и
WcfProductManagementAgent реализуют IProductManagementAgent, но определены они вух различных библиотеках. Поскольку сборка ProductManagementClient содержит
Com position Root, она зависит от ProductWcfAgent и PresentationLogic.
Основная реализация, предложенная WcfProductManagementAgent, не содержит явноункциональности обработки ошибок, поскольку истинный процесс обработксключений является контексто-зависимым. В GUI приложениях, например, в WPF
приложении, которое мы не так давно использовали в качестве примера, хорошетратегией может стать диалоговое сообщение, но в консольном приложении вместиалогового сообщения вы, вероятнее всего, предпочли бы создавать выходной потошибок, а автоматизированный сервис мог бы перемещать операцию с целью повтореничереди и продолжать выполнять что-то еще.
Для того чтобы сохранять свою открытость и гибкость, библиотека ProductWcfAgent нолжна включать в себя обработку ошибок. Но, если вы применяете атрибут аспекта к
WcfProductManagementAgent (или, что еще хуже, к IProductManagementAgent), то вильно привязываете этот аспект к реализации (или даже к абстракции). Если вы так
352
поступаете, то вы навязываете WcfProductManagementAgent определенну ю стратегибработки ошибок, и теряете способность варьировать аспекты независимо от реализации.
Вторая проблема, связанная с атрибутами аспектов, заключается в том, что, у вас естишь ограниченное количество вариантов применения атрибутов, которые могуспользоваться только на следующих уровнях:
? Параметры, включая возвращаемые значения
? Члены, например, методы, свойства и поля
? Типы, например, классы и интерфейсы
? Библиотеки
Несмотря на то, что атрибуты аспектов предоставляют вам широкий круг возможностейы не можете с легкостью выразить большее количество конфигураций, основанных ноглашениях, например, "Я хочу применить аспект Circuit Breaker ко всем типам, именоторых начинаются с Wcf". Вместо этого вам пришлось бы применить гипотетическитрибут [CircuitBreaker] ко всем подходящим классам, нарушающим принцип DRY
(Don't Repeat Yourself – Не повторяйся).
Последний недостаток атрибутов аспектов – атрибуты должны обладать простыонструктором. Если вам нужно использовать зависимости от аспекта, вы можете сделатто только с помощью Ambient Context. Вы уже видели пример этого в разделе 9.2.3
"Добавление функциональности обеспечения безопасности", где
Thread.CurrentPrincipal является Ambient Context. Но данный паттерн в редких случаявляется наиболее подходящим, и делает процесс управления жизненным циклом болерудным. К примеру, совместное использование ICircuitBreaker в рамканогочисленных WCF клиентов неожиданно становится более сложным.
Несмотря на все эти недостатки, привлекательно сть атрибутов аспектов заключается ом, что вам приходится реализовывать код аспекта только в одном единственном месте.
В следующем разделе вы увидите, как можно использовать возможности перехвата DI-
контейнеров для того, чтобы достичь этой цели, не связывая при этом сильно атрибутспектов.
Применение динамического перехвата
До настоящего момента вы видели, как можно использовать Decorator'ы для обращения квозным сущностям и их реализации. Данный прием удовлетворяет SOLID принципу, нарушает DRY принцип. Возможно, это и не видно из примеров данной главы, нрименение аспекта путем ручной разработки расширений классов включает в себгромное количество повторяющегося кода.
Повторяемость Decorator'ов
Примеры из разделов 9.1.1 "Пример: реализация аудита" и 9.2.1 "Осуществлениерехвата с помощью Circuit Breaker" демонстрируют только репрезентативные методыоскольку каждый метод реализуется одинаково, а мне не хотелось загружать нескольктраниц практически идентичным кодом, так как это отвлекало бы нас от того, что массматриваем. Следующий листинг демонстрирует, как похожи методы
CircuitBreakerProductmanagementAgent. Этот листинг демонстрирует только два метода
353
интерфейса IProductManagementAgent, но я уверен, что вы сможете экстраполировать и представить, как выглядит остальная реализация.
Листинг 9-7: Нарушение DRY принципа
1. public void DeleteProduct(int productId)
2. {
3. this.breaker.Guard();
4. try
5. {
6. this.innerAgent.DeleteProduct(productId);
7. this.breaker.Succeed();
8. }
9. catch (Exception e)
10. {
11. this.breaker.Trip(e);
12. throw;
13. }
14. }
15. public void InsertProduct(ProductEditorViewModel product)
16. {
17. this.breaker.Guard();
18. try
19. {
20. this.innerAgent.InsertProduct(product);
21. this.breaker.Succeed();
22. }
23. catch (Exception e)
24. {
25. this.breaker.Trip(e);
26. throw;
27. }
28. }
Строка 6, 20: Единственное отличие
Так как вы уже видели метод InsertProduct в листинге 9-4, цель данного примера кода –
проиллюстрировать повторяющу юся сущность Decorator'ов, используемых в видспектов. Единственное отличие между методами DeleteProduct и InsertProduct – это, что каждый из них вызывает свой собственный соответствующий метод расширенноггента.
Даже если мы успешно делегировали реализацию Circuit Breaker отдельному классосредством интерфейса ICircuitBreaker, этот код инфраструктуры явно нарушает DRY
принцип. Он может быть склонен к разумной неизменности, но все равно обязателен.
Всякий раз, когда вам хочется добавить новый член к типу, который вы расширяете, илогда вам хочется применить Circuit Breaker к новой абстракции, вы должны применяттот же самый код инфраструктуры.
В качестве одного из способов решения данной проблемы вы могли бы рассматриватрименение таких генераторов кода, как Text Template Transformation Toolkit (T4) от
Visual Studio, но многие DI-контейнеры предлагают лучший вариант решения этороблемы – посредством динамического перехвата.
354
Автоматизация Decorator'ов
Код в каждом методе листинга 9-7 очень похож на шаблон. Самая сложная составляющароцесса реализации Decorator'а в виде аспекта – проектирование этого шаблона, но послого, как шаблон спроектирован, остальное – это уже просто механический процесс:
? Создать новый класс
? Унаследовать от нужного интерфейса
? Реализовать каждый член интерфейса путем применения шаблона
Данный процесс является настолько механическим, что вы можете использовать какой-
либо инструмент для его автоматизации. Такой инструмент использовал бы рефлексию хожие API для того, чтобы найти все члены, которые нужно реализовать, а затерименял бы шаблон ко всем этим членам. Рисунок 9-10 демонстрирует, как этроцедуру можно применить с помощью T4 шаблона.
Рисунок 9-10: T4 делает возможной автоматическую генерацию кода Decorator'а иаблонов. Стартовая точка – прототип шаблона, который понимает основную концепцию
Decorator'а. Прототип шаблона содержит код генерации кода, который будет генерироватраницы расширяемого класса, но не определяет никакого кода аспекта. Из прототипаблона разрабатывается шаблон аспекта, который описывает, как должен применятьсонкретный аспект (например, Circuit Breaker) при расширении любого интерфейса.
Результатом является специализированный шаблон (SomeAspect.tt) этого конкретногспекта, который можно использовать для генерации Decorator'ов конкретнынтерфейсов. Результат – обычный файл кода (SomeAspectDecorator.cs), который обычномпилируется вместе с другими файлами кода.
Несмотря на то, что генераторы кода позволяют вам справляться с симптомамовторяющегося кода, они все равно на своем пути оставляют большое количествовторяющегося кода. Если вы верите, что код обязателен, то больший объем кодриведет к большим затратам, независимо от того, автоматически он генерируется илет.
Даже если вы не купитесь на этот аргумент, у вас все еще есть статический набор авто-
генерируемых Decorator'ов. Если вам понадобится новый Decorator для данноомбинации аспекта и абстракции, то вы должны явным образом добавить данный класс.
Он может генерироваться автоматически, но вам все равно нужно не забыть создать его рисоединить. Более условный подход в данном случае не возможен.
Некоторые DI-контейнеры предоставляют вам вариант, который лучше автоматическенерируемого кода: автоматически генерируемые классы. Возможно, разница междтими вариантами кажется скрытой, но продолжайте читать дальше.
355
Динамический перехват
Одной из множества значительных возможностей .NET Framework является возможностинамически порождать типы. Помимо автоматической генерации кода во времроектирования, также возможно написать код, который порождаеолнофункциональный класс во время выполнения. Такой класс не имеесновообразующего файла исходного кода, но компилируется напрямую из некоторобстрактной модели.
Таким же образом, как вы можете автоматизировать генерацию Decorator'ов в файласходного кода, вы можете автоматизировать генерацию Decorator'ов, которыорождались бы прямо во время процесса выполнения. Как демонстрирует рисунок 9-11то как раз то, что и позволяет вам выполнить динамический перехват.
Примечание
Не все DI-контейнеры поддерживают перехват во время выполнения; если вам нужнанная возможность, позаботьтесь о том, чтобы ваш DI-контейнер был подобраоответствующим образом.
Рисунок 9-11: Некоторые DI-контейнеры позволяют нам определять аспекты в видерехватчиков. Перехватчик – фрагмент кода, который реализует аспект заимодействует с контейнером. Регистрация перехватчика с помощью контейнерозволяет контейнеру динамически создавать и порождать Decorator'ы, которые содержаоведение аспекта. Эти классы существуют только во время выполнения.
Для применения динамического перехвата вам все равно нужно написать код, которыеализует аспект. Это мог бы быть код инфраструктуры, необходимый для аспекта Circuit
Breaker, что продемонстрировано в листинге 9-7. Как только вы написали этот код, волжны сообщить DI-контейнеру об этом аспекте и о том, когда ему следует егрименять.
Во время выполнения DI-контейнер будет динамически порождать новые классы ыполняемом AppDomain, основанном на зарегистрированных аспектах. Самое лучшее анном подходе – это то, что вы можете использовать конфигурацию на основоглашений для того, чтобы определить, как применяются аспекты, и можете решитспользовать разные соглашения в разных приложениях (например, несмотря на то, чты можете совместно использовать множество библиотек, в WPF приложении и
PowerShell приложении у вас могут быть разные стратегии обработки ошибок).
356
Примечание
В аспектно-ориентированном программировании соглашение, которое сопоставляеспекты с классами и членами, называется Pointcut.
Хватит теории – давайте рассмотрим пример.
Пример: перехват с помощью Windsor
Благодаря их повторяющемуся коду аспекты Circuit Breaker и обработчик ошибок иазделов 9.2.1 "Осуществление перехвата с помощью Circuit Breaker" и 9.2.2 "Обработксключений" являются отличными кандидатами для динамического перехвата. В качествримера давайте рассмотрим, как можно получить DRY, SOLID код с помощьозможностей перехвата Castle Windsor.
Примечание
Вместо Castle Windsor я мог бы выбрать и другой DI-контейнер, но определенно нюбой. Некоторые DI-контейнеры поддерживают механизм перехвата, а остальные ноддерживают – в части 4 рассматриваются возможности конкретных DI-контейнеров.
В данном примере вы будете реализовывать и регистрировать перехватчики как длбработчика ошибок, так и для Circuit Breaker. Добавление аспекта в Windsor – этроцесс, состоящий из трех шагов, как это продемонстрировано на рисунке 9-12.
Рисунок 9-12: Три шага, составляющие процесс добавления аспекта в Windsor
В данном примере вы будете выполнять эти шаги для обоих аспектов. Обработку ошибоеализовать проще всего, поскольку у нее нет зависимостей; давайте начнем с этогспекта.
Реализация перехватчика обработки ошибок
Реализация перехватчика для Windsor требует от нас реализации интерфейса
IInterceptor, который имеет всего один метод. Следующий листинг демонстрирует, каеализовать стратегию обработки ошибок из листинга 9-5, но в отличие от листинга 9-5
следующий листинг демонстрирует весь класс.
Листинг 9-8: Реализация перехватчика обработки ошибок
1. public class ErrorHandlingInterceptor : IInterceptor
2. {
3. public void Intercept(IInvocation invocation)
4. {
5. try
6. {
7. invocation.Proceed();
8. }
357
9. catch (CommunicationException e)
10. {
11. this.AlertUser(e.Message);
12. }
13. catch (InvalidOperationException e)
14. {
15. this.AlertUser(e.Message);
16. }
17. }
18. private void AlertUser(string message)
19. {
20. var sb = new StringBuilder();
21. sb.AppendLine("An error occurred.");
22. sb.AppendLine("Your work is likely lost.");
23. sb.AppendLine("Please try again later.");
24. sb.AppendLine();
25. sb.AppendLine(message);
26. MessageBox.Show(sb.ToString(), "Error",
27. MessageBoxButton.OK, MessageBoxImage.Error);
28. }
29. }
Строка 1: Реализация IInterceptor
Строка 5-6, 8-16: Реализация аспекта
Строка 7: Вызов расширенного метода
Строка 18: Демонстрация диалогового окна
Для того чтобы реализовать перехватчик, вы должны выполнить наследование онтерфейса IInterceptor, определенного Windsor. Нужно реализовать всего один метод вы делаете это путем применения того же самого кода, который вы не раз использовалиогда реализовывали ErrorHandlingProductManagementAgent.
Единственное отличие от листинга 9-5 – вместо того, чтобы делегировать вызов методонкретному методу, вы должны обобщить все, поскольку применяете этот код отенциально любому методу. Вы даете Windsor указание, позволить вызову пройтальше к расширенной строке, вызывая для этого метод Proceed для входного параметрnvocation.
Интерфейс IInvocation, переданный в метод Intercept в качестве параметраредставляет собой вызов метода. К примеру, он мог бы представлять вызов метода
InsertProduct. Метод Proceed – один из ключевых членов данного интерфейсаоскольку он дает нам возможность позволить вызову пройти к следующей реализацитека.
Интерфейс IInvocation также дает вам возможность установить выходное значениеред тем, как разрешить вызову пройти дальше, а также обеспечивает доступ одробной информации о вызове метода. Из параметра invocation можно получитнформацию об имени метода и значениях параметра, а также множество другонформации о текущем вызове метода.
Реализация перехватчика – сложный шаг. Следующий шаг – полегче.
358
Регистрация перехватчика обработки ошибок
Перехватчик необходимо зарегистрировать с помощью контейнера до того, как его можнудет использовать. Данный шаг не устанавливает правила, управляющие тем, как и когдктивизируется перехватчик (Pointcut), а только делает его доступным в виде компонента.
Примечание
Вы можете рассматривать этот шаг как формальность для соответствия требованиям
Windsor. Одна из причуд Windsor заключается в том, что каждый компонент должен бытарегистрирован явным образом, даже когда он является конкретным типом, обладающионструктором по умолчанию. Не все DI-контейнеры работают таким образом, но в
Windsor такое поведение преднамеренно.
Зарегистрировать класс ErrorHandlingInterceptor легко (container – это экземпляр
IWindsorContainer):
container.Register(Component.For<ErrorHandlingInterceptor>());
Регистрация класса ErrorHandlingInterceptor ничем не отличается от регистрациюбого другого компонента с помощью Windsor, и вы даже могли бы решитспользовать подход, основанный на соглашениях для того, чтобы зарегистрировать всеализации IInterceptor, обнаруженные в конкретной сборке. Возможно, это похоже наблонный код из раздела 3.2 "Конфигурирование DI-контейнеров".
Последний шаг активации перехватчика – определить правила того, когда и карименяется этот перехватчик, но поскольку эти правила также должны затрагиватерехватчик Circuit Breaker, мы отложим этот шаг до тех пор, пока также не будет готов ругой перехватчик.
Реализация перехватчика C ircuit Breaker
Перехватчик Circuit Breaker несколько сложнее, поскольку для него необходимависимость ICircuitBreaker, но как демонстрирует следующий листинг, вы решаеттот вопрос путем применения стандартного Constructor Injection. Когда дело доходит домпоновки класса, Windsor обращается с ним как с любым другим компонентом: так кан может разрешать зависимость, то все в порядке.
Листинг 9-9: Реализация перехватчика Circuit Breaker
1. public class CircuitBreakerInterceptor : IInterceptor
2. {
3. private readonly ICircuitBreaker breaker;
4. public CircuitBreakerInterceptor(
5. ICircuitBreaker breaker)
6. {
7. if (breaker == null)
8. {
9. throw new ArgumentNullException(
10. "breaker");
11. }
12. this.breaker = breaker;
13. }
14. public void Intercept(IInvocation invocation)
15. {
359
16. this.breaker.Guard();
17. try
18. {
19. invocation.Proceed();
20. this.breaker.Succeed();
21. }
22. catch (Exception e)
23. {
24. this.breaker.Trip(e);
25. throw;
26. }
27. }
28. }
Строка 3-13: Constructor Injection
Строка 16-18, 20-26: Реализация аспекта
Строка 19: Вызов расширенного метода
Для CircuitBreakerInterceptor нужна зависимость ICircuitBreaker, а внедрениависимостей в IInterceptor выполняется с помощью Constructor Injection, как и в любыругих сервисах.
Как вы видели в листинге 9-8, вы реализуете интерфейс IInterceptor путем применениаблона, предложенного предыдущей, повторяющейся реализацией из листинга 9-4. Ещаз вместо вызова конкретного метода вы вызываете метод Proceed для того, чтобы датерехватчику указание, позволить обработке продолжить свое выполнение длледующего компонента стека Decorator.
К данному моменту вы должны начать понимать формирование паттерна. Вместо тогтобы повторять код инфраструктуры Circuit Breaker для каждого метода абстракции, вожете определить его всего один раз в перехватчике.
Также вам необходимо зарегистрировать класс CircuitBreakerInterceptor с помощьонтейнера; так как у класса есть зависимость, для этого потребуется не одна, а две строкода.
Регистрация перехватчика Circuit Breaker
Для перехватчика обработки ошибок нужна была только одна строка кода регистрациио, поскольку CircuitBreakerInterceptor зависит от ICircuitBreaker, вы должнарегистрировать и эту зависимость:
container.Register(Component
.For<ICircuitBreaker>()
.ImplementedBy<CircuitBreaker>()
.DependsOn(new
{
timeout = TimeSpan.FromMinutes(1)
}));
container.Register(Component.For<CircuitBreakerInterceptor>());
Вы преобразуете интерфейс ICircuitBreaker в конкретный класс CircuitBreaker, длоторого нужен такой параметр конструктора, как время ожидания.
360
Когда оба перехватчика находятся на своих местах, единственное, что нам еще нужно –
определить правила того, когда они будут активизироваться.
Активация перехватчиков
К настоящему моменту перехватчики реализованы и зарегистрированы с помощьонтейнера Windsor, но вам еще нужно определить, когда они будут активироваться. Еслы не сделаете это, они останутся всего лишь пассивными регистрациями в контейнере аже не будут вызываться.
Вы можете рассматривать этот шаг как аналог применения атрибутов аспектов. Если мрименяем к методу гипотетический атрибут [CircuitBreaker], то мы соединяем аспект
Circuit Breaker с этим методом. Определение и применение пользовательских атрибутов –
один из способов, с помощью которых мы можем активизировать перехватчиков Windsorо у нас еще есть несколько других, более подходящих доступных вариантов.
Самый гибкий – реализовать и зарегистрировать интерфейс
IModelInterceptorsSelector. Это дает нам возможность написать императивный кодоторый решает, какой перехватчик к каким типам и членам применять. Поскольку можем написать условно сложный код, мы имеем возможность применить наши аспектораздо более основанным на соглашениях способом.
В следующем листинге вы используете простую реализацию такого Pointcut.
Листинг 9-10: Реализация Pointcut
1. public class ProductManagementClientInterceptorSelector :
2. IModelInterceptorsSelector
3. {
4. public bool HasInterceptors(ComponentModel model)
5. {
6. return typeof(IProductManagementAgent)
7. .IsAssignableFrom(model.Service);
8. }
9. public InterceptorReference[]
10. SelectInterceptors(ComponentModel model,
11. InterceptorReference[] interceptors)
12. {
13. return new[]
14. {
15. InterceptorReference
16. .ForType<ErrorHandlingInterceptor>(),
17. InterceptorReference
18. .ForType<CircuitBreakerInterceptor>()
19. };
20. }
21. }
Строка 6-7: Применение перехватчиков к IProductManagementAgent
Строка 15-18: Возврат перехватчиков
Интерфейс IModelInterceptorsSelector руководствуется паттерном Tester-Doer.
Windsor сначала вызовет метод HasInterceptors, чтобы узнать, имеет ли данныомпонент, который он собирается инициализировать, какие-либо перехватчики. В
данном примере вы отвечаете на этот вопрос положительно, при этом компонент
361
реализует интерфейс IProductManagementAgent, но вы могли бы написать условнложный код, если бы захотели реализовать более эвристический подход.
Когда метод HasInterceptors вернет значение true, будет вызван метод
SelectInterceptors. Благодаря этому методу вы возвращаете ссылки на перехватчиковоторые вы уже зарегистрировали. Обратите внимание, что вы возвращаете нкземпляры перехватчиков, а ссылки на перехватчики, которые вы уже реализовали арегистрировали.
Это позволяет Windsor автоматически интегрировать любые перехватчики, которые могуметь свои собственные зависимости (например, CircuitBreakerInterceptor иистинга 9-9).
Знаете, что! Вам еще нужно зарегистрировать класс
ProductManagementClientInterceptorSelector с помощью контейнера. Это делаетсемного по-другому, но все равно вкладывается в одну строку кода:
container.Kernel.ProxyFactory.AddInterceptorSelector(
new ProductManagementClientInterceptorSelector());
Регистрация ProductManagementClientInterceptorSelector окончательно активизируеерехватчиков так, что когда вы разрешаете приложение с помощью Windsor, онвтоматически активизируются там, где они должны активизироваться.
Вы можете подумать, что этот многостраничный анализ перехватчиков Windsor довольнложен, но вам следует кое-что иметь ввиду:
? Вы реализовали два, не один, перехватчика.
? Я повторил некоторый фрагмент кода из предыдущих примеров для того, чтобоказать, как его можно приспособить. Не важно, решите ли вы писать Decorator'ручную, использовать фреймворк аспектно-ориентированного программированили использовать динамический перехват, вам всегда нужно будет писать кодоторый реализует аспект.
Динамический перехват предоставляет множество преимуществ. Он позволяет нам иметело со сквозными сущностями, соблюдая при этом и SOLID, и DRY принципы. Он даеам по-настоящему слабо связанные аспекты и возможность применять соглашения илложные эвристические правила для определения того, когда и где какие аспектрименять. Это максимальный уровень свободы и гибкости.
Вы можете беспокоиться о результатах исполнения компиляции и порождениользовательских типов "на лету", но насколько я смог определить, Windsor делает этолько один раз и повторно использует данный тип для последующих вызовов. Я сделаесколько неформальных отметок, не регистрируя никакого значительного ухудшенисполнения.
Еще одна проблема – добавленный уровень преобразования. Вы могли бы поспорить, чторименяя атрибуты аспектов, мы все равно оставляем в основном методе заметный слеого, что поведение, изменяющее аспекты, приходится к месту. Благодаря Decorator'ам инамическому перехвату в частности такой след отсутствует. Начинающие разработчикогли бы теоретически напороться на это полу-магическое поведение, завязнув в нем несколько дней, пока кто-нибудь не поможет им, объяснив концепцию.
362
В некоторых инфраструктурах это является реальной проблемой. Подумайте, как бы вправились с этой проблемой, если бы решили применить динамический перехват.
9.4. Резюме
Механизм внедрения зависимостей по-настоящему расцветает, когда дело доходит дрименения объектно-ориентированных принципов, например, SOLID. В частности, слабвязанная природа механизма внедрения зависимостей позволяет нам использовататтерн Decorator для того, чтобы соблюдать принцип открытости/закрытос ти, а такжринцип единственной ответственности. Эта возможность ценна в широком кругитуаций, поскольку позволяет нам оставлять наш код чистым и хорошо-
структурированным, но применяется особенно хорошо, когда дело доходит до сквозныущностей.
Сквозные сущности традиционно принадлежат области аспектно-ориентированногрограммирования, но также могут с большим успехом разрешаться с помощьеханизма внедрения зависимостей. Паттерн проектирования Decorator – это основноаттерн, позволяющий нам обертывать существующую функциональнос ть ополнительные уровни поведения, не изменяя первоначальный код.
Но, несмотря на свои многочисленные достоинства, главная проблема, связанная еализацией Decorator'ов, – это то, что они склонны к многословности и повторяемости.
Даже если вы можете соблюдать SOLID принципы проектирования, мы прекращаеарушать DRY принцип, поскольку нам нужно писать снова и снова один и тот же конфраструктуры – для каждого члена каждого интерфейса, который мы хотим расширит помощью конкретного аспекта.
Кажется, что атрибуты похожи на привлекательную альтернативу Decorator'ов, посколькни позволяют нам добавлять аспекты более сжатым способом. Но, поскольку атрибутомпилируются в коде, который они расширяют, они приводят к сильному связыванию, х применения нужно избегать.
Некоторые DI-контейнеры предлагают более привлекательну ю альтернативу благодарозможности динамически порождать Decorator'ы во время выполнения. Этинамические Decorator'ы обеспечивают перехват, который соблюдает как SOLID, так и
DRY принципы.
Интересно отметить, что динамический перехват – единственная особенность DI-
контейнеров, которая не имеет прямого эквивалента в Poor Man's DI. С этой точки зрения части 3 вы видели, как обращаться с композицией объектов и механизмом управлениизненным циклом с помощью благоразумного применения паттернов, но когда делоходит до механизма перехвата, самое близкое, что мы получаем – это множество
Decorator'ов.
Несмотря на то, что понятие Decorator сравнимо с механизмом перехвата, предпочтителекачок от множества закодированных вручную Decorator'ов к одному, а также DRY
перехватчик. Скачок от множества Decorator'ов к одному может привести к вспышковторяющегося кода инфраструктуры, тогда как использование DRY перехватчикредлагает возможность обращения к сквозным сущностям с помощью нескольких строода и в качестве дополнительного бонуса – возможность использовать применениспектов на основе соглашений.
363
Именно здесь, в заключении части 3, мы, наконец, достигаем той области, где DI-
контейнеры бесспорно оставляют Poor Man's DI позади. Даже без механизма перехвата
DI-контейнер может гораздо лучше управлять сложностью, вложенной в процесреобразования абстракций к конкретным типам, а также управлять их жизненнымиклами; но когда мы добавим к этому сочетанию механизм перехвата, мы уже не сможеазрушить комбинацию.
На этой ноте мы можем с радостью оставить Poor Man's DI за частью 3 и перейти тению информации о конкретных DI-контейнерах в части 4.
364
DI-контейнеры
Предыду щие части этой книги были посвящены разнообразным принципам и паттернамоторые совместно определяют механизм внедрения зависимостей. Как объяснялось лаве 3, DI-контейнер – это необязательный инструмент, который можно использовать длеализации большого количества общецелевой инфраструктуры, которую вам пришлосы реализовать иным образом, если бы вы использовали Poor Man's DI.
На протяжении всей книги я стремился по возможности сохранять ее, независимой оонтейнеров. Не принимайте это в качестве рекомендации Poor Man's DI; наоборот, отел, чтобы вы увидели механизм внедрения зависимостей в его истинной формеезапятнанным API какого-либо конкретного контейнера (возможно, необычным).
Есть небольшая причина того, чтобы потратить свое время на изучение Poor Man's DI, таак в .NET доступны многие превосходные DI-контейнеры. В данной части 4 представлеабор из 6 конкретных бесплатных контейнеров. В каждой главе я предоставляетальный обзор API конкретного контейнера, как он относится к масштабамхватываемым в части 3, а также другие разнообразные проблемы, которые являютсричинами бед начинающих разработчиков.
В части 4 рассматриваются такие контейнеры, как Castle Windsor, StructureMap,
Spring.NET, Autofac, Unity и MEF. Существуют и другие фреймворки контейнеровоторые я, по той или иной причине, не включил в данную книгу: Ninject, Hiro, Funq,
LinFu, OCInject и т.д. Пожалуйста, обратите внимание на то, что содержание данной книгамо по себе не является предвестником одобрения. Несмотря на то, что многие иключенных в эту книгу DI-контейнеров обладают превосходным качеством, это не былдинственным критерием отбора. Существуют конкретные контейнеры, которые я нключил в эту книгу всего лишь по причине той доли, в которой они представлены нынке. Между тем я решил описать остальные, поскольку они обеспечивают отличныонтраст благодаря их различным философиям проектирования и целям. Это такжзначает, что мне пришлось исключить некоторые превосходные контейнеры. Мнеонечно, хотелось бы включить в эту книгу все DI-контейнеры, но, увы, поскольку моространство ограниченно, это не возможно.
Каждая глава руководствуется общим шаблоном. Чтение одного и того же предложенио 6 раз может дать вам определенное ощущение дежавю, но я считаю это достоинствомоскольку такая структура глав должна дать вам возможность быстро находитналогичные разделы в рамках разных глав, если вы захотите сравнить, как конкретнаеталь раскрывается в рамках двух или более контейнеров. Для быстрого сравненибращайтесь к следующей таблице:
DI-контейнер Достоинства Недостатки
Castle
Windsor
Завершенность
Понимает Decorator
Типизированные фабрики
Доступно коммерческоопровождение
Местами извилистое API
365
DI-контейнер Достоинства Недостатки
StructureMap Просто работает ольшинстве случаев Не поддерживает механизм перехвата
Spring.NET
Механизм перехвата
Исчерпывающаокументация
Доступно коммерческоопровождение
Очень завязан на XML
Не подерживает API, основанное ноглашениях
Не поддерживает пользовательскиизненные циклы
Ограниченные возможности автоматическонтеграции
Autofac
Простое для изучения API
Доступно коммерческоопровождение
Не поддерживает механизм перехвата
Частично поддерживает пользовательскиизненные циклы
Unity
Механизм перехвата
Хорошая документация
Неизменное API
Небольшие возможности управлениизненным циклом
Не подерживает API, основанное ноглашениях
MEF
Доступен в .NET
4/Silverlight 4 BCL
Коммерческоопровождение
Не настоящий DI-контейнер
Конфигурация, основанная на статическитрибутах
Не поддерживает XML
Не поддерживает технологию использованиода в качестве конфигурации
Не подерживает API, основанное ноглашениях
Не поддерживает пользовательскиизненные циклы
Не поддерживает механизм перехвата
Многие из описанных здесь контейнеров – это проекты с открытым исходным кодоммеющие быстрые циклы выпуска. На момент написания книги информацияредставленная в части 4, была актуальна, но всегда старайтесь также консультироватьс более современными источниками.
Эти главы рассматриваются в качестве стимула. Если вы еще не подобрали тот контейнероторый вам больше всего нравится, то можете прочитать эти шесть глав, чтобы сравнитсе контейнеры, но можете прочитать одну или две главы, которые действительно вантересуют.
366
10. Castle Windsor
11. StructureMap
12. Spring.NET
13. Autofac
14. Unity
15. MEF
367
10. Castle Windsor
Меню:
? Знакомство с Castle Windsor
? Управление жизненным циклом
? Работа с составными компонентами
? Конфигурирование сложных API
В предыдущих девяти главах мы обсуждали паттерны и принципы, которые применяютс механизму внедрения зависимостей в общем, но за исключением нескольких примероы еще не рассматривали подробно то, как применять эти принципы и паттерны прспользовании конкретного DI-контейнера. В этой главе вы увидите, как все эти общиаттерны применяются к Castle Windsor; для того чтобы эта глава принесла ваолноценную пользу, вам нужно ознакомиться с материалом предыдущих глав.
Castle Windsor – второй по старшинству DI-контейнер .NET. Он является частью болерупного проекта с открытым исходным кодом, известного как Castle Project, которыредоставляет повторно используемые библиотеки для различных целей. Windsoвляется составляющей DI-контейнера в Castle Project, но может использоваться езависимо от любых других компонентов Castle. В этой главе мы рассмотрим его катдельный компонент.
Помимо того, что он является одним из самых старых DI-контейнеров, Castle Windsor ещ один из самых зрелых контейнеров, и, если верить нескольким совсем не научнынтернет-опросам, один из самых популярных контейнеров. Несмотря на то, что начатаботать с Windsor достаточно легко, он предлагает богатое и расширяемое API.
В данной главе мы попутешествуем по Castle Windsor. Когда мы завершим свой тур, волжны будете уже иметь достаточные знания об этом контейнере, чтобы суметезамедлительно применять его. Мы не собираемся рассматривать продвинутые сценариасширяемости, а вместо этого сконцентрируемся на главных паттернах применения.
Рисунок 10-1 демонстрирует структуру главы.
Рисунок 10-1: Структура данной главы похожа на дерево. Первый раздел знакомит вас онтейнером Castle Windsor и объясняет, как сконфигурировать и разрешить компоненты.
Остальные разделы, базирующиеся на введении, можно читать последовательно или болели менее независимо. В последнем разделе используется синтаксис и несколько методовоторые в первый раз встречаются в разделе, посвященном составным компонентамоэтому, если вы захотите пропустить предпоследний раздел, можете случайно вернутьс нему снова.
368
Первый раздел обеспечивает полноценное знакомство с Castle Windsor и демонстрируетак конфигурировать и разрешать компоненты. Следующие три раздела имеют дело аттернами применения, которые требуют излишнего внимания; вы можете прочитать исе по порядку или пропустить некоторые и читать только те, которые вас интересуют.
Данная глава должна дать вам возможность приступить к работе, а также коснутьсаиболее универсальных проблем, которые могут возникнуть при повседневноспользовании Castle Windsor. Глава 10 не является законченной трактовкой Castle
Windsor – на рассмотрение его могла бы уйти вся эта книга.
Вы можете прочитать эту главу изолированно от остальных глав части 4, чтобы изучитонкретно Castle Windsor, или можете прочитать ее совместно с другими главами, чтобравнить DI-контейнеры. Цель данной главы – показать, какое отношение Castle Windsoмеет к паттернам и принципам, описанным в предыдущих девяти главах, и как он иеализует.
10.1. Знакомство с Castle Windsor
10.2. Управление жизненным циклом
10.3. Работа с составными компонентами
10.4. Конфигурирование сложных API
10.5. Резюме
369
10.1. Знакомство с Castle Windsor
Из этого раздела вы узнаете, где можно взять Castle Windsor, что вы при этом получите ак начать его использовать. Кроме того, мы рассмотрим универсальные вариантонфигурации, а также то, как упаковать настройки конфигурации в повторнспользуемые компоненты. В таблице 10-1 содержится фундаментальная информацияоторая, скорее всего, понадобится вам для того, чтобы приступить к работе.
Как показывает рисунок 10-2, в Castle Windsor присутствует простая цикличность:
конфигурирование контейнера путем добавления компонентов, а затем разрешениеобходимых компонентов.
Рисунок 10-2: Общий паттерн применения Castle Windsor прост: сначала монфигурируем контейнер, затем разрешаем компоненты из этого контейнера. В
большинстве случаев мы создаем экземпляр WindsorContainer и полностьонфигурируем его перед тем, как начать разрешать компоненты из этого контейнера. Мазрешаем компоненты из того экземпляра, который конфигурируем.
Таблица 10-1: Краткая информация о Castle Windsor
Вопрос Ответ
Откуда мне еголучить?
Перейти на сайт http://www.castleproject.org/downloa d/ и нажать нсылку соответствующего релиза.
Из Visual Studio 2010 можно получить его посредством NuGet. Имакета – Castle.Windsor.
Что находится агруженном файле?
Можно загрузить zip-файл, содержащий предварительнкомпилированные бинарные файлы. Кроме того, можно получитекущий исходный код и скомпилировать его самостоятельно.
Бинарные файлы – это dll-файлы, которые можно размещать тамде захочется, и ссылаться на них из собственного кода.
Какие платформоддерживаются? .NET 3.5 SP1, .NET 4 Client Profile, .NET 4, Silverlight 3, Silverlight 4.
Сколько он стоит? Нисколько. Это программное обеспечение с открытым исходныодом, обладающее мягкой лицензией.
Где мне получитомощь?
Коммерческое сопровождение можно получить от Castle Stronghold.
Больше информации по этому вопросу можно получить на сайтww.castlestronghold.com/services/support.
370
Вопрос Ответ
Помимо коммерческого сопровождения, Castle Windsor остаетсрограммным обеспечением с открытым исходным кодоммеющим бурно развивающу юся экосистему, поэтому, скорее всего
(но не гарантированно), вы получите помощь на официальнооруме http://groups.google.com/gro up/castle-pro ject-users. Stack
Overflow (http://stackoverflow.com/) – еще одно место, где можнадать вопросы.
На какой версии
Castle Windsoснована данналава?
2.5.2
После окончания изучения данного раздела вы должны будете уже хорошо разбираться в
Castle Windsor, а также уметь использовать его в сценариях, в которых все компонентуководствуются соответствующими DI-паттернами, например, Constructor Injection. Мачнем с самого простого сценария и увидим, как можно разрешать объекты с помощьонтейнера Windsor.
Разрешение объектов
Основная цель каждого DI-контейнера – разрешать объекты посредством подключе ния им всех их зависимостей. Castle Windsor предоставляет простое API для разрешениервисов, но перед тем, как вы сможете разрешить сервис, его необходимарегистрировать с помощью контейнера. Ниже приведено самое простое возможнорименение Windsor:
var container = new WindsorContainer();
container.Register(Component.For<SauceBearnaise>());
SauceBearnaise sauce = container.Resolve<SauceBearnaise>();
Перед тем, как попросить WindsorContainer чт о-т о разрешить, вы должны явным образоарегистрировать соответствующие компоненты. В данном примере вы можете достичтого, регистрируя единственный конкретный тип. Тем не менее, как вы увидите далееаще всего вы будете регистрировать преобразования от абстракции к конкретному типу.
После соответствующей конфигурации контейнера можно разрешить тип SauceBearnaisля того, чтобы получить его экземпляр. Вам не придется выполнять проверку на null-
значение, поскольку WindsorContainer выдаст исключение, если не сможет выполнитвтоматическую интеграцию и вернуть экземпляр запрашиваемого типа.
Примечание
Для Windsor необходимо, чтобы все запрашиваемые компоненты были зарегистрированыаже если они являются конкретными типами. Это сделано намеренно, но данная схема нспользуется в других DI-контейнерах.
Этот первый пример функционально эквивалентен прямому созданию экземпляра класса
SauceBearnaise с помощью ключевого слова new: ничего нового еще не приобретено.
Вспомните, что механизм внедрения зависимостей – средство достижения результата, а
371
результатом является слабое связывание. Для того чтобы достичь слабого связывания, волжны преобразовать абстракции к конкретным типам.
Преобразование абстракций к конкретным типам
Несмотря на то, что иногда нужно регистрировать сам конкретный класс, гораздо болениверсальное требование – преобразовать абстракцию к конкретному классу. В концонцов, это и есть основная услуга, предлагаемая DI-контейнерами.
Ниже вы преобразуете интерфейс IIngredient к конкретному классу SauceBearnaiseоторый позволяет вам успешно разрешать IIngredient:
var container = new WindsorContainer();
container.Register(Component
.For<IIngredient>()
.ImplementedBy<SauceBearnaise>());
IIngredient ingredient = container.Resolve<IIngredient>();
Вместо регистрации конкретного типа вы преобразуете абстракцию к конкретному типу.
Когда вы позднее запросите экземпляр IIngredient, контейнер вернет экземпляр
SauceBearnaise.
Строго типизированное свободное API, доступное через класс Component
(Castle.MicroKernel.Registration.Component, а не
System.ComponentModel.Component), помогает предотвратить ошибки конфигурацииоскольку метод ImplementedBy имеет generic-ограничитель, который гарантирует, чтип, указанный в аргументе типа, реализует аргумент типа абстракция, заданный в методе
For. Т о есть, предыдущий код примера компилируется, потому что SauceBearnaisеализует IIngredient.
Во многих случаях строго типизированное API – это все, что вам нужно, и, поскольку онбеспечивает желаемую проверку во время компиляции, вы должны использовать его тамде это возможно. Кроме того, существуют ситуации, в которых вам необходим слабипизированный способ разрешения сервисов. Это также возможно.
Разрешение слабо типизированных сервисов
В некоторых случаях мы не можем писать generic-код для разрешения типа, так каожем даже не знать точный тип абстракции на этапе проектирования. Хороший примеакой ситуации – DefaultControllerFactory в ASP.NET MVC, который мы обсуждали азделе 7.2 "Построение ASP.NET MVC приложений". Соответствующая часть этогласса – виртуальный метод GetControllerInstance:
protected internal virtual IController GetControllerInstance(
RequestContext requestContext, Type controllerType);
В этом API нет строго типизированных generic-ов. Вместо них нам предоставляют Type росят вернуть экземпляр IController. Класс WindsorContainer также обладает слабипизированной версией метода Resolve. Вы можете использовать этот метод длеализации GetControllerInstance:
return (IController)this.container.Resolve(controllerType);
372
Обратите внимание на то, что в этом примере вы передаете аргумент controllerType етод Resolve. Поскольку слабо типизированная версия метода Resolve возвращаекземпляр System.Object, вы должны явным образом выполнить приведение к
IController перед тем, как вернуть результат.
Не важно, какую перегрузку метода Resolve вы используете, Windsor гарантирует, чтна вернет экземпляр требуемого типа или выдаст исключение, если существуюависимости, не удовлетворяющие данным условиям. После правильной регистрации всееобходимых зависимостей Windsor будет автоматически интегрировать необходимыип на основании его конфигурации.
В предыдущем примере this.container – это экземпляр IWindsorContainer. Для тогтобы иметь возможность разрешать требуемые типы, необходимо перед этиарегистрировать все типы и их зависимости. Существует множество способоонфигурации контейнера Windsor, и в следующем разделе рассматриваются наиболениверсальные из этих способов.
Конфигурирование контейнера
Как обсуждалось в разделе 3.2 "Конфигурирование DI-контейнеров", существуеесколько, концептуально разных способов конфигурирования DI-контейнера. На рисунке
10-3 представлен обзор возможных вариантов.
Рисунок 10-3: Концептуально разные варианты конфигурирования. Использование кода ачестве конфигурации подразумевает строгую типизированность и явное объявление.
XML, с другой стороны, – позднее связывание, но все равно явное объявление.
Автоматическая регистрация полагается на соглашения, которые могут быть строгипизированными и более слабо определенными.
373
Как и другие, имеющие длинную историю DI-контейнеры, Castle Windsor сначалспользовал XML в качестве главного источника конфигурации. Но многие командазработчиков вскоре поняли, что определение регистрации типов с помощью XML –
чрезвычайно хрупкий способ. На сегодняшний момент мы предпочитаем строгипизированную конфигурацию. Это можно сделать, используя код в качествонфигурации, но чаще всего более эффективно делать это при помощи автоматическоегистрации, которая в большей степени основывается на соглашениях.
Castle Windsor поддерживает все три подхода и даже позволяет нам сочетать их ределах одного и того же контейнера. В этом отношении, Castle Windsor дает нам всето мы только могли бы попросить. В данном разделе вы увидите, как можнспользовать каждый из этих трех типов источников конфигурации.
C ode as Configuration
В главе 3 вы видели примеры API Castle Windsor, использующего код в качествонфигурации. Каждая регистрация инициализиру ется с помощью метода Register бычно указывается при помощи Fluent API.
Мы конфигурируем WindsorContainer методом Register, который в качестве входныанных принимает массив IRegistration. На первый взгляд все это выглядит довольнбстрактным. Но вместо того, чтобы возлагать на нас обязанность определения тогоакую реализацию IRegistration использовать, Castle Windsor предоставляет Fluent
Registration API, которое позволяет создавать экземпляры IRegistration с болеонятным синтаксисом.
Для того чтобы применять Fluent Registration API, мы используем статический класс
Component в качестве точки входа.
Предупреждение
Не путайте Castle.MicroKernel.Registration.Component с
System.ComponentModel.Component из стандартной библиотеки классов.
Как вы уже видели ранее, самая простая возможная регистрация – регистрационкретного типа:
container.Register(Component.For<SauceBearnaise>());
Данный код регистрирует класс SauceBearnaise с помощью контейнера, но нбеспечивает никакого преобразования. Даже если SauceBearnaise будет реализовывать
IIngredient, контейнер выдаст исключение, если вы попросите его разрешить
IIngredient:
container.Resolve<IIngredient>()
Для возможности такого более релевантного сценария вы должны преобразоватонкретный тип в абстракцию:
container.Register(Component
.For<IIngredient>()
.ImplementedBy<SauceBearnaise>());
374
Обратите внимание на то, что теперь вместо класса SauceBearnaise вы регистрируетнтерфейс IIngredient. Это позволит вам разрешить IIngredient, но, что можеоказаться слегка удивительным, вы при этом потеряли способность разрешатонкретный класс SauceBearnaise. Изредка тот факт, что код слабо связан, становитсроблемой, но в исключительных ситуациях, когда вам нужно уметь разрешать оба типаы можете обеспечить это с помощью перегрузки метода For:
container.Register(Component
.For<SauceBearnaise, IIngredient>());
Данный код регистрирует компонент SauceBearnaise, в то же самое время перенаправляегистрацию к интерфейсу IIngredient. Это означает, что и SauceBearnaise, и
IIngredient регистрируются как разрешаемые типы. В обоих случаях реализацибеспечивается с помощью SauceBearnaise. Заметьте, что при использовании этоерегрузки вам не нужно неявно использовать метод ImplementedBy.
Очевидно, вы можете регистрировать составные типы при помощи последовательныызовов метода Register:
container.Register(Component
.For<IIngredient>()
.ImplementedBy<SauceBearnaise>());
container.Register(Component
.For<ICourse>()
.ImplementedBy<Course>());
Данный код регистрирует и интерфейс IIngredient, и интерфейс ICourse, а такжреобразует их к конкретным типам. Тем не менее, регистрация одной и той жбстракции несколько раз имеет приводит к некоторым интересным последовательнос тям:
container.Register(Component
.For<IIngredient>()
.ImplementedBy<Steak>());
container.Register(Component
.For<IIngredient>()
.ImplementedBy<SauceBearnaise>());
В этом примере вы регистрируете IIngredient дважды. Если вы разрешаете IIngredientо получаете экземпляр Steak. Выигрывает первая регистрация, но последующиегистрации не забыты. Castle Windsor имеет изощренную модель работы с составнымегистрациями. Мы вернемся к этому в разделе 10.3 "Работа с составнымомпонентами".
В Fluent Registration API доступны более продвинутые варианты, но данным способом можем сконфигурировать все приложение. Тем не менее, для того чтобы уберечь нас олишком явного сопровождения конфигурации контейнера, мы можем рассмотреть ольшей степени основанный на соглашениях подход, в котором используетсвтоматическая регистрация.
Автоматическая регистрация
Во многих случаях большинство регистраций похожи друг на друга. Такие регистрацирудно сопровождать, а явная регистрация каждого компонента часто сокращаероизводительно сть.
375
Давайте рассмотрим библиотеку, которая содержит множество реализаций IIngredient.
Вы можете регистрировать каждый класс индивидуально, но это приведет ногочисленным, схожим вызовам метода Register. Что еще хуже, каждый раз пробавлении новой реализации IIngredient вы должны также явно регистрировать этеализацию с помощью контейнера, если хотите, чтобы эта реализация была доступной.
Было бы более продуктивно установить, что все реализации IIngredient, обнаруженны данной сборке, должны быть зарегистрированы.
Сделать это можно путем применения статического класса AllTypes, который играеоль, аналогичную той роли, которую играет класс Component. Мы можем использоватдин из методов класса AllTypes для того, чтобы просмотреть сборку на факт наличиипов, удовлетворяющих определенному критерию. Приведенный ниже код регистрируесе реализации IIngredient за один шаг:
container.Register(AllTypes
.FromAssemblyContaining<Steak>()
.BasedOn<IIngredient>());
Класс AllTypes предоставляет множество методов, которые дают нам возможностбратиться к конкретной сборке, но я считаю generic-метод FromAssemblyContaininаиболее кратким: предоставь ему тип представителя в качестве параметра типа, и оудет использовать сборку, содержащую данный тип. Существуют также и другиетоды, предоставляющие возможность обеспечения Assembly с помощью другиредств.
В предыдущем примере вы, безусловно, регистрируете все реализации интерфейса
IIngredient, но можете задать другие критерии отбора, либо сузив отбор, либо выполнятбор не на основании интерфейсов и базовых классов, а на основании других критериев.
Ниже представлена основанная на соглашениях регистрация, при которой вы добавляетсе классы, имя которых начинается с Sauce, и регистрируете их относительно всентерфейсов, которые они реализуют:
container.Register(AllTypes
.FromAssemblyContaining<SauceBearnaise>()
.Where(t => t.Name.StartsWith("Sauce"))
.WithService.AllInterfaces());
Обратите внимание на то, что вы применяете предикат к методу Where, которыыполняет фильтрацию по типу имени. Любой тип, имя которого начинается с Sauceудет отобран из сборки, содержащей класс SauceBearnaise. Свойство WithServicозволяет задать правило регистрации типа. В данном примере вы регистрируете все типтносительно всех интерфейсов, которые они реализуют.
Благодаря регистрации на основании соглашений вы можете перейти от строгогонтроля типов к той области, где безопасность типов, кажется, исчезает. Примеродобный предыдущему, компилируется, но при этом не гарантируется, что будеегистрироваться вообще любой тип. Это зависит от того, существуют ли какие-либипы, удовлетворяющие критерию отбора. Вы можете переименовать все sauce-классы вто-то еще и останетесь без sauce.
В классе AllTypes существует даже метод, который принимает в качестве входногараметра имя сборки. Он будет использовать Fusion (средство загрузки сборки .NET
376
Framework) для обнаружения соответствующей сборки. Сочетая сборку с позднивязыванием и нетипизированный предикат, можно продвинуться вглубь территориозднего связывания. Такая возможность могла бы стать полезным приемом реализациополнений, поскольку Castle Windsor также может просматривать все сборки иректории.
Еще один способ регистрации дополнений и других сервисов с поздним связыванием –
применение возможности XML конфигурации Castle Windsor.
XML конфигурация
Когда вам нужно уметь изменять конфигурацию без повторной компиляции приложения,
XML конфигурация – наилучший вариант.
Подсказка
Используйте XML конфигурацию только для тех типов, которые вам нужно изменить беовторной компиляции приложения. Для остальных случаев используйте автоматическуегистрацию или технологию использования кода в качестве конфигурации.
Мы можем вставить XML конфигурацию в обычные файлы .NET конфигурации илмпортировать XML из специализированных файлов. В Castle Windsor ничего нроисходит, пока мы об этом явно не попросим, поэтому мы должны также указать, хотии загрузить конфигурацию из XML.
Сделать это можно несколькими способами, но рекомендуемый способ – использоватетод Install (подробнее об Installer'ах мы поговорим в разделе 10.1.3 "Пакетированионфигурации"):
container.Install(Configuration.FromAppConfig());
Метод FromAppConfig возвращает экземпляр ConfigurationInstaller, который читает
XML конфигурацию Castle Windsor из конфигурационного файла приложения реобразует ее в объекты, понятные контейнеру.
Для того чтобы разрешить размещать конфигурацию Castle Windsor в конфигурационноайле, вы должны сначала добавить секцию конфигурации:
<configSections>
<section name="castle"
type="Castle.Windsor.Configuration.AppDomain
?.CastleSectionHandler, Castle.Windsor" />
</configSections>
Данный код позволяет вам добавить секцию конфигурации castle в конфигурационныайл. Ниже приведен простой пример, который преобразует интерфейс IIngredient ласс Steak:
<castle>
<components>
<component id="ingredient.sauceBearnaise"
service="IIngredient"
type="Steak"/>
</components>
</castle>
377
Обратите внимание на то, что вам не приходится применять квалифицированное имя типборки для сервиса или для класса. Пока имена в рамках всех загруженных сборок будуникальными, они будут корректно разрешаться – но если бы вам захотелось получитонфликт имен, вы могли бы все равно использовать квалифицированные имена типов.
Очевидно, вы можете добавить столько компонентов, сколько вам потребуется.
ConfigurationInstaller преобразует эту XML конфигурацию в объекты регистрацииоторые конфигурируют контейнер, и вы можете последовательно разрешатконфигурированные типы.
XML конфигурация – это хороший вариант в тех ситуациях, когда вам нужно изменитонфигурацию одного или более одного компонента без повторной компиляцириложения. Тем не менее, поскольку это может быть довольно хрупким вариантом, тля таких случаев вам следует сделать резервную копию и использовать либвтоматическую регистрацию, либо использовать код в качестве конфигурации длсновной части конфигурации контейнера.
Подсказка
Помните, каким образом выигрывает первая конфигурация? Вы можете использовать этоведение для того, чтобы перезаписать жестко-закодиро ванную конфигурацию XML
конфигурацией. Для этого вы должны не забыть установить ConfigurationInstaller дого, как установите любые другие компоненты.
В данном разделе мы, главным образом, рассматривали различные API конфигурации
Castle Windsor. Несмотря на то, что наверняка можно написать один большой блоеструктурированного кода конфигурации, лучше всего разделить конфигурацию нодули. Для этих целей у нас есть Windsor Installer'ы.
Пакетирование конфигурации
Иногда хочется упаковать логику конфигурации в повторно используемые группы, и дажогда повторное использование само по себе не является для нас самым приоритетнымы можем пожелать обеспечить некоторого рода структуру в случае, если нам нужнконфигурировать большое и сложное приложение.
Благодаря Castle Windsor мы можем упаковать конфигурацию в Installer'ы. Installer –
это класс, который реализует интерфейс IWindsorInstaller:
public interface IWindsorInstaller
{
void Install(IWindsorContainer container, IConfigurationStore store);
}
Все, что вы делали до настоящего момента, вы также можете сделать и внутри Installer.
Следующий листинг демонстрирует Installer, который регистрирует все реализации
IIngredient.
378
Листинг 10-1: Реализация Windsor Installeublic class IngredientInstaller : IWindsorInstaller
{
public void Install(IWindsorContainer container,
IConfigurationStore store)
{
container.Register(AllTypes
.FromAssemblyContaining<Steak>()
.BasedOn<IIngredient>());
}
}
IngredientInstaller реализует интерфейс IWindsorInstaller посредствоспользования точно такого же API, которое вы видели ранее, для регистрации всееализаций IIngredient.
Для того чтобы зарегистрировать Installer, вызовите метод Install:
container.Install(new IngredientInstaller());
Несмотря на то, что метод Install можно вызывать бессчисленное множество раз, окументации к Castle Windsor рекомендуется выполнять всю конфигурацию динственном вызове метода Install. Метод Install принимает в качестве параметрассив экземпляров IW indsorInstaller:
public IWindsorContainer Install(params IWindsorInstaller[] installers);
Подсказка
Windsor Installer'ы позволяют вам упаковывать и структурировать код конфигурациашего контейнера. Используйте их вместо встроенной конфигурации: это сделает вашу
Composition Root более читабельной.
Подсказка
Кроме преимуществ, которые Installer'ы предлагают для вашего собственного кода,
Castle Windsor также движется по направлению оптимизации большинства своих API
вокруг Installer'ов. Это своеобразный и рекомендуемый способ конфигурирования ольшей степени Castle Windsor, нежели других контейнеров.
Кроме того, вы можете задать один или более одного Installer'а в XML, и загрузитонфигурационный файл, как это было описано ранее:
<installers>
<install type="IngredientInstaller" />
</installers>
Используя, Installer'ы вы можете конфигурировать WindsorContainer таким способомаким вам только захочется – используя код в качестве конфигурации, автоматическуегистрацию или XML – или же вы можете сочетать все три подхода. После того, каонтейнер сконфигурирован, вы можете попросить его разрешить сервисы.
Данный раздел познакомил вас с DI-контейнером Castle Windsor и продемонстрировасновные принципы: как сконфигурировать контейнер и впоследствии использовать его
379
для того, чтобы разрешать сервисы. Выполнять разрешение сервисов легко с помощьдиничного вызова метода Resolve, поэтому вся сложность заключается онфигурировании контейнера. Это можно сделать несколькими различными способамиключая императивный код и XML. До настоящего момента мы рассматривали толькамое основное API. Есть и более перспективные области, которые нам необходимассмотреть. Одна из наиболее важных тем – как управлять жизненным циклоомпонентов.
380
10.2. Управление жизненным циклом
В главе 8 мы обсуждали механизм управления жизненным циклом, в том числе самыниверсальные, принципиальные стили существования, например, Singleton и Transient.
Castle Windsor поддерживает множество различных стилей существования и позволяеам сконфигурировать жизненный цикл всех сервисов. Стили существованияродемонстрированные в таблице 10-2, доступны в виде составляющей API Castle
Windsor.
Таблица 10-2: Стили существования Castle Windsor
Название Комментарии
Singleton Этот стиль существования используется в Castle Windsor по умолчанию.
Transient Каждый раз создается новый экземпляр, но экземпляр все равнтслеживается контейнером.
PerThread На один поток создается один экземпляр.
PerWebRequest Необходима регистрация в web.config (см. раздел 10.2.2 "Использованиродвинутых стилей существования").
Pooled Чаще всего будет уместно конфигурировать размер пула (см. раздел
10.2.2).
Custom Создайте свой собственный пользовательский стиль существования (см.
раздел 10.2.3 "Разработка пользовательского стиля существования").
Некоторые из встроенных стилей существования полностью эквивалентны основныаттернам стилей существования, описанным в главе 8. Это, в частности, справедливо ля стилей существования Singleton и Transient, поэтому в этой главе я не буду выделятля их описания какое-то специальное пространство.
Примечание
Стиль существования, используемый в Castle Windsor по умолчанию, – это Singleton. Эттличает его от многих других контейнеров. Как мы уже обсуждали в главе 8, Singleton –
самый эффективный, но, тем не менее, не всегда самый безопасный из всех стилеуществования. В Castle Windsor по умолчанию эффективность имеет приоритет наезопасностью.
В этом разделе вы увидите, как можно конфигурировать стили существования дломпонентов и как использовать некоторые более специфичные стили существованияапример, PerWebRequest и Pooled. Мы также рассмотрим реализацию пользовательскогтиля существования для того, чтобы продемонстрировать, что мы не ограниченспользованием только встроенных стилей существования. После прочтения данногаздела вы должны будете уметь использовать стили существования Castle Windsor воем собственном приложении.
Давайте начнем с обзора того, как конфигурировать стили существования дломпонентов.
381
Конфигурирование стиля существования
В данном разделе мы разберем то, как управлять стилями существования компонентов омощью Castle Windsor. Стиль существования конфигурируется в виде составляющеасти регистрации компонента, поэтому нам доступны те же самые возможности, что ри выполнении конфигурации в целом: код или XML. Мы будем рассматривать каждуз этих возможностей поочереди.
Конфигурирова ние стиля существования с помощью кода
Стиль существования конфигурируется с помощью Fluent Registration API, которое мспользуем для регистрации компонентов. Это настолько просто, как и представленныиже код:
container.Register(Component
.For<SauceBearnaise>()
.LifeStyle.Transient);
Обратите внимание на то, что вы определяете стиль существования при помощи свойства
Lifestyle. В данном примере вы устанавливаете в качестве стиля существования стиль
Transient. Таким образом, каждый раз, когда разрешается SauceBearnaise, возвращаетсовый экземпляр.
Вы все равно можете явным образом определить стиль существования Singleton, дажсли он и является используемым по умолчанию. Два примера, приведенные нижевляются эквивалентными:
container.Register(Component
.For<SauceBearnaise>()
.LifeStyle.Singleton);
ontainer.Register(Component
.For<SauceBearnaise>());
Поскольку Singleton является используемым по умолчанию стилем существования, вам нужно явно определять его, но вы можете это сделать, если пожелаете.
Точно так же, как мы можем конфигурировать компоненты в коде и XML, мы можеонфигурировать стили существования и в коде, и в XML.
Конфигурирова ние стиля существования с помощью XML
В разделе 10.1.2 "Конфигурирование контейнера" вы видели, как конфигурироватомпоненты с помощью XML, но не применяли никакого стиля существования. Как и лучае с конфигурированием компонента при помощи Fluent Registration API, Singletoвляется используемым по умолчанию стилем существования, но при необходимости вожете явно определить другой стиль существования:
<component id="ingredient.sauceBearnaise"
service="IIngredient"
type="Steak"
lifestyle="transient" />
382
Единственное отличие от примера из раздела 10.1.2 "Конфигурирование контейнера"
заключается в добавленном атрибуте lifestyle. Как вы видите, определение стилуществования легко выполняется и с помощью кода, и при помощи XML.
Высвобождение компонентов
Как мы уже обсуждали в разделе 8.2.2 "Управление устраняемыми зависимостями", важнысвободить объекты после того, как мы завершили работу с ними. Это также просто, ка вызов метода Release:
container.Release(ingredient);
Данный код будет высвобождать экземпляр, предоставленный в метод Release
(переменная ingredient из предыдущего примера), а также все те зависимосткземпляра, жизненный цикл которых завершился. То есть, если экземпляр обладает
Transient зависимостью, то эта зависимость будет высвобождена (и возможнничтожена), тогда как Singleton зависимость останется в контейнере.
Подсказка
Castle Windsor отслеживает все, даже Transient компоненты, поэтому важно, не забыватысвобождать все разрешенные экземпляры для того, чтобы избежать утечек памяти.
Подсказка
Высвобождайте явно то, что вы явно разрешаете.
Подсказка
Не забывайте уничтожать сам контейнер при закрытии приложения. Такое поведенириведет к уничтожению Singleton компонентов и даст гарантию того, что приложениравильно очищается.
Теперь давайте обратим наше внимание на некоторые из тех стилей существования, длоторых нужно немного больше конфигурации, нежели простой оператор.
Использование продвинутых стилей существования
В данном разделе мы рассмотрим два стиля существования Castle Windsor, для которыеобходимо больше конфигурации, нежели простое объявление: Pooled и PerW ebRequest.
Использование стиля существования Pooled
В разделе 8.3.5 "Pooled" мы рассматривали общую концепцию стиля существования
Pooled. В данном разделе мы увидим, как использовать реализацию Windsor. Стилуществования Pooled в Castle Windsor уже идет с заданным по умолчанию размероула, но, поскольку оптимальный размер пула всецело зависит от обстоятельств, валедует явно сконфигурировать размер пула. Вы можете определить стиль существования
Pooled с заданными по умолчанию размерами таким же способом, как вы конфигурируетюбой другой стиль существования:
383
container.Register(Component
.For<IIngredient>()
.ImplementedBy<SauceBearnaise>()
.LifeStyle.Pooled);
Тем не менее, данный код не передает размер пула. Несмотря на то, что я не смог найтакую-либо документ ацию, в которой указано, каковы значения пула по умолчаниюсходный код Castle Windsor 2.1.1 показывает, что по умолчанию первоначальный размеула равен 5, а максимальный размер – 15. Для меня эти значения кажутся довольнроизвольными, что является еще одной причиной определения размера явным образом.
Для того чтобы явным образом сконфигурировать размеры пула, вы можете использоватетод PooledWithSize:
container.Register(Component
.For<IIngredient>()
.ImplementedBy<SauceBearnaise>()
.LifeStyle.PooledWithSize(10, 50));
Данный пример устанавливает первоначальный размер – 10, а максимальный размер – 50.
Пулы Castle Windsor имеют два конфигурационных значения: первоначальный размер аксимальный размер. Первоначальный размер, очевидно, регулирует первоначальныазмер пула, а максимальный размер – максимальный размер пула, но в крайних случаяоведение может быть неожиданным. Рисунок 10-4 демонстрирует, как эволюционируеазмер пула в течение жизненного цикла контейнера.
Рисунок 10-4: Прогрессия размера пула с первоначальным размером, равным 3, аксимальным размером, равным 5. Даже если первоначальный размер равен 3, пустается пустым до тех пор, пока не разрешается первый экземпляр. На данном этапозданы все три экземпляра для первоначального размера, и один из них непосредственнспользуется. Когда экземпляр высвобождается, он возвращается в пул. Пувеличивается в размере, если необходимо больше экземпляро в, чем для первоначальногазмера. Обратите внимание на то, что можно превысить максимальный размер, но чтзлишние экземпляр ы не используются повторно при высвобождении.
Когда экземпляр разрешается из пула, он помечается как используемый. Поскольку остается в этом состоянии до тех пор, пока не будет явным образом высвобожден ионтейнера, важно, не забывать высвобождать экземпляры после завершения работы ими. Это позволяет контейнеру повторно использовать экземпляры:
container.Release(ingredient);
384
Примечание
То, что происходит, когда пул полностью утилизируется, довольно неожиданно. Вместого чтобы выдавать исключение или блокировать вызов, создаются избыточныкземпляры. После использования они отбрасываются вместо того, чтобы повторнспользоваться.
Несмотря на то, что стиль существования Pooled более продвинут, чем Singleton или
Transient, его все равно легко использовать. Единственное дополнительное усилиеоторое вам необходимо сделать – передать два дополнительных числа для того, чтобконфигурировать размеры пула. Стиль существования PerWebRequest не сильнтличается от Pooled, но его несколько сложнее конфигурировать.
Использование стиля существования PerWebRequest
Как и подразумевает его имя, работа стиля существования PerWebRequest заключается оздании экземпляра для веб-запроса. Объявление этого стиля столь же просто, как бъявление стиля существования Transient:
container.Register(Component
.For<IIngredient>()
.ImplementedBy<SauceBearnaise>()
.LifeStyle.PerWebRequest);
Тем не менее, если мы попытаемся использовать его без дальнейшей конфигурации, толучим исключение:
Looks like you forgot to register the HTTP module Castle.MicroKernel.Lifestyle.PerWeb-
RequestLifestyleModule
Add ‘<add name="PerRequestLifestyle" type="Castle.MicroKernel.Lifestyle.PerWebRequest-
LifestyleModule, Castle.Wind so r" />’ to the <httpModules> section on your web.config. Iou’re running IIS7 in Integrated Mode you will need to add it to <m odules> section under
<system.webServer>
(Похоже, вы забыли зарегист рировать HTTP-модуль
Castle.MicroKernel.Lifestyle.PerWebRequestLifestyleModule
Добавьт е ‘<add name="PerRequestLifestyle"
type="Castle.MicroKernel.Lifestyle.PerWebRequestLifestyleModule, Castle.Wind so r" />’ аздел <httpModules> ваш его файла web.config. Если IIS7 запущен в инт егрированноежиме, вам нужно будет добавить эт от код в раздел <modules> после
<system.webServer>)
Поскольку выдаются сообщения об ошибках, приведенное выше исключение являетсоказательным. Оно точно указывает, что вам необходимо сделать.
В любом случае, важно отметить, что стиль существования PerWebRequest использует
HTTP-модуль для того, чтобы указать, какой веб-запрос на данный момент выполняется.
Одно из последствий этого – нам необходимо зарегистрировать HTTP-модуль так, как то описывал выше, другое – данный конкретный стиль существования работает т олько в
385
рамках веб-запросов. Если мы попытаемся использовать его в других типах приложенийы получим то же самое исключение, что и в предыдущем примере.
Как и стиль существования Pooled, так и стиль существования PerWebRequest, требуюспользования немного большего разнообразия задач, нежели простое объявление, но пртом их все равно легко конфигурировать и использовать. Встроенные стилуществования Castle Windsor предоставляют обширный и полезный набор стилеуществования, который удовлетворяет большинству сценариев. Однако если ни один итих стилей существования не удовлетворяет специализированным нуждам, мы можеоздать пользовательский стиль существования.
Разработка пользовательского стиля существования
В большинстве случаев для наших нужд должны подходить встроенные стилуществования Castle Windsor, но если нам нужно что-то особенное, мы можем создатользовательский стиль существования.
В данном разделе вы увидите, как это сделать. Для начала мы вкратце рассмотриоответствующий шов, который делает возможным создание пользовательского стилуществования, но быстро перейдем к рассмотрению примера.
Понимание API стиля существования
Вы можете создать пользовательский стиль существования путем реализации интерфейса
ILifestyleManager:
public interface ILifestyleManager : IDisposable
{
void Init(IComponentActivator componentActivator,
IKernel kernel, ComponentModel model);
bool Release(object instance);
object Resolve(CreationContext context);
}
Одним из немного странных условий реализации ILifestyleManager является тот фактто он должен иметь конструктор по умолчанию. То есть использовать Constructor
Injection при реализации ILifestyleManager запрещено. Вместо этого наредоставляется одна из относительно редких возможностей использовать Method
Injection. Будет вызван метод Init, предоставляя среди прочих параметров экземпляр
IKernel, который можно использовать в качестве Service Locator. Это мне совершенно нодходит, и когда мы будем рассматривать некоторые примеры кода, вы увидите, чтакой подход в большей степени усложняет реализацию, чем, если бы было возможныспользование Constructor Injection.
Другие методы интерфейса ILifestyleManager – Resolve и Release, но нам следуеспользовать их в качестве перехватчиков, а не предоставлять свои собственныеализации Resolve и Release – за это отвечает IComponentActivator, переданный нам етоде Init. Рисунок 10-5 демонстрирует, что для обеспечения возможности управлениизненным циклом каждого компонента мы должны использовать эти методы только длерехвата вызовов Resolve и Release.
386
Рисунок 10-5: ILifestyleManager выступает в роли некоторого рода перехватчикаоторый вызывается вместо упомянутого выше IComponentActivator. Предполагаетсято реализация ILifestyleManager использует предоставленный IComponentActivatoля создания экземпляро в объектов. Поскольку ILifestyleManager располагаетсосередине, он получает возможность перехватывать каждый вызов и исполнять свообственную логику стиля существования. Можно повторно использовать экземплярместо того, чтобы каждый раз вызывать IComponentActivator.
Castle Windsor обеспечивает реализацию по умолчанию ILifestyleManager в виде класса
AbstractLifestyleManager. Он реализует интерфейс и предоставляет обоснованнуеализацию по умолчанию для большинства методов. Именно этот класс вы будетспользовать для реализации шаблонного стиля существования.
Разработка стиля существования Caching
Поскольку Castle Windsor предлагает исчерпывающий набор стандартных стилеуществования, трудно придумать хороший пример. Тем не менее, представьте себе, чтам захотелось разработать стиль существования Caching, который держит экземпляр поукой в течение определенного времени, а затем высвобождает его. Это хороший примероскольку он достаточно сложен для демонстрации различных аспектов реализациользовательского стиля существования, но не так сложен, чтобы на его рассмотрениыделять несколько страниц.
Примечание
Стиль существования Caching – выдуманный пример. Существуют лучшие способеализации функциональности кэширования, поскольку обычно вы хотите кэшировать нервисы, а данные, которыми управляют эти сервисы.
Предупреждение
Продемонстрированный в данном разделе шаблонный код не принимает во вниманиотоко-безопасность, но реальная реализация ILifestyleManager должна быть потоко-
безопасной.
Самый легкий способ реализации пользовательского стиля существования – наследованит AbstractLifestyleManager, что продемонстрировано в следующем листинге.
387
Листинг 10-2: Определение пользовательского стиля существования
1. public partial class CacheLifestyleManager :
2. AbstractLifestyleManager
3. {
4. private ILease lease;
5. public ILease Lease
6. {
7. get
8. {
9. if (this.lease == null)
10. {
11. this.lease = this.ResolveLease();
12. }
13. return this.lease;
14. }
15. }
16. private ILease ResolveLease()
17. {
18. var defaultLease = new SlidingLease(TimeSpan.FromMinutes(1));
19. if (this.Kernel == null)
20. {
21. return defaultLease;
22. }
23. if (this.Kernel.HasComponent(typeof(ILease)))
24. {
25. return this.Kernel.Resolve<ILease>();
26. }
27. return defaultLease;
28. }
29. }
Строка 2: Наследование от AbstractLifestyleManager
Строка 9-13: "Ленивая" загрузка
Строка 23-26: Пытается определить местоположение ILease
Одна из тех вещей, которые вы получаете благодаря наследованию от
AbstractLifestyleManager, – реализация метода Init. Вы можете переопределить его, н данном случае это не нужно. Все, что он делает, – сохраняет внедренные сервисы такибразом, чтобы вы могли в дальнейшем получить доступ к ним посредством защищеннывойств.
Для того чтобы реализовать функционально сть, которая решает, когда заканчиваетсремя кэшированного объекта, вам нужен экземпляр ILease. Если бы вы моглспользовать Constructor Injection, то вы бы запросили ILease с помощью конструктораостоящего из трех строк кода (включая граничный оператор). На данный момент ваеобходимо 12 строк кода, поскольку вам приходится иметь дело со множествоотенциальных состояний CacheLifestyleManager: вызывался ли уже метод Init?
Обладает ли Kernel экземпляром ILease?
Вы справляетесь с этим при помощи свойства Lease, имеющего отложенную загрузку
(lazy-loaded property). При первом его прочтении он вызывает метод ResolveLeaseоторый выясняет, каким должен быть срок аренды. Он использует срок арендыаданный по умолчанию, но пытается искать альтернативный срок посредством Kernel –
если Kernel вообще существует. Я думаю, что это довольно хорошая иллюстрация
388
недостатков Method Injection. Обратите внимание на то, что, если кто-либо прочитаевойство Lease до вызова метода Init, то будет использоваться срок аренды пмолчанию даже в случае, если Kernel содержит компонент ILease. Тем не менееоскольку Castle Windsor ничего не знает о свойстве Lease, при обычном его примененитого не происходит.
Примечание
Интерфейс ILease, используемый в данном примере, является пользовательскинтерфейсом, определенным для конкретной цели. Это не
System.Runtime.Remoting.Lifetime.ILease, который имеет аналогичное, но не намноголее сложное API.
По сравнению со всеми трудностями, которые вам приходится преодолеть для того, чтобнедрить зависимость в ваш пользовательский стиль существования, реализация метода
Resolve намного проще. Увидеть это вы можете из приведенного ниже листинга.
Листинг 10-3: Реализация метода Resolve
1. private object obj;
2. public override object Resolve(CreationContext context)
3. {
4. if (this.Lease.IsExpired)
5. {
6. base.Release(this.obj);
7. this.obj = null;
8. }
9. if (this.obj == null)
10. {
11. this.Lease.Renew();
12. this.obj = base.Resolve(context);
13. }
14. return this.obj;
15. }
Строка 4-8: Выносит объект на просрочку
Строка 11: Продляет срок аренды
Каждый раз, когда CacheLifestyleManager просят разрешить компонент, он начинает роверки того, просрочен ли текущий срок аренды. Если срок аренды просрочен,
CacheLifestyleManager высвобождает текущий кэшированный экземпляр и обнуляет его.
Метод Release явным образом вызывается для базового класса и через него – для
IComponentActivator, что продемонстрировано на рисунке 10-5. Это важно выполнитьотому что это дает вышеупомянуто й реализации возможность уничтожить экземплярсли он реализует IDisposable.
Следующее, что необходимо сделать, – проверить, имеет ли кэшированный экземпляначение null. Он может иметь null, если он был высвобожден перед этим, но такжожет иметь null при первом вызове метода Resolve. В обоих случаях вы продлите сроренды и просите базовую реализацию разрешить компонент для вас. Именно здесазовый класс вызывает соответствующий метод для IComponentActivator.
В данном пользовательском стиле существования вы переопределяете метод Release тактобы он ничего не делал:
389
public override bool Release(object instance)
{
return false;
}
Это может показаться странным, но является вполне нормальным. Вы должны принять внимание тот факт, что метод Release – это Hook-метод, который является частью Seaтиля существования Castle Windsor. Вы проинформированы о том, что компонент можеыть высвобожден, но это не означает, что вам придется это делать. Для примера стилуществования Singleton по определению никогда не высвобождает свой экземпляроэтому он имеет такую же реализацию метода Release, как и продемонстрированнаанее.
В случае с CacheLifestyleManager вы время от времени высвобождаете кэшированныкземпляр, но, как показано в листинге 10-3, вы делаете это в рамках метода Resolve пеобходимости.
CacheLifestyleManager кэширует разрешенный экземпляр до тех пор, пока не истечерок аренды, а затем разрешает новый экземпляр и продлевает срок аренды. Существуеесколько способов реализации логики аренды, но мы рассмотрим только один из них.
Реализация Lease
Вам нужна, по крайней мере, одна реализация ILease для CacheLifestyleManager. Сроласса SlidingLease истекает по окончании фиксированного промежутка времени, но вогли бы создать другие реализации, срок которых истекает фиксированное количестваз в день, или после того, как они разрешили компонент заданное количество раз.
Примечание
Интерфейс ILease и класс SlidingLease, продемонстрированные в данном разделеичего не делают в рамках Castle Windsor, но я хотел продемонстрировать их радолноты знаний. Вы можете пропустить этот раздел и приступить к чтению информации ом, как зарегистрировать пользовательский жизненный цикл, если вас не интересует
SlidingLease.
Следующий листинг демонстрирует реализацию SlidingLease.
Листинг 10-4: Реализация SlidingLease
1. public class SlidingLease : ILease
2. {
3. private readonly TimeSpan timeout;
4. private DateTime renewed;
5. public SlidingLease(TimeSpan timeout)
6. {
7. this.timeout = timeout;
8. this.renewed = DateTime.Now;
9. }
10. public TimeSpan Timeout
11. {
12. get { return this.timeout; }
13. }
14. public bool IsExpired
15. {
16. get
390
17. {
18. return DateTime.Now >
19. this.renewed + this.timeout;
20. }
21. }
22. public void Renew()
23. {
24. this.renewed = DateTime.Now;
25. }
26. }
27.
Строка 16-17: Выносит на просрочку в случае истечения времени ожидания
Строка 22: Продление срока
Класс SlidingLease реализует ILease путем отслеживания того, когда был продлен сроренды. Всякий раз, когда вы запрашиваете у SlidingLease информацию о том, был лросрочен срок аренды, он сравнивает текущее время со временем продления и ожидания.
При продлении срока аренды SlidingLease устанавливает текущее время в качествремени продления. Я мог бы использовать TimeProvider Ambient Context из раздела 4.4.4
вместо DateTime.Now, но решил упростить все, насколько это возможно.
Теперь, когда вы знаете, как реализовать пользовательский стиль существования и любыользовательские зависимости, которые он может иметь, вам осталось узнать только тоак их использовать.
Конфигурирова ние компонентов с помощью пользовательского стилуществования
Применять CacheLifestyleManager к компоненту легко, и выполняется это таким жбразом, как и определение любого другого стиля существования:
container.Register(Component
.For<IIngredient>()
.ImplementedBy<SauceBearnaise>()
.LifeStyle.Custom<CacheLifestyleManager>());
Вы применяете generic-перегрузку метода Custom для того, чтобы определить, какой тип
ILifestyleManager использовать. Но существует также перегрузка, которая принимаекземпляр Type в качестве входного параметра.
До тех пор, пока вы не будете забывать регистрировать также и ILease,
CacheLifestyleManager будет использовать заданный по умолчанию срок аренды
SlidingLease с одноминутным таймаутом. Ниже приведен способ регистрациользовательского ILease:
container.Register(Component
.For<ILease>()
.Instance(new SlidingLease(TimeSpan.FromHours(1))));
При помощи данного кода выполняется регистрация экземпляра SlidingLease ременным интервалом в один час. Вы должны не забывать регистрировать ILease переспользованием пользовательского стиля существования, поскольку иначе будеспользоваться срок аренды по умолчанию.
391
Разработка пользовательского стиля существования для Castle Windsor не особеннложна. В большинстве случаев класс AbstractLifestyleManager предоставляеорошую стартовую точку, и нам нужно только переопределить методы, которые насобенно важны. Чаще всего это будет метод Resolve, хотя для некоторых другиетодов мы можем оставить их реализации по умолчанию. Только в редких случаях наужно будет создавать пользовательский стиль существования, поскольку стандартныабор стилей существования Castle Windsor довольно исчерпывающий.
На этом мы заканчиваем свое путешествие по управлению жизненным циклом с помощью
Castle Windsor. Компоненты можно конфигурировать при помощи сочетания стилеуществования, и это справедливо даже в тех случаях, когда мы регистрируем составныеализации одной и той же абстракции. Нам еще придется рассмотреть то, как работать оставными компонентами, поэтому давайте сейчас перенаправим наше внимание в этаправление.
392
10.3. Работа с составными компонентами
DI-контейнеры процветают благодаря их индивидуа льности, но их неопределенносторождает ряд трудностей. При использовании Constructor Injection единичныонструктор предпочтительнее перегружаемых конструкторов, поскольку в этом случасно, какой конструктор использовать в ситуации, когда у вас нет выбора. То же самоасается и преобразования абстракций к конкретным типам. Если мы пытаемсреобразовать конкретные составные типы к одной и той же абстракции, это приводит еопределенности.
Несмотря на столь нежелательну ю особенность как неопределенность, нам частриходится работать с составными реализациями единичного интерфейса. Это можероисходить в следующих ситуациях:
? Для разных потребителей должны использоваться разные специфичные типы
? Зависимости являются последовательнос тями
? Используются Decorator'ы
В данном разделе мы рассмотрим каждую из этих ситуаций и увидим, как Castle Windsoоочереди справляется с каждой из них. После прочтения раздела вы должны будетметь регистрировать и разрешать компоненты даже тогда, когда в дело вступаюоставные реализации одной и той же абстракции.
Давайте сначала рассмотрим то, как можно обеспечить более разветвленное управлениеежели то, которое предоставляет автомат ическая интеграция (Auto-Wiring).
Выбор из составных кандидатов
Автоматическая интеграция – удобный и мощный инструмент, но предоставляет наеньшие возможности контроля. Пока все абстракции преобразуются в конкретные типтдельно друг от друга, никаких трудностей не возникает, но как только мы вводиольше реализаций для одного и того же интерфейса, возникает неопределенно сть.
Давайте для начала повторим, как Castle Windsor работает с составными регистрациямдной и той же абстракции.
Регистрация составных реализаций одного и того же сервиса
Как вы видели в разделе 10.1.2 "Конфигурирование контейнера", вы можетегистрировать составные компоненты одного и того же сервиса:
container.Register(Component
.For<IIngredient>()
.ImplementedBy<Steak>());
container.Register(Component
.For<IIngredient>()
.ImplementedBy<SauceBearnaise>());
Данный пример регистрирует как класс Steak, так и класс SauceBearnaise для сервиса
IIngredient. Выигрывает первая регистрация, поэтому, если вы будете разрешать
IIngredient при помощи container.Resolve<IIngredient>(), вы получите экземпляр
Steak. Т ем не менее, в результате вызова container.ResolveAll<IIngredient>()
393
возвращается массив IIngredient, содержащий как Steak, так и SauceBearnaise. То естьоследующие регистрации не позабыты, но их трудно получить.
Подсказка
Побеждает первая регистрация данного типа. Она определяет регистрацию, используемуля него по умолчанию.
Предупреждение
Если существуют регистрации данного типа, которые не могут быть разрешены в связи тсутствием зависимостей, ResolveAll молча игнорирует их и возвращает только теоторые может разрешить. Поскольку не выдается никаких исключений, все это иногдожет приводить к некоторым труднопонимаемым багам.
Следующий листинг демонстрирует способ, благодаря которому вы можете предоставлятодсказки, которые могут впоследствии использоваться для осуществления выбора иоставных кандидатов.
Листинг 10-5: Присваивание имен компонентаontainer.Register(Component
.For<IIngredient>()
.ImplementedBy<Steak>()
.Named("meat"));
container.Register(Component
.For<IIngredient>()
.ImplementedBy<SauceBearnaise>()
.Named("sauce"));
Каждой регистрации вы можете присвоить уникальное имя, которое позднее можеспользоваться для того, чтобы отличить этот компонент от других компонентов.
Имея представленные в листинге 10-5 именованные компоненты, вы можете разрешить и
Steak, и SauceBearnaise следующим образом:
var meat = container.Resolve<IIngredient>("meat");
var sauce = container.Resolve<IIngredient>("sauce");
Заметьте, что вы применяете тот же самый идентификатор, который использовали длрисваивания имени компоненту во время регистрации.
Если вы примете как должное то, что вам следует всегда разрешать сервисы динственном Composition Root, вы уже не будете сталкиваться с такоеопределенностью на данном уровне.
Подсказка
Если вы обнаружили, что вызываете метод Resolve со специальным идентификаторомодумайте, можете ли вы сделать свою технологию менее неопределенно й.
Тем не менее, вы можете использовать именованные компоненты для того, чтобы выбратежду составными альтернативами при конфигурировании зависимостей данногервиса.
394
Регистрация именованных зависимостей
Насколько бы полезной ни была автоматическая интеграция, иногда вам необходимереопределять обычное поведение таким образом, чтобы обеспечить болеазветвленное управление зависимостями. Но может случиться и то, что вам нужно будебратиться к неопределенному API. В качестве примера рассмотрите приведенный нижонструктор:
public ThreeCourseMeal(ICourse entree,
ICourse mainCourse, ICourse dessert)
В данном примере у вас имеется три одинаково типизированных зависимости, каждая иоторых представляет отличную от других сущность. В большинстве случаев вы хотитреобразовать каждую зависимость к отдельному типу. Следующий листинемонстрирует, каким образом вы могли бы зарегистрировать преобразования ICourse.
Листинг 10-6: Регистрация именованных course'оontainer.Register(Component
.For<ICourse>()
.ImplementedBy<Rillettes>()
.Named("entree"));
container.Register(Component
.For<ICourse>()
.ImplementedBy<CordonBleu>()
.Named("mainCourse"));
container.Register(Component
.For<ICourse>()
.ImplementedBy<MousseAuChocolat>()
.Named("dessert"));
Согласно листингу 10-6 вы регистрируете три именованных компонента, преобразуя
Rilettes в регистрацию с именем "entree" (напоминаю американским читателям, что это же самое, что и starter или appetizer – то, что возбуждает аппетит, придает вкус),
CordonBleu – в регистрацию с именем "mainCourse", а MousseAuChocolat – в регистраци именем "dessert".
Имея такую конфигурацию, вы теперь можете зарегистрировать класс ThreeCourseMealак это продемонстрировано в следующем листинге.
Листинг 10-7: Переопределение автоматической интеграциontainer.Register(Component
.For<IMeal>()
.ImplementedBy<ThreeCourseMeal>()
.ServiceOverrides(new
{
entree = "entree"ainCourse = "mainCourse"essert = "dessert"
}));
Вы можете явным образом обеспечить переопределения для тех параметров (или свойств) которым хотите явно обращаться. В случае класса ThreeCourseMeal вам нужнбращаться ко всем трем параметрам конструктора. Тем не менее, в других случаях вожете захотеть переопределить только один из нескольких параметров; это тожозможно. Метод ServiceOverrides позволяет вам применять анонимный
395
типизированный объект, который указывает, какие параметры необходимереопределить. Если вы не хотите использовать безымянные типы, то другие перегрузкетодов ServiceOverrides дают нам возможность использовать массипециализированных экземпляров ServiceOverride или IDictionary.
Используя анонимный тип, вы сравниваете параметры, которые хотите переопределить, менованной регистрацией. В первом случае вы сравниваете имя параметра entree егистрацией, имеющей имя "entree". В данном случае имена параметров идентичнменам регистраций, но это не обязательно. Остальные параметры преобразуютсохожим способом.
Предупреждение
Несмотря на то, что анонимный тип может выглядеть строго типизированным, если оспользуется указанным образом, то представляет собой еще одну группу "волшебнытрок". В конце концов, он конвертируется в словарь имен и значений. Имена свойстнонимный типа должны совпадать с именами параметров соответствующегонструктора. Если в конструкторе вы измените имя параметра, то ServiceOverridерестанет функционировать до того момента, пока вы не исправите имя параметраоэтому не полагайтесь на эту возможность чаще, чем это требуется.
Поскольку метод ServiceOverrides зависит от сравнения имен параметров конфигурированных переопределений по текстовому принципу, лучше слишком сильна него не полагаться. Если вы чувствуете необходимость использовать этот метод толькля того, чтобы справиться с неопределенно стью, то для избавления от этоеопределенности лучше всего сконструировать API. Это чаще всего приводит к болеолноценному дизайну.
В следующем разделе вы увидите, как выполнить рефакторинг текущего класса
ThreeCourseMeal для получения более общей реализации и в то же время для избавленит присущей неопределенности. Сделать это можно, разрешив в обеде произвольнооличество блюд, – но это принуждает вас к осознанию того, как Castle Windsoодключает списки и последовательности.
Интеграция последовательностей
В разделе 6.4.1 мы обсуждали, как Constructor Injection выступает в роли системповещения при нарушениях принципа единственной ответственности. Урокзвлеченный из того раздела, – вместо того, чтобы рассматривать constructor over-injectioак слабую сторону паттерна Constructor Injection, мы должны скорее порадоваться томуто constructor over-injection делает сомнительную композицию столь очевидной.
Когда дело доходит до DI-контейнеров и неопределенности, мы видим аналогичнузаимосвязь. DI-контейнеры, в общем случае, не справляются с неопределенностью столрациозно. Несмотря на то, что мы можем заставить DI-контейнер, например, Castle
Windsor, справляться с неопределенностью, он чаще всего делает это с трудом. Чащсего это говорит о том, что мы могли бы улучшить конструкцию нашего собственногода.
Подсказка
396
Если конфигурировать определенную составляющу ю вашего API в Castle Windsor сложноодумайте, можете ли вы сделать ваше API более явным и четким. Это не только облегчиго конфигурацию в рамках Castle Windsor, но также, вероятнее всего, улучшит общуонструкцию вашего кода.
Вместо того чтобы чувствовать себя стесненными Castle Windsor, мы должны принять егоглашения и позволить ему провести нас к улучшенной и более последовательноонструкции. В данном разделе мы рассмотрим пример, который продемонстрирует, каожно выполнить рефакторинг таким образом, чтобы избавиться от неопределенно сти, акже покажем, как Castle Windsor работает с последовательностями, массивами писками.
Рефакторинг с целью получения лучшего course
В разделе 10.3.1 "Выбор из составных кандидато в" вы увидели, как ThreeCourseMeal рисущая ему неопределенно сть вынудили нас отказаться от автоматической интеграци вместо нее использовать явный ServiceOverride. Это должно было дать вам намек нересмотр конструкции API.
Простое обобщение приводит нас к реализации IMeal, которая принимает в качествараметров произвольное количество экземпляров ICourse вместо явных трех, как было лучае с классом ThreeCourseMeal:
public Meal(IEnumerable<ICourse> courses)
Обратите внимание на то, что вместо требования о наличии в конструкторе третдельных экземпляров ICourse, единичная зависимость экземпляра
IEnumerable<ICourse> позволяет вам обеспечить любое количество блюд в классе Meal –
от 0 до … бесконечности! Это решает проблему неопределенности, поскольку теперуществует только одна зависимость. Кроме того, это улучшает API и реализациюбеспечивая единственный универсальный класс, который может моделироватножество различных видов обедов, от простого обеда с единственным блюдом дложного, состоящего из 12 блюд.
Имея регистрацию course'ов, продемонстрированну ю в листинге 10-6, вы сможетвтоматически разрешать IMeal, если зарегистрируете его следующим образом:
container.Register(Component
.For<IMeal>()
.ImplementedBy<Meal>());
Тем не менее, когда вы пытаетесь разрешить IMeal, контейнер выдает исключение.
Несмотря на то, что исключение совсем ни о чем нам не говорит, причина в том, что вы нообщили контейнеру, как он должен разрешать IEnumerable<ICourse>. Давайте сделаебзор некоторых различных доступных вариантов.
Конфигурирова ние массивов
Castle Windsor отлично понимает массивы. Поскольку массивы реализуют
IEnumerable<T>, вы можете явным образом сконфигурировать массив для параметронструктора courses. Это можно сделать способом, похожим на синтаксис, который вы
397
видели в листинге 10-7. В следующем листинге вы увидите те же самые coursesпределенные в виде сервисов.
Листинг 10-8: Явное определение массива сервисов
1. container.Register(Component
2. .For<IMeal>()
3. .ImplementedBy<Meal>()
4. .ServiceOverrides(new
5. {
6. courses = new[]
7. {
8. "entree",
9. "mainCourse",
10. "dessert"
11. }
12. }));
Строка 6-10: Переопределение параметра courses
Аналогично листингу 10-7 вы используете метод ServiceOverrides, когда хотитереопределить автоматическу ю интеграцию для конкретных параметров. В данноримере вы хотите явным образом сконфигурировать параметр конструктора courses длласса Meal. Поскольку этот параметр является IEnumerable<ICourse>, вы должны теперадать последовательность сервисов ICourse.
Поскольку массивы реализуют IEnumerable<T>, вы можете определить массименованных сервисов. Осуществляете вы это путем создания массива имен сервисов.
Эти имена идентичны именам, присвоенным каждой регистрации в листинге 10-6, а Castle
Windsor настолько добр, что преобразует этот массив имен сервисов в массив экземпляров
ICourse в рабочей среде. Все это аналогично листингу 10-7 за одним лишь исключением –
fluent registration API по своей природе понимает и преобразует массивы имен сервисов ассивы сервисов.
Несмотря на то, что рефакторинг от ThreeCourseMeal к Meal казался шагом в правильноаправлении, кажется, вы ничего не сделали касательно громоздкости конфигурации.
Можно ли сделать это лучшим способом?
Наверняка упростить конфигурацию можно, но это приведет к меньшему контролю. Каллюстрирует рисунок 10-6, иногда нам нужно уметь делать выбор из списка всеконфигурированных сервисов данного типа, но в других ситуациях нам нужны они все.
398
Рисунок 10-6: Существует несколько способов работы с исчисляемыми зависимостями. В
ситуации, продемонстрированной справа, необходимо разрешить все сервисыконфигурированные в контейнере. В ситуации слева – только некоторую подгруппу.
Пример, который вы видели, соответствует ситуации слева, при которой мы тщательнодбираем явный список именованных сервисов из концептуально громадного списксех сконфигурированных сервисов данного типа. В остальных случаях мы, возможноредпочтем более простое соглашение, согласно которому мы используем все доступныервисы запрашиваемого типа. Давайте посмотрим, как это может выполняться.
Разрешение последовательностей
Castle Windsor по умолчанию не разрешает массивы или IEnumerable<T>. Это можеоказаться довольно неожиданным, поскольку в результате вызова ResolveAlозвращается массив:
IIngredient[] ingredients = container.ResolveAll<IIngredient>();
Тем не менее, если вы попытаетесь позволить контейнеру разрешить компонент, которыависит от массива сервисов, вы получите исключение. Подходящий способ решенианной проблемы – зарегистрировать встроенный CollectionResolver с помощьонтейнера, как это показано ниже:
container.Kernel.Resolver.AddSubResolver(
new CollectionResolver(container.Kernel));
CollectionResolver даст контейнеру возможность разрешать такие последовательностависимостей, как IEnumerable<T>. Благодаря этому теперь вы можете разрешать класс
Meal, не используя явный ServiceOverrides. Имея данную регистрациontainer.Register(Component
.For<IMeal>()
.ImplementedBy<Meal>());
399
вы можете разрешать IMeal с помощью CollectionResolver:
var meal = container.Resolve<IMeal>();
Будет создан экземпляр Meal со всеми сервисами ICourse контейнера.
Возможно, потребители, которые полагаются на списки зависимостей, являются самыонятным случаем использования составных регистраций одной и той же абстракции, неред тем, как окончательно завершить обсуждение этой темы, необходимо рассмотретоследний и, вероятно, слегка неожиданный случай: когда начинают действоватоставные регистрации.
Интеграция Decorator'ов
В разделе 9.1.2 "Паттерны и принципы механизма перехвата" мы обсуждали то, насколькаттерн проектирования Decorator полезен при реализации сквозных сущностей. Ппределению Decorator'ы представляют собой составные типы одной и той же абстракции.
У нас есть, по крайней мере, две реализации абстракции: сам Decorator и обернутый тип.
Если бы мы помещали Decorator'ы в стек, то у нас было бы еще больше реализаций.
Это еще один пример составных регистраций одного и того же сервиса. В отличие оредыдущих разделов эти регистрации не являются концептуально равносильными, ависят друг от друга. В данном разделе вы увидите, как сконфигурировать Castle Windsoаким образом, чтобы он мог работать с этим паттерном.
Явное подключение Decorator'ов
Castle Windsor требует от нас регистрации всех компонентов, которые мы собираемсспользовать. Когда дело касается Decorator'ов, мы должны регистрировать и Decorator, бернутые типы. Поскольку оба типа реализуют один и тот же интерфейс, мы, тем самымводим неопределенность, которую можем побороть. Как показывает следующий листингы можем сделать это явным образом.
Листинг 10-9: Явная конфигурация Decorator'ontainer.Register(Component
.For<IIngredient>()
.ImplementedBy<Breading>()
.ServiceOverrides(new
{
ingredient = "cutlet"
}));
container.Register(Component
.For<IIngredient>()
.ImplementedBy<VealCutlet>()
.Named("cutlet"));
Как мы уже обсуждали во введении к главе 9, панировку можно рассматривать в качествбертки для говяжьей отбивной – регистрация Cotoletta. При разрешении Cotoletta ваужна ссылка на breading, которая должна содержать в себе veal cutlet. Сначала вегистрируете Breading. Вспомните, что в Castle Windsor всегда выигрывает перваегистрация. Вы явным образом используете метод ServiceOverrides для того, чтобконфигурировать, какой именованный сервис должен использоваться для параметронструктора ingredient. Обратите внимание на то, что вы ссылаетесь на компонент под
400
названием cutlet, несмотря на то, что данный компонент на данном этапе еще не быарегистрирован. Такое возможно, поскольку порядок регистрации мало что значит.
Можно регистрировать компоненты до того, как вы зарегистрируете их зависимости, ри этом все будет работать, поскольку при попытке разрешения сервисов всегистрируется должным образом.
Это означает, что перед разрешением IIngredient вы все равно должны зарегистрироватeal cutlet. Впоследствии вы регистрируете ее под именем cutlet. Это имя совпадает менем сервиса, переданного в параметр конструктора ingredient в предыдущеонфигурации.
Несмотря на то, что такая явная конфигурация Decorator'ов возможна и иногда дажеобходима, Castle Windsor по своей природе понимает паттерн Decorator и предоставляеолее неявный способ выполнения тех же самых действий.
Неявное подключение Decorator'ов
Castle Windsor дает нам возможность конфигурировать Decorator'ы неявным образомегистрируя их в подходящем порядке. Вспомните, что выигрывает первая регистрация, ом смысле, что это тип, который возвращается в результате вызова метода Resolve. Молжны сначала зарегистрировать наиболее удаленный Decorator.
По определению Decorator имеет зависимость от другого экземпляра одного и того жипа. Если мы явным образом не определим, какую регистрацию использовать, мы можежидать появления циклических ссылок. Тем не менее, Castle Windsor умнее всего этого.
Он выбирает следующу ю регистрацию соответствующего типа. Это означает, что вместистинга 10-9 вы можете записатontainer.Register(Component
.For<IIngredient>()
.ImplementedBy<Breading>());
container.Register(Component
.For<IIngredient>()
.ImplementedBy<VealCutlet>());
Нет необходимости явным образом присваивать компонентам имена или использоватетод ServiceOverrides для конфигурирования зависимостей. При разрешении
IIngredient Castle Windsor будет автоматически интегрировать класс Breading следующим доступным сервисом IIngredient, то есть классом VealCutlet.
Примечание
Следующий логический шаг вперед от Decorator'а – механизм перехвата. Castle Windsoбладает великолепными возможностями для осуществления перехвата. В разделе 9.3.3
"Пример: перехват с помощью Windsor" уже приводился исчерпывающий пример.
Поэтому вместо того, чтобы заново повторять его в данном разделе я сошлюсь на раздел
9.3.3.
Castle Windsor позволяет нам работать с составными компонентами несколькимазличными способами. Мы можем регистрировать компоненты в виде альтернатив друругу, в виде пиров, которые разрешаются в виде последовательностей, или в видерархических Decorator'ов. В большинстве случаев Castle Windsor будет понимать, что
401
ему делать, но если нам нужен более явный контроль, мы всегда можем использоватетод ServiceOverrides, чтобы явно определить, каким образом компонуются сервисы.
Кроме того, это может происходить в ситуации, когда нам нужно иметь дело с APIтклоняющимися от Constructor Injection. До настоящего момента вы наблюдали за темак конфигурировать компоненты в WindsorContainer, включая то, как определять стилуществования, и как работать с составными компонентами. Но до этого момента мозволяли контейнеру подключать зависимости, явным образом предполагая, что всомпоненты используют Constructor Injection. Поскольку это не всегда происходит именнак, в следующем разделе мы сделаем краткий обзор того, как работать с классамикземпляры которых должны создаваться особым образом.
402
10.4. Конфигурирование сложных API
До настоящего момента мы рассматривали то, как можно конфигурировать компонентыспользующие Constructor Injection. Одним из главных преимуществ Constructor Injectioвляется то, что DI-контейнеры, например, Castle Windsor, могут с легкостью пониматьак компоновать и создавать все классы диаграммы зависимостей.
Все становится менее понятным, когда API не столь хорошо функционируют. В данноазделе вы увидите, как работать с простыми аргументами конструктора, статическимабриками и Property Injection. Все это требует особого внимания. Давайте начнем ассмотрения классов, которые принимают в качестве параметров простыми типыапример, строки и целые числа.
Конфигурирование простыми зависимостей
Пока мы внедряем абстракции в потребителей, все в порядке. Но данный процессложняется, если конструктор зависит от простого типа, например, строковогоислового или перечисляемого. Наиболее часто это случается в реализациях доступа анным, которые принимают в качестве параметра конструктора строку соединения. Но о же время это является более общей проблемой, касающейся всех строковых и числовыипов.
В сущности, регистрация строкового или числового типа в качестве компонентонтейнера не имеет особого смысла, а в Castle Windsor это и вовсе не работает. Если мопытаемся разрешить компонент с простой зависимостью, мы получим исключениеаже если простой тип был до этого зарегистрирован.
Рассмотрите в качестве примера приведенный ниже конструктор:
public ChiliConCarne(Spiciness spiciness)
В этом примере Spiciness имеет перечисляемый тип:
public enum Spiciness
{
Mild = 0,
Medium,
Hot
}
Предупреждение
Согласно эмпирическому правилу перечисления являются "запахами" и их нужнреобразовать в полиморфные классы (имеющие разное состояние). Тем не менее, дланного примера они вполне нам подходят.
Необходимо явным образом сообщить Castle Windsor о том, как разрешать параметонструктора spiciness. Следующий листинг демонстрирует, как это можно сделатьспользуя синтаксис, очень похожий на метод ServiceOverrides, но представляющиобой другой метод.
403
Листинг 10-10: Применение простого значения для аргумента конструкторontainer.Register(Component
.For<ICourse>()
.ImplementedBy<ChiliConCarne>()
.DependsOn(new
{
spiciness = Spiciness.Hot
}));
Вместо метода ServiceOverrides, который переопределяет автоматическую интеграциюожно использовать метод DependsOn, который дает возможность применять экземпляронкретных зависимостей. В данном примере для параметра конструктора spiciness вспользуете значение Spiciness.Hot.
Примечание
Разница между ServiceOverrides и DependsOn заключается в том, что в рамках
DependsOn мы применяем фактические экземпляры, которые используются для данногараметра или свойства, тогда как в рамках ServiceOverrides мы используем имена ипы сервисов, которые будут разрешаться для данного параметра или свойства.
Предупреждение
Как и в случае с ServiceOverrides, метод DependsOn полагается на соответствие междменем параметра и именем безымянного свойства, применяемого в DependsOn. Если мереименуем параметр, то мы должны отредактировать также и вызов DependsOn.
Всякий раз, когда нам нужно использовать простое значение, например, строкоединения, мы можем явным образом определить значение в коде (или взять его ионфигурации приложения) и присвоить его при помощи метода DependsOn. Что хорошри использовании DependsOn, так это то, что нам не нужно явным образом вызыватонструктор или применять какие-либо другие зависимости, в которых автоматическантеграция была бы более подходящей. Но недостаток использования DependsOn – оолее хрупок для выполнения рефакторинга.
Существует более мощная альтернатива, которая позволяет явным образом вызыватонструктор. Она также может использоваться для работы с классами, которые не имеюрадиционных конструкторов.
Регистрация компонентов с помощью блоков кода
Экземпляры некоторых классов не могут быть созданы посредством открытогонструктора. Вместо него для создания экземпляров типов вы должны использоватекоторого рода фабрику. Это всегда проблематично для DI-контейнеров, поскольку пмолчанию они следят за наличием открытых конструкторов.
Рассмотрите приведенный ниже пример конструктора класса JunkFood:
internal JunkFood(string name)
404
Даже если класс JunkFood является открытым, конструктор расположен внутри него.
Очевидно, экземпляры JunkFood должны создаваться посредством статического класса
JunkFoodFactory:
public static class JunkFoodFactory
{
public static IMeal Create(string name)
{
return new JunkFood(name);
}
}
С точки зрения Castle Windsor это проблемное API, поскольку в нем отсутствуют точныраженные и заданные соглашения касательно статических фабрик. Тут требуетсомощь – и мы можем предоставить ее посредством блока кода, что продемонстрирован следующем листинге.
Листинг 10-11: Конфигурирование метода фабрикontainer.Register(Component
.For<IMeal>()
.UsingFactoryMethod(() =>
JunkFoodFactory.Create("chicken meal")));
Для определения блока кода, который создает соответствующий экземпляр, можнспользовать метод UsingFactoryMethod – в данном примере путем вызова метода Creat необходимым параметром для JunkFoodFactory.
Данный блок кода будет вызываться в соответствующее время согласнконфигурированно му стилю существования компонента. В данном примере, посколькы явным образом не определили стиль существования, по умолчанию используется
Singleton, а метод Create будет вызываться всего единожды, вне зависимости от тогоколько раз вы разрешаете IMeal. Если бы вы сконфигурировали компонент такибразом, чтобы для него использовался стиль существования Transient, то метод Creatызывался бы всякий раз, когда вы разрешали бы IMeal.
Использование блока кода предоставляет возможность более экзотичной инициализацибъектов, нежели обычные открытые конструкторы. Кроме того, используя блок кода, молучаем обеспечивающу ю наибольшую типовую безопасность альтернативрименению простых типов, нежели та, которую предоставляет метод DependsOnоторый вы наблюдали в разделе 10.4.1 "Конфигурирование простых зависимостей":
container.Register(Component
.For<ICourse>()
.UsingFactoryMethod(() =>
new ChiliConCarne(Spiciness.Hot)));
В данном примере вы используете блок кода, чтобы явным образом создать новыкземпляр класса ChiliConCarne с необходимым Spiciness. Это обеспечивает большуиповую безопасность, но полностью устраняет возможность автоматической интеграциля рассматриваемого типа.
405
Подсказка
Существуют более продвинутые перегрузки UsingFactoryMethod, которые позволяюазрешать зависимости из контейнера. Это полезно в ситуации, когда нам нужнспользовать UsingFactoryMethod для того, чтобы явным образом присвоить только одиз нескольких параметров, но при этом для выполнения компиляции мы должнередавать все остальные параметры.
UsingFactoryMethod – хороший инструмент для работы с классами, которые не могуыть созданы посредством открытого конструктора. Пока у вас есть некое открытое APIоторое вы можете вызвать для создания необходимого экземпляра класса, вы можетспользовать метод UsingFactoryMethod для того, чтобы явным образом определить блоода, который будет создавать запрашиваемый экземпляр.
Последним общепринятым отклонением от Constructor Injection, которое мы будем здесаблюдать, является Property Injection.
Подключение с помощью Property Injection
Property Injection является не столь четко определенной формой механизма внедрениависимостей, поскольку компилятор не принуждает вас присваивать значение свойствуоступному для записи. И все-таки Castle Windsor, по своей природе, понимает Property
Injection и по возможности присваивает значения доступным для записи свойствам.
Рассмотрите приведенный ниже класс CaesarSalad:
public class CaesarSalad : ICourse
{
public IIngredient Extra { get; set; }
}
Согласно общепринятому заблуждению в салат "Цезарь" входит курица. По существалат "Цезарь" является салатом, но, поскольку с курицей он вкуснее, многие ресторанредлагают возможность добавления в него курицы в качестве дополнительногнгредиента. Класс CaesarSalad моделирует такую возможность посредством доступногля записи свойства под названием Extra.
Если вы зарегистрируете только класс CaesarSalad без какого-либо Chicken, то свойству
Extra не будет присвоено значение:
container.Register(Component
.For<ICourse>()
.ImplementedBy<CaesarSalad>());
Благодаря такой регистрации в результате разрешения ICourse будет возвращатьскземпляр CaesarSalad без какого-либо ингредиента Extra. Т ем не менее, вы можетзменить выходной результат, добавив в контейнер Chicken:
container.Register(Component
.For<IIngredient>()
.ImplementedBy<Chicken>());
container.Register(Component
.For<ICourse>()
.ImplementedBy<CaesarSalad>());
406
Теперь при разрешении ICourse свойство Extra возвращаемого экземпляра CaesarSalaудет представлять собой экземпляр класса Chicken. То есть, Castle Windsoросматривает новый экземпляр на наличие доступных для записи свойств и присваиваем значения, если может предоставить компонент, который по типу совпадает с типовойства.
Подсказка
В ситуациях, когда вам необходимо явным образом управлять тем, как присваиваютсначения свойствам, вы можете использовать метод ServiceOverrides.
В данном разделе вы увидели, как работать с API, которые отклоняются от Constructor
Injection. Вы можете обратиться к простым аргументам конструктора с помощью метода
DependsOn или UsingFactoryMethod, который также поддерживает методы фабрики ругие альтернативы открытых конструкторов. Castle Windsor, по своей природеоддерживает Property Injection.
407
10.5. Резюме
Обзор Castle Windsor, предоставленный в данной главе, только обрисовывает то, чтозможно выполнить с помощью одного из самых развитых и исчерпывающихоступных DI-контейнеров. Поскольку Seam'ы находятся повсюду, мы можем настроитонтейнер для наших собственных нужд, и при этом станут доступными многиополнительные возможности.
В данной главе мы сконцентрировалась на наиболее универсальной части API Windsor.
Представленный в ней материал охватывает основное применение контейнера, а такжоветы по более продвинутым составляющим его API. Это все, что вам нужно знать, еслаша база кода руководствуется DI паттернами и соглашениями. Вооружившись даннынанием, вы должны уметь подключать с помощью Castle Windsor целые приложения.
Даже будучи пустым DI-контейнером, Castle Windsor является довольно значительным.
Он поддерживает практически любую возможность, которую мы могли бы запросить.
Являясь одним из самых старейших .NET DI-контейнеров, он значительно выигрываелагодаря длительным годам своего развития. Однако это не демонстрирует его возраст;
напротив, он поддерживает множество новых идей и современных конструкций языка.
Все же, возможно, самый значительный недостаток Castle Windsor заключается в том, чтгромный набор возможностей реализуется за счет утраты некоторого неоднородного
API. Несмотря на то, что начать работать с классом WindsorContainer довольно легкоолее продвинутые сценарии реализовывать будет сложно до тех пор, пока вы точно нвладеете всем API. К счастью, поскольку форум поддержки Castle Windsor активен, пытные разработчики выполняют его мониторинг, если у вас появляется вопрос, выкорее всего, быстро получите ответ на него.
Несмотря на то, что продвинутое API может казаться устрашающим, начать работать с
Castle Windsor намного легче, чем с любым другим DI-контейнером: создайте экземпляр
WindsorContainer, сконфигурируйте его и разрешайте с помощью него компоненты.
Существует несколько способов конфигурирования контейнера: возможно спользование кода в качестве конфигурации (code as configuration), и XML, онфигурация на основании соглашений; мы даже можем сочетать и сопоставлять все этри способа, чтобы достичь оптимального решения.
В Castle Windsor доступен широкий набор стилей существования, включая Singleton,
Transient и Web Request Context. Если не подходят встроенные стили существования, вожете реализовать пользовательские стили существования – но такое довольно редклучается.
Кажется, что поддержка составных компонентов одной и той же абстракции являетсдной из слабых сторон Castle Windsor. Он, кажется, лучше понимает массивы, черугие типы последовательностей или списков, но мы можем справиться с этиедостатком довольно легко. Точный способ решения данной проблемы зависит от тогоотим мы разрешить все компоненты или только подмножество компонентов одного ого же сервиса.
Несмотря на то, что нам следует полагаться на автоматическую интеграцию, метод
ServiceOverrides дает нам возможность явным образом сконфигурировать то, каависимости присваиваются компонентам.
408
Иногда компоненты не используют Constructor Injection, а вместо него могут использовать
Property Injection или требовать использования отдельных классов фабрики. Такиценарии также поддерживаются посредством различных методов.
Поскольку Castle Windsor является одним из самых универсальных среди доступных DI-
контейнеров, нет причины не использовать его, но он не исключает альтернатив, которытоль же хороши. В следующей главе мы рассмотрим другой развитый и продвинутый DI-
контейнер: StructureMap.
409
11. StructureMap
Меню:
? Знакомство со StructureMap
? Управление жизненным циклом
? Работа с составными компонентами
? Конфигурирование сложных API
В предыдущей главе мы рассматривали DI-контейнер Castle Windsor с целью увидеть, ка нему применяются принципы и паттерны, описанные в частях 1-3. В данной главе мрактически то же самое сделаем и для другого DI-контейнера – StructureMap.
StructureMap – старейший DI-контейнер из всех DI-контейнеров для .NET. Он существуеольше, чем все остальные контейнеры. Несмотря на его возраст, он все еще продолжаективно развиваться и обладает множеством современных возможностей, поэтому молжны рассматривать его возраст, главным образом, как доказательство его развитости.
Кроме того, StructureMap является одним из наиболее универсально используемых DI-
контейнеров.
В данной главе мы рассмотрим то, как можно использовать StructureMap длрактического применения принципов и паттернов, изложенных ранее в частях 1-3.
Рисунок 11-1 демонстрирует структуру данной главы.
Рисунок 11-1: Данная глава разделена на 4 раздела. Первый раздел знакомит нас с API
StructureMap и должен рассматриваться в качестве предпосылки следующих треазделов. Каждый из четырех разделов данной главы может быть прочитан независимо остальных разделов, несмотря на то, что в четвертом разделе используются методыоторые вводятся в третьем разделе. Данные методы имеют относительно понятнымена, поэтому вы можете прочитать четвертый раздел, не читая при этом третий. Но, ругой стороны, вы можете обнаружить, что вам время от времени придется обращаться тому разделу.
Первый раздел обеспечивает полноценное знакомство со StructureMap и демонстрируетак конфигурировать и разрешать компоненты. Каждая из трех последующих глав имееело с паттернами применения, которые требуют к себе дополнительного внимания. Вожете читать их по порядку или пропустить некоторые и прочитать только те, которыам интересны.
Данная глава должна дать вам возможность приступить к работе, а также справиться ольшинством общепринятых проблем, которые могут возникнуть при ежедневном
410
использовании StructureMap. Это не окончательная трактовка StructureMap, поскольксецелое его рассмотрение заняло бы несколько глав или, может быть, даже целую книгу.
Вы можете прочитать эту главу, не читая при этом остальные главы части 4, специальнля того, чтобы познакомиться со StructureMap, или можете прочитать ее совместно стальными главами части 4, чтобы сравнить DI-контейнеры. Цель данной главы –
показать, как StructureMap связан с паттернами и принципами, описанными в частях 1-3, ак он их реализует.
11.1. Знакомство с StructureMap
11.2. Управление жизненным циклом
11.3. Работа с составными компонентами
11.4. Конфигурирование сложных API
11.5. Резюме
411
11.1. Знакомство с StructureMap
Из этого раздела вы узнаете, где можно взять StructureMap, что вы при этом получите ак начать его использовать. Кроме того, мы рассмотрим универсальные вариантонфигурирования, а также то, как упаковать настройки конфигурации в повторнспользуемые компоненты. Таблица 11-1 предоставляет основополагающу нформацию, которая, скорее всего, понадобится вам для того, чтобы приступить к работо StructureMap.
Таблица 11-1: Краткая информация о StructureMap
Вопрос Ответ
Откуда мне еголучить?
Перейти на сайttp://structuremap.github.com/struct uremap/index.html и нажать нсылку Download the Latest Release.
Из Visual Studio 2010 можно получить его посредством NuGet. Имакета – structurem ap.
Что находится агруженном файле?
Можно загрузить zip-файл, содержащий предварительнкомпилированные бинарные файлы. Кроме того, можно получитекущий исходный код и скомпилить его самостоятельно.
Бинарные файлы – это dll-файлы, которые можно размещать тамде захочется, и ссылаться на них из собственного кода.
Какие платформоддерживаются? .NET 3.5 SP1, .NET 4
Сколько он стоит? Нисколько. Это программное обеспечение с открытым исходныодом.
Откуда мне получитомощь?
Гарантированная поддержка отсутствует, но получить помощожно на официальном форумttp://groups.google.com/group/structuremap users.
На какой версии
StructureMaснована данналава?
2.6.1
Как и в случае с Castle Windsor, при использовании StructureMap соблюдается простоитм, проиллюстрированный на рисунке 11-2.
412
Рисунок 11-2: Полноценный паттерн применения StructureMap довольно прост: сначалы конфигурируем контейнер, а затем разрешаем компоненты из этого контейнера. В
большинстве случаев мы создаем экземпляр класса Container и полностьонфигурируем его перед тем, как начать разрешать компоненты из него. Мы разрешаеомпоненты того же экземпляра, который и конфигурировали.
Контейнер или ObjectFactory?
В более ранних версиях StructureMap статический класс ObjectFactory использовался ачестве одиночного контейнера приложений. Он использовался следующим образом:
SauceBearnaise sauce = ObjectFactory.GetInstance<SauceBearnaise>();
Среди нескольких проблем, возникающих при использовании статической фабрикиожно выделить тот факт, что статическая фабрика способствует неправильному еспользованию в качестве Service Locator. На сегодняшний момент использование класса
ObjectFactory не приветствуется, при этом предпочтение отдается экземпляраонтейнеров. На сайте StructureMap (и не только на нем) представлено множествримеров, в которых образцы кода ObjectFactory используются для демонстрациазличных возможностей StructureMap. Но мы должны рассматривать их как рудиментолее ранних лет.
В остальных частях данной главы мы будем игнорировать тот факт, что ObjectFactorуществует и концентрируется исключительно на экземплярах контейнера.
Предупреждение
API StructureMap за последнее время значительно изменилось. Очень часто мы находим нтернете пример кода, в котором используется метод или класс, недоступный в текущеерсии. Скорее всего, он был переименован или, в противном случае, был выполнен егефакторинг. Несмотря на то, что при написании данной главы все примеры кодомпилировались и работали, возможно, некоторые составляющие API изменились зериод, начиная с момента написания главы и до момента ее прочтения вами.
После прочтения этого раздела вы приобретете полноценное понимание всей сущностаттерна применения StructureMap и сможете начать использовать его в сценариях, оторых все компоненты руководствуются должным DI-паттерном, например, Constructor
Injection. Давайте начнем с простейшего сценария и посмотрим, как можно разрешатбъекты с помощью контейнера StructureMap.
413
Разрешение объектов
Ключевая обязанность любого DI-контейнера – разрешение компонентов. В данноазделе мы рассмотрим API, позволяющее нам разрешать компоненты с помощью
StructureMap.
Если вы помните, как мы обсуждали процесс разрешения компонентов с помощью Castle
Windsor, то, возможно, вспомните, что Windsor требует, чтобы вы регистрировали всоответствующие компоненты перед тем, как сможете их разрешить. StructureMap этоге требует. Если вы запрашиваете конкретный тип с конструктором по умолчанию, тикакой конфигурации не нужно. Самый простой вариант использования StructureMaредставлен ниже:
var container = new Container();
SauceBearnaise sauce = container.GetInstance<SauceBearnaise>();
Если у вас есть экземпляр StructureMap.Container, то для получения экземпляронкретного класса SauceBearnaise, вы можете использовать generic-метод GetInstance.
Поскольку у этого класса есть конструктор по умолчанию, StructureMap автоматическоймет, как создать его экземпляр. При этом никакой явной конфигурации контейнера нребуется.
Примечание
Метод GetInstance<T> аналогичен методу Resolve<T> контейнера Windsor.
Поскольку StructureMap поддерживает возможность автоматической интеграции, то дажри отсутствии конструктора по умолчанию он сможет создавать экземпляры бередварительной конфигурации. Делать он это сможет, пока все рассматриваемыараметры конструктора относятся к конкретным типам, а полноценное деревараметров имеет такие типы листьев, которые обладают конструкторами по умолчанию.
В качестве примера рассмотрите приведенный ниже конструктор Mayonnaise:
public Mayonnaise(EggYolk eggYolk, OliveOil oil)
Между тем, как рецепт майонеза достаточно прост, и EggYolk, и OliveOil являютсонкретными классами, обладающими конструкторами по умолчанию. Несмотря на тото сам Mayonnaise не имеет конструктора по умолчанию, StructureMap все равно можеоздать его, не выполняя при этом никакой конфигурации:
var container = new Container();
var mayo = container.GetInstance<Mayonnaise>();
Это происходит, потому что StructureMap может определять, каким образом создавать всеобходимые параметры конструктора. Тем не менее, как только мы введем слабовязывание, нам нужно будет сконфигурировать StructureMap таким образом, чтоббстракции преобразовывались в конкретные типы.
414
Преобразование абстракций в конкретные типы
Несмотря на то, что способность StructureMap автоматически интегрировать конкретныипы, наверняка, время от времени может искусно появляться, при слабом связыванибычно необходимо преобразовывать абстракции в конкретные типы. Созданикземпляров на основании таких преобразований – ключевая услуга, предлагаемая любым
DI-контейнером, но вам все равно нужно задать соответствие.
В данном примере вы преобразуете интерфейс IIngredient в конкретный класс
SauceBearnaise, который позволяет успешно разрешать IIngredient:
var container = new Container();
container.Configure(r => r
.For<IIngredient>()
.Use<SauceBearnaise>());
IIngredient ingredient = container.GetInstance<IIngredient>();
Метод Configure предоставляет возможность сконфигурировать
ConfigurationExpression с помощью блока кода (объяснение смотри в приведенноиже блоке "Nested Closures" (вложенные замыкания)). Оператор конфигурации читаетсочти как предложение (или как инструкция из кулинарной книги): для IIngredienспользуйте SauceBearnaise. Метод For позволяет определить абстракцию, а метод Usозволяет определить конкретный тип, реализующий абстракцию.
Строго типизированное API, предоставляемое классом ConfigurationExpressionомогает предотвратить ошибки конфигурации, поскольку метод Use имеет generic-
ограничение, настаивающее на том, чтобы тип, указанный в аргументе типа, наследовалст аргумента типа абстракции, указанного в методе For. Предыду щий пример кодомпилируется, поскольку SauceBearnaise реализует IIngredient.
В большинстве случаев строго типизированное API – это все, что нам нужно, так как онредоставляет желаемую проверку во время компиляции, Мы должны использовать егам, где это возможно. Однако существуют ситуации, когда нам нужен более слабипизированный способ разрешения сервисов. Это тоже возможно.
Разрешение слабо типизированных сервисов
Иногда мы не можем использовать generic API, так как во время проектирования мы ннаем, какой тип нам понадобится. Все, что у нас есть – это экземпляр Type, но нам всавно хотелось бы получить экземпляр этого типа. Пример этого вы видели в разделе 7-2
"Построение ASP.NET MVC приложений", где мы обсуждали ASP.NET MVC класс
DefaultControllerFactory. Соответствующий метод представлен ниже:
protected internal virtual IController GetControllerInstance(
RequestContext requestContext, Type controllerType);
Поскольку у вас есть только экземпляр Type, вы не можете воспользоваться generic'ами место них должны обратиться к слабо типизированным API. К счастью, StructureMaредлагает слабо типизированную перегрузку метода GetInstance, которая позволяееализовать метод GetControllerInstance приведенным ниже способом:
return (IController)this.container.GetInstance(controllerType);
415
Слабо типизированная перегрузка GetInstance позволяет передавать аргуменontrollerType прямо в StructureMap, но также требует, чтобы вы явным образоривели возвращаемое значение к IController.
Не важно, какую перегрузку GetInstance вы используете, StructureMap гарантирует, чтта перегрузка вернет экземпляр требуемого типа или выдаст исключение, если естависимости, которые не могут соответствовать заданным требованиям. После того, касе необходимые зависимости сконфигурированы должным образом, StructureMap можевтоматически интегрировать необходимый тип.
В предыдущем примере this.container – это экземпляр StructureMap.IContainer. Длбеспечения возможности разрешать необходимый тип все слабо связанные зависимостолжны быть заранее сконфигурированы. Существует множество способов конфигурации
StructureMap. В следующем разделе приводится обзор самых универсальных способов.
Конфигурирование контейнера
Как обсуждалось в разделе 3-2 "Конфигурирование DI-контейнеров", существуеесколько концептуально разных способов конфигурирования DI-контейнера. На рисунке
11-3 представлен обзор возможных вариантов.
Рисунок 11-3: Концептуально разные варианты конфигурирования. Использование кода ачестве конфигурации подразумевает строгую типизированность и имеет тенденцию вному определению. XML, с другой стороны, предполагает позднее связывание, но тожклонно к явному определению. Автоматическая регистрация, напротив, полагается ноглашения, которые могут быть и строго типизированными, и более слабпределенными.
Как и другие, имеющие длительную историю DI-контейнеры, StructureMap сначалспользовал XML в качестве основного источника конфигурации. Тем не менее, многиоманды разработчиков вскоре узнали, что определение регистраций типа в XML
чрезвычайно хрупко, поэтому на сегодняшний день мы предпочитаем строгипизированную конфигурацию. Строго типизированну ю конфигурацию можно
416
выполнить, используя код в качестве конфигурации, но чаще всего наиболее эффективновляется основанная на соглашениях автоматическая регистрация.
StructureMap поддерживает все три подхода и даже позволяет нам сочетать их в пределадного и того же контейнера. В этом отношении StructureMap предоставляет нам все, чты только можем попросить. В данном разделе вы увидите, как можно использоватаждый из этих трех видов источников конфигурации.
Конфигурация в коде
В разделе 11.1.1 "Разрешение объектов" вы уже видели небольшой намек на строгипизированное API для конфигурации StructureMap. В данном разделе мы рассмотриго подробнее.
Существует несколько точек входа в конфигурационное API. Вы уже видели, что онызывается посредством явного использования метода Configure:
var container = new Container();
container.Configure(r => r
.For<IIngredient>()
.Use<SauceBearnaise>());
Еще один вариант – определение точно такого же блока кода прямо при созданикземпляра Container:
var container = new Container(r => r
.For<IIngredient>()
.Use<SauceBearnaise>());
Результат тот же, однако, в данной главе я руководствуюсь соответствующиоглашением и предпочитаю использовать метод Configure, а не конструктор.
Вложенные замыкания
StructureMap широко использует паттерн Вложенное замыкание (Nested Closure), отором конфигурация определяется блоками кода (известными как лямбда-выражения).
В качестве примера ниже приведена сигнатура метода Configure:
public void Configure(Action<ConfigurationExpression> configure);
Параметр configure – делегат, который принимает ConfigurationExpression в качествходного параметра. В примерах кода, приведенных в этой главе, этот параметр обычнбозначается как r, и обычно я передаю делегат в виде блока кода, выраженногосредством параметра r.
При просмотре примеров кода, встречающихся на сайте StructureMap или в блоге
Джереми Миллера, можно обнаружить, что иногда имя параметра, используемого в блокода, задается как x, а иногда – как registry. Поскольку подходящие преценденттсутствуют, я решил использовать r (соответствующее registry) в качестве условногбозначения, которое будет применяться в данной главе. Несмотря на то, что r нвляется достаточно понятным именем для переменной, рассматриваемые здесебольшие по объему блоки кода делают r более подходящим для этих целей именемежели более длинное и менее краткое имя.
417
Класс ConfigurationExpression содержит множество методов, которые можнспользовать для конфигурирования StructureMap. Один из этих методов, For, мы ужидели ранее. Как вы увидите в данном разделе позднее, еще одним таким методовляется метод Scan с приведенной ниже сигнатурой:
public void Scan(Action<IAssemblyScanner> action);
Обратите внимание на то, что сам метод Scan принимает делегат в качестве входногараметра. Когда вы передаете блок кода метода Scan, то получается, что у вас имеетсдин блок кода внутри другого блока кода – отсюда и название Nested Closure (вложенноамыкание).
В отличие от Castle Windsor преобразование IIngredient в SauceBearnaisродемонстрированным ранее способом не исключает разрешения самого
SauceBearnaise. Т о есть, и sauce, и ingredient будут разрешены должным образом:
container.Configure(r =>
r.For<IIngredient>().Use<SauceBearnaise>());
var sauce = container.GetInstance<SauceBearnaise>();
var ingredient = container.GetInstance<IIngredient>();
Если вы вспомните обсуждение, проводимое в разделе 10.1.2 "Конфигурированионтейнера", то вспомните и то, что преобразование IIngredient в SauceBearnaise омощью Castle Windsor приводит к тому, что "исчезает" конкретный класс
(SauceBearnaise), и вам приходится использовать перенаправление типов (Type
Forwarding), чтобы суметь разрешить и IIngredient, и SauceBearnaise. Прспользовании StructureMap такие дополнительные шаги выполнять не нужно, поскольку
StructureMap умеет преобразовывать и IIngredient, и SauceBearnaise. В обоих случаяозвращаемые объекты являются экземплярами SauceBearnaise.
В реальных приложениях нам всегда нужно преобразовывать более одной абстракцииоэтому нам необходимо сконфигурировать составные преобразования. Сделать этожно при помощи единичного вызова метода Configure или посредством составныоследовательных вызовов. Приведенные ниже примеры аналогичны:
container.Configure(r =>
{
r.For<IIngredient>()
.Use<SauceBearnaise>();
r.For<ICourse>()
.Use<Course>();
});
ontainer.Configure(r => r
.For<IIngredient>()
.Use<SauceBearnaise>());
container.Configure(r => r
.For<ICourse>()
.Use<Course>());
Несмотря на то, что во втором примере для конфигурации используются двоследовательных вызова, в первом примере блок кода с большим количествоператоров передается в единичный вызов метода Configure. Оба примера кода
418
завершаются регистрацией корректных преобразований как для интерфейса ICourse, так ля интерфейса IIngredient. Тем не менее, конфигурирование одной и той жбстракции несколько раз приводит к интересным результатам:
container.Configure(r =>
r.For<IIngredient>().Use<SauceBearnaise>());
container.Configure(r =>
r.For<IIngredient>().Use<Steak>());
В этом примере вы регистрируете IIngredient дважды. Если вы разрешаете IIngredientо получаете экземпляр Steak. Выигрывает последняя конфигурация, но предыдущионфигурации не забыты. StructureMap отлично управляет составными конфигурациямдной и той же абстракции, но к этой теме мы вернемся в разделе 11.3.1 "Выбор иоставных кандидатов".
Возможны более продвинутые варианты конфигурирования StructureMap, но можнконфигурировать все приложение при помощи продемонстрированных ниже методов.
Для того чтобы избежать излишнего явного сопровождения конфигурации контейнера, могли бы рассмотреть подход, в большей мере основанный на соглашениях, –
автоматическую регистрацию.
Автоматическая регистрация
В большинстве случаев регистрации будут аналогичными. Такие регистрации труднопровождать, а явная регистрация каждого компонента, возможно, не самыродуктивный подход.
Рассмотрим библиотеку, которая состоит из множества реализаций IIngredient. Можем сконфигурировать каждый класс индивидуальным образом, но это приведет ногочисленным, схожим по внешнему виду вызовам метода Configure. Что еще хужесякий раз при добавлении новой реализации IIngredient, мы должны также явныбразом конфигурировать эту реализацию в контейнере, если хотим, чтобы она былоступной. Было бы более продуктивно установить, что все реализации IIngredientаходящиеся в данной сборке, необходимо зарегистрировать.
Это возможно благодаря методу Scan, который является еще одним примером обширногрименения StructureMap делегатов. Метод Scan доступен в классе
ConfigurationExpression, который уже доступен через блок кода. Именно здесь мы идим паттерн Nested Closure в действии. Приведенный ниже пример кода конфигурируесе реализации IIngredient одним махом:
container.Configure(r =>
r.Scan(s =>
{
s.AssemblyContainingType<Steak>();
s.AddAllTypesOf<IIngredient>();
}));
Метод Scan расположен в пределах блока кода Configure. Переменная s представляеобой экземпляр IAssemblyScanner, который можно использовать для определения тогоаким образом необходимо просматривать сборку и как должны конфигурироваться типы.
419
Экземпляр IAssemblyScanner предоставляет несколько методов, которые можнспользовать для того, чтобы определить, какие сборки необходимо просматривать и каонфигурировать типы из этой сборки. Мы можем использовать generic-метод
AssemblyContainingType для идентификации сборки по типу представителя, нуществует несколько других методов, позволяющих нам предоставить экземпляр
Assembly или даже добавить все сборки, находящиеся по данному пути.
Другой набор методов дает нам возможность определить, какие типы добавлять и как иреобразовывать. Метод AddAllTypesOf обеспечивает самый быстрый способ добавленисех типов, реализующих данный интерфейс, но существует и несколько других методовоторые позволяют нам тщательно контролировать то, как конфигурируются типы.
Предыду щий пример, безусловно, конфигурирует все реализации интерфейса
IIngredient, но мы можем предоставить фильтры, которые позволят нам выбиратолько подмножества. Ниже приведен пример сканирования на основании соглашенийри котором вы добавляете только те классы, имена которых начинаются с Sauce:
container.Configure(r =>
r.Scan(s =>
{
s.AssemblyContainingType<Steak>();
s.AddAllTypesOf<IIngredient>();
s.Include(t => t.Name.StartsWith("Sauce"));
}));
Единственное отличие от предыдущего примера заключается в добавлении вызова метода
Include, который вводит третий уровень Nested Closure. Метод Include принимает ачестве параметра предикат, который используется для определения того, нужно лключать данный Type или нет. В этом примере ответ – true, поскольку Name для Typачинается с Sauce.
Если мы хотим полностью контролировать процесс конфигурирования на основаниоглашений, мы можем определить пользовательское соглашение путем реализацинтерфейса IRegistrationConvention. В следующем листинге демонстрируетсоглашение Sauce, реализованное в виде пользовательского соглашения.
Листинг 11-1: Реализация пользовательского соглашениublic class SauceConvention : IRegistrationConvention
{
public void Process(Type type, Registry registry)
{
var interfaceType = typeof(IIngredient);
if (!interfaceType.IsAssignableFrom(type))
{
return;
}
if (!type.Name.StartsWith("Sauce"))
{
return;
}
registry.For(interfaceType).Use(type);
}
}
420
Класс SauceConvention реализует IRegistrationConvention, который определяединичный член. Метод Process будет вызываться StructureMap для каждого типа сборкипределенного в методе Scan, поэтому вы должны явным образом предоставить набораничных операторов, которые отфильтровывают все не нужные вам типы.
Граничные операторы гарантируют, что любой тип, проходящий через них, – это
IIngredient, чье имя начинается с Sauce, поэтому теперь вы можете зарегистрироваттот тип с помощью registry. Обратите внимание на то, что Registry, между прочимредоставляется посредством Method Injection, который имеет огромный смыслоскольку IRegistrationConvention определяет встраиваемый элемент для StructureMap.
Можно использовать класс SauceConvention в методе Scan следующим образом:
container.Configure(r =>
r.Scan(s =>
{
s.AssemblyContainingType<Steak>();
s.Convention<SauceConvention>();
}));
Обратите внимание на то, что вы все равно определяете сборку за рамками соглашения.
Это позволяет вам менять источники типов, которые обрабатываются независимо оамого соглашения. SauceConvention определяется с помощью метода Convention.
Данный метод требует, чтобы IRegistrationConvention, указанный в качестве аргументипа, имел конструктор по умолчанию. Но существует также метод With, принимающий ачестве входного параметра экземпляр IRegistrationConvention, который можноздать вручную любым необходимым способом.
Поскольку вы можете использовать метод Scan для того, чтобы просматривать все сборк указанной папке, вы также можете применять его для реализации дополнительно ункциональности, в которой дополнения могут добавляться без повторной компиляцисновного приложения. Это один из способов реализации позднего связывания. Еще одиариант – использовать конфигурационное API, основанное на XML.
XML конфигурация
XML конфигурация – отличный вариант в тех ситуациях, когда нам необходимо уметзменять конфигурацию без повторной компиляции приложения.
Подсказка
Используйте XML конфигурацию только для тех типов, изменить которые вам нужно, ныполняя при этом повторной компиляции приложения. В остальных случаях применяйтвтоматическую регистрацию или технологию использования кода в качествонфигурации.
Мы можем использовать специализированные XML-файлы для того, чтобконфигурировать StructureMap, или даже вставить конфигурацию в стандартныонфигурационный файл приложения. Тем не менее, удивительно, но возможностставки конфигурации в конфигурационный файл приложения напрямую ноддерживается в StructureMap, поэтому давайте сначала рассмотрим использованипециализированных XML-файлов.
421
Конфигурацию можно определить в XML и прочитать при помощи метода
AddConfigurationFromXmlFile:
container.Configure(r =>
r.AddConfigurationFromXmlFile(configName));
В данном примере configName – это строка, которая содержит имя соответствующего
XML-файла. Если вы захотите использовать стандартный конфигурационный файриложения, то вам нужно будет использовать AppDomain API для того, чтобпределить путь к текущему конфигурационному файлу:
var configName =
AppDomain.CurrentDomain.SetupInformation.ConfigurationFile;
Примечание
Несмотря на то, что статический класс ObjectFactory напрямую поддерживает чтенионфигурации из App.config, данная возможность не поддерживается для экземпляроонтейнера. Использование AppDomain API для получения имени файла – рекомендуемаехнология работы.
Помимо направления StructureMap к соответствующему файлу XML конфигурациожно передать в виде XmlNode:
container.Configure(r =>
r.AddConfigurationFromNode(xmlNode));
Данный код позволяет вам получать XML конфигурацию не только из файлов, но и иаких произвольных мест, как базы данных или вложенные ресурсы.
Не важно, каков источник XML, схема остается той же. Ниже приведена простаонфигурация, которая преобразует IIngredient в Steak:
<StructureMap MementoStyle="Attribute">
<DefaultInstance PluginType="Ploeh.Samples.MenuModel.IIngredient,
? Ploeh.Samples.MenuModel"
PluggedType="Ploeh.Samples.MenuModel.Steak,
? Ploeh.Samples.MenuModel" />
</StructureMap>
Обратите внимание на то, что вы должны передавать квалифицированное имя типа сборкак для абстракции, так и для реализации – StructureMap называет их Плагинами (Plugins)
или Подключаемыми т ипами (Plugged types).
Если вы хотите вставить данный код XML в конфигурационный файл приложения, то волжны зарегистрировать элемент StructureMap в виде раздела конфигурации:
<configSections>
<section name="StructureMap"
type="StructureMap.Configuration.
?StructureMapConfigurationSection, StructureMap"/>
</configSections>
422
XML конфигурация – отличный вариант в тех ситуациях, когда вам необходимо изменитонфигурацию одного или более одного компонента, не выполняя при этом повторноомпиляции приложения. Тем не менее, поскольку этот вариант довольно хрупокоберегите его для таких конкретных ситуаций, а для основной части конфигурационтейнера используйте либо автоматическую регистрацию, либо код в качествонфигурации.
Подсказка
Помните, что выигрывает последняя конфигурация типа? Данное поведение вы можетспользовать для того, чтобы перезаписать жестко-зако диро ванну ю конфигурацию XML
конфигурацией. Для этого вы должны не забывать считывать XML конфигурацию послого, как будут сконфигурированы любые другие компоненты.
В данном разделе мы, главным образом, рассматривали различные API для конфигурации
StructureMap. Несмотря на то, что, наверняка, можно записать один большой блоеструктурированного кода конфигурации, лучше всего разделить конфигурацию нодули. StructureMap поддерживает эту возможность посредством регист ров (Registries).
Пакетирование конфигурации
Иногда существует необходимость упаковать логику конфигурации в повторнспользуемые группы. И даже в тех случаях, когда само по себе повторное использование является для вас высшим приоритетом, вы можете захотеть предоставить некоторогода структуру, когда вам нужно конфигурировать большое и сложное приложение.
В рамках StructureMap мы можем упаковывать конфигурацию в регистры (Registries)оторые представляют собой классы, унаследованные от конкретного класса Registry.
Рисунок 11-4 демонстрирует взаимосвязь между классом Registry и методом Configureоторый использовался в разделе 11.1.2 "Конфигурирование контейнера".
Рисунок 11-4: Метод Configure класса Container принимает в качестве входногараметра делегат, который действует для ConfigurationExpression – в данной главе мбозначаем экземпляр этого ConfigurationExpression с помощью имени переменной r.
Класс ConfigurationExpression – дочерний класс конкретного класса Registry.
Каждый раз при использовании метода Configure в этой главе вы представляеткземпляр ConfigurationExpression с помощью имени переменной r. Большинстветодов, вызываемых для r (например, методы For и Scan), определены в классе
Registry.
Для того чтобы реализовать Registry, мы реализуем класс, который наследуется от
Registry. Приведенный ниже листинг демонстрирует пример, который конфигурируеспользуемый по умолчанию ICourse, а также добавляет типы IIngredient из сборки. В
нем используется то же самое API, которое мы ранее использовали в разделе 11.1.2
423
"Конфигурирование контейнера", но в настоящее время это API упаковано в отдельныласс.
Листинг 11-2: Реализация регистрublic class MenuRegistry : Registry
{
public MenuRegistry()
{
this.For<ICourse>().Use<Course>();
this.Scan(s =>
{
s.AssemblyContainingType<Steak>();
s.AddAllTypesOf<IIngredient>();
});
}
}
Registry или C onfigurationExpression?
Несмотря на то, что большинство конфигурационных API (например, методы For и Scan)
все равно доступны при прямом наследовании от Registry, мы не можем использоватетоды, определенные непосредственно для класса ConfigurationExpression. Какуункциональность мы теряем?
Существует только пять методов, которые определены непосредственно для
ConfigurationExpression, и разделяются они на две категории:
? Методы, которые считывают конфигурацию из XML
? Методы, добавляющие регистры
Скорее всего, нам не понадобится добавлять Registry внутри Registry, поэтому даннаозможность не столь важна.
Конфигурация, определенная в XML, – совершенно другой способ выраженионфигурации. Мы выражаем определенную часть конфигурации приложения либо в
XML, либо при помощи конфигурационного API, но использовать эти два способдновременно нельзя. В этом свете невозможность определения источников XML из
Registry не является большим недостатком.
И все-таки, можно ли унаследовать регистр от ConfigurationExpression вместо тоготобы наследовать его напрямую от Registry? К несчастью, мы не можем это сделатьоскольку конструктор ConfigurationExpression – внутренний.
Основной момент – это то, что регистр не может быть унаследован от
ConfigurationExpression, а должен наследоваться от самого Registry.
Класс MenuRegistry наследуется от Registry и определяет всю конфигурацию онструкторе. Внутри класса вы можете получить доступ ко всему открытому API класса
Registry, поэтому использовать методы For и Scan вы можете тем же самым способомто и в разделе 11.1.2 "Конфигурирование контейнера". Единственное отличиаключается в том, что в данном случае вы реализуете не безымянный делегат, онструктор. Вместо блока кода и вездесущей переменной r, к которым вы, возможно, нанный момент уже привыкли, вы обращаетесь к API посредством переменной this.
424
После получения MenuRegistry вы теперь можете добавить его в контейнер с помощьетода Configure:
container.Configure(r =>
r.AddRegistry<MenuRegistry>());
Эта generic-версия метода AddRegistry требует, чтобы реализация Registry имелонструктор по умолчанию, но помимо этого доступна и не generic-перегрузка, котораринимает экземпляр Registry в качестве входного параметра, предоставляя нам полныонтроль над тем, как он создается.
Примечание
Методы AddRegistry – два из пяти методов, определенных непосредственно для
ConfigurationExpression и недоступных внутри Registry.
Вы также можете передать Registry непосредственно через конструктор контейнера:
var container = new Container(new MenuRegistry());
Я предпочитаю использовать метод Configure, поскольку он позволяет мне добавлять оследовательность более одного регистра.
Подсказка
Регистры позволяют вам упаковать и структурировать код конфигурации вашегонтейнера. Используйте их вместо однострочной конфигурации, так как это сделаеашу Composition Root более читабельной.
Благодаря регистрам мы можем конфигурировать StructureMap, используя в качествонфигурации код или автоматическую регистрацию, тогда как XML конфигурациолжна импортироваться непосредственно через метод Configure. Кроме того, мы можеочетать оба подхода, получая некоторую часть конфигурации из XML, а остальную – идного или более чем одного регистра:
container.Configure(r =>
{
r.AddConfigurationFromXmlFile(configName);
r.AddRegistry<MenuRegistry>();
});
После того, как контейнер сконфигурирован, вы можете начать разрешать с помощьего сервисы, как это описано в разделе 11.1.1 "Разрешение объектов".
Данная глава познакомила вас с DI-контейнером StructureMap и продемонстрировалундаментальные механизмы: как конфигурировать контейнер и впоследствиспользовать его для разрешения сервисов. Разрешение сервисов с легкостьыполняется при помощи единичного вызова метода GetInstance, поэтому вся сложностаключается в конфигурировании контейнера. Это можно сделать несколькимазличными способами, включая императивный код и XML. До настоящего момента массматривали только самое основное API, поэтому нам придется рассмотреть еще олее продвинутые API. Один из самых важных вопросов – как управлять жизненныиклом компонентов.
425
11.2. Управление жизненным циклом
В главе 8 "Жизненный цикл объектов" мы обсуждали процесс управления жизненныиклом, включая самые универсальные, концептуальные стили существования, например,
Singleton и T ransient. StructureMap поддерживает множество различных стилеуществования и позволяет нам конфигурировать жизненные циклы всех сервисов. Стилуществования, продемонстрированные в таблице 11-2, доступны в виде составляющей
API StructureMap.
Таблица 11-2: Стили существования StructureMap
1. Название 2. Комментарии
3. PerRequest
4. Название стиля существования Per Graphспользуемое в рамках StructureMap. Этот стилспользуется им по умолчанию. Экземпляр онтейнером не отслеживаются.
5. Singleton 6. Стандартный Singleton
7. HttpContext 8. Название стиля существования Web Request Contextспользуемое в рамках StructureMap.
9. ThreadLocal 10. На один поток создается один экземпляр.
11. Hybrid
12. Комбинация HttpContext и T hreadLocal. HttpContexспользуется тогда, когда он доступен (напримерогда контейнер размещается в веб-приложении), а
ThreadLocal используется в качестве резерва.
13. HttpSession 14. На одну HTTP-сессию создается один экземпляр.
Используйте его с осторожностью.
15. HybridHttpSession
16. Комбинация HttpSession и ThreadLocal. HttpSessioспользуется тогда, когда он доступен (напримерогда контейнер размещается в веб-приложении), а
ThreadLocal используется в качестве резерва.
17. Unique 18. Название стиля существования Transientспользуемое в рамках StructureMap.
Реализации различных стилей существования в StructureMap эквивалентны основныаттернам стилей существования, описанным в главе 8, поэтому в этой главе я не будного времени тратить на их обсуждение.
Подсказка
Стиль существования, используемый в StructureMap по умолчанию, – это Per Graph. Каы уже обсуждали в разделе 8.3.3 "Per Graph", данный стиль предлагает наилучшиаланс между эффективностью и безопасностью. Кроме того, если ваши сервисы потоко-
безопасны, то наиболее эффективный стиль существования в этом случае – Singleton, нри этом вы должны не забывать конфигурировать такие сервисы.
В данном разделе вы увидите, как определять стили существования для компонентов и оде, и в XML. Помимо этого в качестве более продвинутого сценария вы рассмотрите тоак реализовать пользовательский стиль существования с целью продемонстрировать, чташи возможности не ограничены встроенными в StructureMap стилями существования.
426
После прочтения этого раздела вы должны будете уметь использовать стилуществования StructureMap в своем собственном приложении.
Давайте начнем с обзора того, как конфигурировать стили существования дломпонентов.
Конфигурирование стилей существования
В данном разделе мы приведем обзор того, как управлять жизненными стилямомпонентов с помощью StructureMap. Стили существования конфигурируются в видоставляющей части конфигурируемых компонентов, и вы можете определить их как оде, так и в XML. Мы поочереди рассмотрим каждый из этих стилей существования.
Конфигурирова ние стилей суще ствования с помощью кода
Стили существования конфигурируются в виде составляющей части Configure APIоторое вы используете для конфигурирования компонентов в общем. Это столь жросто, как и приведенный ниже код:
container.Configure(r =>
r.For<SauceBearnaise>().Singleton());
Данный код конфигурирует конкретный класс SauceBearnaise в виде Singleton такибразом, что каждый раз, когда запрашивается SauceBearnaise, создается один и тот жкземпляр. Если вы хотите преобразовать абстракцию в конкретный класс с заданныизненным циклом, то объявление стиля существования помещается между вызоваметодов For и Use:
container.Configure(r =>
r.For<IIngredient>().Singleton().Use<SauceBearnaise>());
Данный код преобразует IIngredient в SauceBearnaise, а также конфигурирует его иде Singleton. Существуют и другие методы, аналогичные методу Singleton, которыозволяют нам объявить множество других стилей существования. Но не все стилуществования обладают таким методом. Все стили существования могуонфигурироваться при помощи универсального метода LifecycleIs. К примеру, стилуществования Unique не имеет такого метода, но может быть сконфигурироваледующим образом:
container.Configure(r => r
.For<SauceBearnaise>()
.LifecycleIs(new UniquePerRequestLifecycle()));
Метод LifecycleIs принимает в качестве параметра экземпляр ILifecycle, поэтому вожете передать его в любой класс, реализующий этот интерфейс. Как вы увидите азделе 11.2.2 "Разработка пользовательского стиля существования", таким же способоы конфигурируем компонент, имеющий пользовательский жизненный цикл.
Все встроенные в StructureMap стили существования обладают соответствующееализацией ILifecycle, за исключением используемого по умолчанию стилуществования Per Graph. Этот стиль существования обычно неявным образоонфигурируется за счет опускания явного стиля существования. Во всех конфигурациях,
427
которые вы видели в разделе 11.1 "Знакомство со StructureMap", использовался стилуществования Per Graph.
Подсказка
Опускание объявления стиля существования подразумевает Per Graph, которыспользуется в StructureMap по умолчанию. Но null на месте экземпляра ILifecyclакже подразумевает Per Graph.
Если мы создаем некоторого рода универсальный код, который принимает в качествходной информации экземпляр ILifecycle и передает его в метод LifecycleIs, тожем использовать его для конфигурирования компонента с помощью стилуществования Per Graph. Наличие null подразумевает Per Graph, поэтому двриведенных ниже примера, эквивалентны:
container.Configure(r => r
.For<IIngredient>()
.LifecycleIs(null)
.Use<SauceBearnaise>());
ontainer.Configure(r => r
.For<IIngredient>()
.Use<SauceBearnaise>());
Подсказка
Несмотря на то, что вы можете использовать null для того, чтобы дать намек на Per
Graph, лучше всего полностью опустить объявление стиля существования.
В то время как API, раскрывающееся при помощи метода Configure и
ConfigurationExpression, позволяет нам явным образом объявлять стилуществования, Scan API, основанное на соглашениях, не позволяет нам сделать это. В
интерфейсе IAssemblyScanner нет ни одного метода, который дал бы нам возможностдним махом явно объявить стиль существования для набора компонентов.
Тем не менее, мы можем реализовать простой IRegistrationConvention, который можебъявить стиль существования для набора компонентов одним махом. Ниже приведеример использования экземпляра IRegistrationConvention под названием
SingletonConvention:
container.Configure(r =>
r.Scan(s =>
{
s.AssemblyContainingType<Steak>();
s.AddAllTypesOf<IIngredient>();
s.Convention<SingletonConvention>();
}));
Обратите внимание на то, что здесь приведена такая же конфигурация, как и в перворимере автоматической регистрации из раздела 11.1.2 "Конфигурирование контейнера".
Вы добавили только одну строку кода, которая добавляет SingletonConventionродемонстрированный в приведенном ниже листинге.
428
Листинг 11-3: Реализация соглашения по объявлению стиля существованиublic class SingletonConvention : IRegistrationConvention
{
public void Process(Type type, Registry registry)
{
registry.For(type).Singleton();
}
}
Если вы помните предыдущее обсуждение IRegistrationConvention из листинга 11-1, томните и то, что метод Process вызывается в сборке операции Scan для каждогключенного типа. В этом случае единственное, что вам необходимо сделать – объявиттиль существования для каждого типа, используя метод Singleton. Таким образом, мконфигурируем каждый тип в виде Singleton.
Используя код в качестве конфигурации, мы можем конфигурировать компонентымеющие различные стили существования, тем способом, которым только захотим.
Несмотря на то, что это намного более гибкий способ конфигурирования компонентовам иногда нужно обращаться к XML с целью получения позднего связывания. В этолучае мы также можем объявлять стили существования.
Конфигурирова ние стилей суще ствования с помощью XML
В ситуациях, когда нам нужно определять компоненты в XML, мы еще хотим в этом жамом месте уметь конфигурировать их стили существования. Это легко выполняется иде составляющей части XML-схемы, введенной в разделе 11.1.2 "Конфигурированионтейнера". Для объявления стиля существования можно использовать необязательнытрибут Scope:
<DefaultInstance PluginType="Ploeh.Samples.MenuModel.IIngredient,
?Ploeh.Samples.MenuModel"
PluggedType="Ploeh.Samples.MenuModel.Steak,
?Ploeh.Samples.MenuModel"
Scope="Singleton" />
Единственное отличие этого примера от примера из раздела 11.1.2 – добавленнытрибут, который конфигурирует экземпляр в виде Singleton. Когда вы ранее опускалтрибут Scope, автоматически применялся Per Graph, используемый в StructureMap пмолчанию.
И в коде, и в XML конфигурировать стили существования для компонентов легко. Во вселучаях это выполняется в довольно декларативной манере. Несмотря на то, чтыполнять конфигурацию легко, вы должны не забывать, что в некоторые стилуществования включаются объекты-долгожители, которые, пока существуютспользуют память.
Предотвращение утечек памяти
Как и любой другой DI-контейнер StructureMap создает для нас диаграмму объектов, но нтслеживает созданные объекты. Он может отслеживать эти объекты в своих собственныелях, но зависит это от жизненного цикла объекта. К примеру, для того чтобеализовать область применения Singleton, StructureMap должен сохранять ссылку нозданный экземпляр. Это справедливо и для стиля существования HttpContext, в котором
429
все экземпляры хранятся в HttpContext.Current.Items. Тем не менее, после завершения
HTTP-запроса все эти экземпляры выходят за пределы области применения и могут бытничтожены сборщиком мусора.
С другой стороны, стили существования Per Graph и Transient не отслеживают созданные
StructureMap объекты. Как вы видели в листингах 8-7 и 8-8, экземпляры объектооздаются и возвращаются без внутреннего сопровождения. Это имеет некоторыреимущества и недостатки.
Поскольку StructureMap особо не держится за экземпляры, риск появлениеумышленных утечек памяти в этом случае намного меньше. Для такого контейнера, как
Castle Windsor, утечки памяти будут гарантированно возникать, если мы забудем вызватетод Release для всех разрешенных диаграмм объектов. Такого не происходит со
StructureMap, поскольку, как только объекты выйдут за рамки области применения, онудут уничтожены сборщиком мусора.
Недостаток заключается в том, что устраняемые объекты не могут детерминированнничтожаться. Так как мы не можем явным образом высвобождать диаграмму объектовы не можем уничтожать какие-либо устраняемые объекты. Это означает, чтбертывание устраняемых API в неустраняемые сервисы, которое обсуждалось в разделе
6.2.1, становится еще более значимым.
Короче говоря, StructureMap позволяет сборщику мусора уничтожать объекты после тогоак в вашем коде они выходят за рамки области применения, но наши собственные классолжны вести себя точно также. Мы не можем полагаться на то, что контейнер или кодсуществляющий вызов, будут уничтожать любые сервисы, поэтому мы должнродолжать использовать устраняемые объекты в рамках единичных методов.
Встроенные в StructureMap стили существования представляют собой довольнсчерпывающий набор, который должен удовлетворять самым повседневным нуждам.
Помимо этого в редких случаях, когда нам нужен специализированный стилуществования, у нас есть возможность создать свой собственный стиль существования.
Разработка пользовательского стиля существования
В большинстве случаев мы должны уметь выходить из разных ситуаций с помощьсчерпывающего набора стилей существования, уже предоставляемых StructureMap, нсли у нас имеются особые нужды, можно реализовать пользовательский стилуществования. В данном разделе вы увидите, как это сделать. После краткого обзора
Seam, который делает возможным создание пользовательского стиля существованияольшую часть времени мы потратим на пример.
Понимание API стиля существования
В разделе 11.1.2 "Конфигурирование контейнера" вы уже получили некотороредставление об API стилей существования StructureMap. Метод LifecycleIs принимае качестве параметра экземпляр интерфейса ILifecycle, который моделирует то, катили существования взаимодейству ют с остальной частью контейнера StructureMap:
430
public interface ILifecycle
{
string Scope { get; }
void EjectAll();
IObjectCache FindCache();
}
Среди этих трех методов центральным методом является FindCache. Он возвращает кэшоторый StructureMap использует для поиска и вставки объектов, имеющих конкретнытиль существования. Интерфейс ILifecycle, главным образом, выступает в ролбстрактной фабрики для экземпляров IObjectCache, в которых содержится реализацитиля существования. Этот интерфейс довольно-таки сложен, но его не столь сложнеализовать:
public interface IObjectCache
{
object Locker { get; }
int Count { get; }
bool Has(Type pluginType, Instance instance);
void Eject(Type pluginType, Instance instance);
object Get(Type pluginType, Instance instance);
void Set(Type pluginType, Instance instance, object value);
void DisposeAndClear();
}
Большинство методов данного интерфейса имеют дело с поиском, передачей илдалением экземпляра на основании Type и Instance. Рисунок 11-5 иллюстрирует, какибразом StructureMap взаимодействует с реализацией IObjectCache.
Рисунок 11-5: StructureMap взаимодействует с интерфейсом IObjectCache, в первучередь, вызывая метод Get для объекта-кэша. Если кэш возвращает значение, то данноначение используется незамедлительно. В противном случае StructureMap создает новоначение и добавляет это значение в кэш перед тем, как его вернуть.
431
Примечание
Механизм, проиллюстрированный на рисунке 11-5, похож на взаимодействие между
Unity и ILifetimePolicy, продемонстрированное на рисунке 14-6.
Сначала StructureMap пытается получить запрашиваемый экземпляр из метода Get. Еслтот метод возвращает значение null для предоставленных Type и Instance, то
StructureMap создает запрашиваемый экземпляр и перед тем, как его вернуть, добавляетот экземпляр в кэш посредством метода Set.
Давайте на примере рассмотрим, как это работает.
Разработка стиля существования Caching
В данном примере вы будете разрабатывать такой же стиль существования Caching, каы создавали для Castle Windsor в разделе 10.2.3 "Разработка пользовательского стилуществования". Короче говоря, этот стиль существования кэширует и повторнспользует экземпляры в течение некоторого времени перед тем, как их высвободить.
Предупреждение
Этот шаблонный код не является потоко-безопасным, но соответствующая рабочаеализация должна быть потоко-безопасной, поскольку, скорее всего, несколько потокоудут одновременно пытаться разрешать объекты из контейнера.
Давайте начнем с самой простой составляющей. Следующий листинг демонстрируееализацию интерфейса ILifecycle.
Листинг 11-4: Реализация ILifecycle
1. public partial class CacheLifecycle : ILifecycle
2. {
3. private readonly LeasedObjectCache cache;
4. public CacheLifecycle(ILease lease)
5. {
6. if (lease == null)
7. {
8. throw new ArgumentNullException("lease");
9. }
10. this.cache = new LeasedObjectCache(lease);
11. }
12. public void EjectAll()
13. {
14. this.FindCache().DisposeAndClear();
15. }
16. public IObjectCache FindCache()
17. {
18. return this.cache;
19. }
20. public string Scope
21. {
22. get { return "Cache"; }
23. }
24. }
Строка 10: Сохраняет lease в пользовательском cache
432
Строка 12, 16, 20: Члены ILifecycle
Строка 18: Возвращает пользовательский cache
Класс CacheLifecycle, как и требуется, реализует интерфейс ILifecycle. Для полученикземпляра ILease он использует паттерн Constructor Injection. Интерфейс ILease –
локальный вспомогательный (helper) интерфейс, который вводится для реализации
CacheLifecycle. Первоначально этот интерфейс был введен в разделе 10.2.3 "Разработкользовательского стиля существования" и не имеет никакого отношения ни к
StructureMap, ни к любому другому DI-контейнеру.
Примечание
Чтобы увидеть пример реализации ILease, взгляните на раздел 10.2.3.
Вместо того чтобы сохранять экземпляр ILease напрямую в приватном поле, везамедлительно оборачиваете его в пользовательскую реализацию интерфейса
IObjectCache под названием LeasedObjectCache. Это тот кэш, который возвращаетсетодом FindCache.
Примечание
Сравните конструктор из листинга 11-4 с намного более сложным кодом листинга 10-2.
Данное сравнение ясно иллюстрирует превосходство Constructor Injection над Method
Injection.
Несмотря на то, что CacheLifecycle предоставляет исходный интерфейс ILifecycleстинная реализация обеспечивается при помощи пользовательского класса
LeasedObjectCache, который реализует интерфейс IObjectCache.
StructureMap уже предоставляет реализацию IObjectCache под названием
MainObjectCache. К несчастью, MainObjectCache не имеет ни одного виртуального членаоторый мы могли бы переопределить для того, чтобы реализовать стиль существования
Caching. Вместо этого мы можем обернуть MainObjectCache пользовательским
LeasedObjectCache. В следующем листинге продемонстрирован конструктор.
Листинг 11-5: Конструирование LeasedObjectCachrivate readonly IObjectCache objectCache;
private readonly ILease lease;
public LeasedObjectCache(ILease lease)
{
if (lease == null)
{
throw new ArgumentNullException("lease");
}
this.lease = lease;
this.objectCache = new MainObjectCache();
}
В конструкторе LeasedObjectCache вы используете стандартный Constructor Injection длого чтобы внедрить экземпляр ILease. LeasedObjectCache – это Decorator для
MainObjectCache, поэтому вы создаете экземпляр и присваиваете его приватному полю.
Обратите внимание на то, что поле objectCache объявлено как IObjectCache, поэтому вы
433
могли бы просто расширить класс LeasedObjectCache перегруженным конструкторомоторый позволял бы вам внедрять любую реализацию IObjectCache из вне.
Комбинация обернутого IObjectCache и члена ILease приближает реализацию класса
LeasedObjectCache к тривиальной. Следующий листинг демонстрирует реализациажных методов Get и Set, а остальная реализация руководствуется тем же самыроектом.
Листинг 11-6: Реализация методов Get и Seublic object Get(Type pluginType, Instance instance)
{
this.CheckLease();
return this.objectCache.Get(pluginType, instance);
}
public void Set(Type pluginType, Instance instance, object value)
{
this.objectCache.Set(pluginType, instance, value);
this.lease.Renew();
}
private void CheckLease()
{
if (this.lease.IsExpired)
{
this.objectCache.DisposeAndClear();
}
}
Когда StructureMap вызывает метод Get, вы, в первую очередь, удостоверяетесь в том, чтэш не содержит какие-либо просроченные экземпляр ы. При возврате этим методоезультата вы можете быть уверены в том, что, если обернутый кэш содержиапрашиваемый экземпляр, вы сможете безопасно его вернуть.
Наоборот, при вызове метода Set вы тотчас же делегируете этот метод обернутомбъекту-кэшу. Поскольку вы понимаете, что StructureMap использует IObjectCache такак показано на рисунке 11-5, вы знаете, что метод Set вызывается только тогда, когдонтейнер создает новый экземпляр, поскольку ни один экземпляр кэша недоступен. Этзначает, что экземпляр, переданный при помощи параметра value, представляет собоолько что созданный экземпляр, поэтому вы можете безопасно обновить срок аренды.
Вспомогательный метод CheckLease вызывается многими реализациями члена
IObjectCache способами, аналогичными методу Get. Он игнорирует обернутый кэш, еслрок его аренды истек.
Теперь, когда вы знаете, как реализовать пользовательский стиль существования и любыользовательские зависимости, которыми он может обладать, вам остается только узнатьак его применять.
Конфигурирова ние компонентов с помощью пользовательского стилуществования
Использовать CacheLifecycle при конфигурировании компонента легко, а выполняетсто таким же самым способом, которым бы вы конфигурировали любой другой стилуществования:
434
var lease = new SlidingLease(TimeSpan.FromMinutes(1));
var cache = new CacheLifecycle(lease);
container.Configure(r => r
.For<IIngredient>()
.LifecycleIs(cache)
.Use<SauceBearnaise>());
При помощи данного кода контейнер конфигурируется таким образом, что
CacheLifecycle используется для интерфейса IIngredient с одноминутныромежутком. В пределах одной минуты вы можете запросить столько диаграмбъектов, сколько только пожелаете, и при этом будете получать обратно тот же самый
SauceBearnaise всякий раз, когда в диаграмме будет содержаться экземпляр
IIngredient. По окончании одноминутного промежутка последующие запросы будуолучать новый экземпляр SauceBearnaise.
Следует отметить, что способ, при помощи которого реализуется CacheLifecycle, можеледующим образом использоваться для связывания вместе нескольких экземпляровмеющих один и тот же срок аренды:
container.Configure(r =>
{
r.For<IIngredient>().LifecycleIs(cache).Use<Steak>();
r.For<ICourse>().LifecycleIs(cache).Use<Course>();
});
Это будет приводить к тому, что экземпляры ICourse и IIngredient будут просрочены новь созданы в одно и то же время. Иногда это может быть нужно, а иногда и нет.
Альтернативный вариант – использовать два отдельных экземпляра CacheLifecycle. Каоказывает следующий листинг, такая возможность также позволяет вам использовать двазличных таймаута.
Листинг 11-7: Использование разных стилей существования Cache для каждого Instancontainer.Configure(r => r
.For<IIngredient>()
.LifecycleIs(
new CacheLifecycle(
new SlidingLease(
TimeSpan.FromHours(1))))
.Use<Steak>());
container.Configure(r => r
.For<ICourse>()
.LifecycleIs(
new CacheLifecycle(
new SlidingLease(
TimeSpan.FromMinutes(15))))
.Use<Course>());
Первый cache задается с одночасовым таймаутом. Не важно, на сколь долгий или сколалый промежуток времени вам необходим IIngredient, в течение одночасового периоды будете получать один и тот же экземпляр. По истечении одного часа старый экземпляерестает учитываться, а новый экземпляр беспорядочно используется в течениледующего часа.
Cache для ICourse – это другой экземпляр, сконфигурированный с 15-минутныаймаутом. В течение этих 15 минут вы будете получать один и тот же экземпляр, ногда они истекут, будет использоваться новый экземпляр. Стоит отметить, что даже
435
когда время ICourse истекает, IIngredient продолжает существовать благодаря своемолее длительному сроку аренды. Несмотря на то, что ICourse и IIngredient используюдин и тот же стиль существования type, они имеют разные расписания.
В листинге 11-7 вы использовали разные таймауты, но при этом в обоих случаярименяли тип SlidingLease. Это не является обязательным условием, вы могли бспользовать две совершенно разные реализации ILease для каждого экземпляра.
Реализация пользовательского стиля существования для StructureMap не столь сложна. В
теории она может казаться довольно сложной, но если бы вы рассмотрели этот процесс нтегрированной среде разработки (IDE), то быстро поняли бы, что реализациользовательского стиля существования состоит всего лишь из двух классов, в которыамый сложный метод (CheckLease) имеет только один оператор if и состоит из двутрок кода.
Все-таки необходимость реализации пользовательского стиля существования для
StructureMap должна встречаться довольно редко. Исчерпывающий набор встроеннытилей существования должен удовлетворять нашим повседневным нуждам.
На этом мы завершаем наше путешествие по управлению жизненным циклом в рамках
StructureMap. Компоненты должны конфигурироваться при помощи сочетания стилеуществования, и это справедливо, даже когда мы регистрируем составные реализацидной и той же абстракции. Нам еще нужно будет рассмотреть то, как работать оставными компонентами, поэтому давайте направим наше внимание в этоаправлении.
436
11.3. Работа с составными компонентами
DI-контейнеры процветают благодаря их индивидуа льности, но их неопределенносторождает ряд трудностей. При использовании Constructor Injection единичныонструктор предпочтительнее перегружаемых конструкторов, поскольку в этом случасно, какой конструктор использовать в ситуации, когда у вас нет выбора. То же самоасается и преобразования абстракций к конкретным типам. Если мы пытаемсреобразовать конкретные составные типы к одной и той же абстракции, это приводит еопределенности.
Несмотря на столь нежелательну ю особенность как неопределенность, нам частриходится работать с составными реализациями единичного интерфейса. Это можероисходить в следующих ситуациях:
? Для разных потребителей должны использоваться разные специфичные типы.
? Зависимости являются последовательнос тями.
? Используются Decorator'ы.
В данном разделе мы рассмотрим каждую из этих ситуаций и увидим, как StructureMaоочереди справляется с каждой из них. После прочтения раздела вы должны будетметь регистрировать и разрешать компоненты даже тогда, когда в дело вступаюоставные реализации одной и той же абстракции.
Давайте сначала рассмотрим то, как можно обеспечить более разветвленное управлениеежели то, которое предоставляет нам автоматическая интеграция (Auto-Wiring).
Выбор из составных кандидатов
Автоматическая интеграция – удобный и мощный инструмент, но предоставляет наеньшие возможности контроля. Пока все абстракции преобразуются в конкретные типтдельно друг от друга, никаких трудностей не возникает, но как только мы вводиольшее количество реализаций для одного и того же интерфейса, возникаееопределенность.
Давайте для начала повторим, как StructureMap работает с составными регистрациямдной и той же абстракции.
Конфигурирова ние составных реализаций одного и того же плагина
Как вы уже видели в разделе 11.1.2 "Конфигурирование контейнера", вы можетонфигурировать составные плагины одного и того же сервиса:
container.Configure(r =>
{
r.For<IIngredient>().Use<SauceBearnaise>();
r.For<IIngredient>().Use<Steak>();
});
Данный пример кода регистрирует как класс Steak, так и класс SauceBearnaise вместе лагином IIngredient. Выигрывает последняя реализация, поэтому, если вы разрешаете
IIngredient посредством container.GetInstance<IIngredient>(), вы получите
437
экземпляр Steak. Т ем не менее, вызов container.GetAllInstances<IIngredient>()
вернет IList<IIngredient>, который содержит как Steak, так и SauceBearnaise. То естьоследующие конфигурации не позабыты, но их трудно получить.
Подсказка
Выигрывает последняя конфигурация данного типа. Она задает экземпляр по умолчаниля этого типа.
Если есть сконфигурированные экземпляры плагина, которые не могут быть разрешенри вызове GetAllInstances, StructureMap выдает исключение, объясняющее, что естависимости, которые не удовлетворяют заданным условиям. Это сообразно поведениетода GetInstance, но отличается от поведения Castle Windsor или MEF.
Следующий листинг демонстрирует, как можно обеспечить появление подсказок, которыпоследствии могут использоваться для осуществления выбора между различнымконфигурированными экземплярами.
Листинг 11-8: Присваивание имен экземпляраontainer.Configure(r =>
{
r.For<IIngredient>()
.Use<SauceBearnaise>()
.Named("sauce");
r.For<IIngredient>()
.Use<Steak>()
.Named("meat");
});
Вы можете присвоить каждому сконфигурированно му экземпляру уникальное имяоторое в дальнейшем можете применять для того, чтобы отличать друг от друга схожикземпляры.
При наличии именованных экземпляров из листинга 11-8, вы можете разрешать и Steak, и
SauceBearnaise следующим образом:
var meat = container.GetInstance<IIngredient>("meat");
var sauce = container.GetInstance<IIngredient>("sauce");
Обратите внимание на то, что вы передаете тот же самый идентификатор, которыспользовали, когда присваивали имя экземпляру при конфигурировании.
Предполагая, что вам всегда следует разрешать сервисы в единственном Composition Rootы не должны ожидать, что на данном уровне столкнетесь с такой неопределенностью.
Подсказка
Если вы обнаружили, что вызываете метод GetInstance с конкретным идентификаторомодумайте, можете ли вы изменить свой подход так, чтобы он стал менееопределенным.
Можно использовать именованные экземпляры для того, чтобы сделать выбор междоставными альтернативами при конфигурировании зависимости для данного плагина.
438
Конфигурирова ние именованных зависимостей
Для тех же целей, которые обеспечивает автоматическая интеграция, нам иногда нужнереопределять обычное поведение, чтобы обеспечить более расширенный контроль наем, какие зависимости, куда направляются. Иногда возникают ситуации, когда наужно обращаться к неопределенному API. В качестве примера рассмотрите приведенныиже конструктор:
public ThreeCourseMeal(ICourse entree,
ICourse mainCourse, ICourse dessert)
В данном примере у вас имеется три идентично типизированных зависимости, каждая иоторых представляет сущность, отличную от остальных. В большинстве случаев ваеобходимо преобразовать каждую зависимость к отдельному типу. Следующий листинемонстрирует, как вы могли бы решить конфигурировать преобразования ICourse.
Листинг 11-9: Конфигурирование именованных course'оontainer.Configure(r => r
.For<ICourse>()
.Use<Rillettes>()
.Named("entree"));
container.Configure(r => r
.For<ICourse>()
.Use<CordonBleu>()
.Named("mainCourse"));
container.Configure(r => r
.For<ICourse>()
.Use<MousseAuChocolat>()
.Named("dessert"));
Как и в листинге 11-8 вы регистрируете три именованных компонента, преобразуя
Rilettes в экземпляр под названием "entree", CordonBleu – в экземпляр с именем
"mainCourse", а MousseAuChocolat – в экземпляр под названием "dessert".
При такой конфигурации вы теперь можете регистрировать класс ThreeCourseMeal такак показано в следующем листинге.
Листинг 11-10: Переопределение автоматической интеграциontainer.Configure(r => r
.For<IMeal>()
.Use<ThreeCourseMeal>()
.Ctor<ICourse>("entree").Is(i =>
i.TheInstanceNamed("entree"))
.Ctor<ICourse>("mainCourse").Is(i =>
i.TheInstanceNamed("mainCourse"))
.Ctor<ICourse>("dessert").Is(i =>
i.TheInstanceNamed("dessert")));
Как обычно, выражение конфигурирования вы начинаете с преобразования интерфейса
IMeal к конкретному ThreeCourseMeal. Но в дальнейшем вы расширяете выражение промощи метода Ctor. Метод Ctor (сокращение от constructor) повзоляет вам выражато, как должен преобразовываться параметр конструктора данного типа. В случае, когдля данного типа существует только один параметр, можно использовать перегрузку, оторой вам не приходится передавать имя параметра. Тем не менее, поскольку
439
ThreeCourseMeal имеет три параметра ICourse, вам необходимо идентифицироватараметр по его имени, "entree".
Метод Ctor возвращает объект, который позволяет вам задать то, как будет заполнятьсараметр конструктора. Метод Is позволяет вам использовать
IInstanceExpression<ICourse> для отбора именованного экземпляра, что является ещдним примером паттерна Nested Closure. Эти же выражения вы в дальнейшем можетовторить и для следующих двух параметров.
Примечание
В этом примере я присвоил экземплярам конфигурации такие же имена, как и параметрамо это не является необходимым. Я мог назвать экземпляры так, как мне пожелаетсяесмотря на то, что имена параметров, очевидно, привязаны к именам реальныараметров конструктора.
Предупреждение
Идентифицировать параметры по их именам удобно, но это не приводит к безопасномефакторингу. Если мы переименуем параметр, мы можем разрушить конфигурацию (этависит от вашего инструмента рефакторинга).
Переопределение автоматической интеграции путем явного преобразования параметров менованные экземпляры – общепринятый вариант работы. Сделать это мы можем, дажсли мы конфигурируем именованные экземпляры с помощью одного выражения, онструктор – с помощью совершенно другого выражения, поскольку единственнадентификация, связывающая именованный экземпляр с параметром, – это имя. Таделать можно всегда, но, когда нам нужно управлять большим количеством имен, такоариант может оказаться хрупким.
Инте грация ссылок на экземпляры
Всякий раз, когда у нас есть возможность определить экземпляры и конструктор в одноыражении, мы можем сделать это более изящно. Ниже приведенный листинг показываетак это можно сделать.
Листинг 11-11: Использование ссылок на экземпляры для переопределенивтоматической интеграции
1. container.Configure(r =>
2. {
3. var entree =
4. r.For<ICourse>().Use<Rillettes>();
5. var mainCourse =
6. r.For<ICourse>().Use<CordonBleu>();
7. var dessert =
8. r.For<ICourse>().Use<MousseAuChocolat>();
9. r.For<IMeal>()
10. .Use<ThreeCourseMeal>()
11. .Ctor<ICourse>("entree").Is(entree)
12. .Ctor<ICourse>("mainCourse").Is(mainCourse)
13. .Ctor<ICourse>("dessert").Is(dessert);
14. });
Строка 3,5,7: Ссылки на экземпляры
440
Строка 11-13: Использование ссылок на экземпляры
До настоящего момента мы игнорировали тот факт, что типичная цепочка методов
For/Use возвращает какой-то результат, поскольку для нас это было бесполезно. Нозвращаемые значения являются экземплярами SmartInstance<T>, которые можнспользовать в качестве ссылок на конфигурации, которые вы делали до этого. Вместмен экземпляров, которые вам пришлось использовать в листинге 11-10, вы можетспользовать эти ссылки прямо с одной из множества перегрузок метода Is, сравнивааждую локальную переменную с соответствующим именованным параметроонструктора.
Несмотря на то, что данная возможность позволяет нам избавиться от имен экземпляро в, ас все еще остаются "волшебные" строки, которые идентифицируют параметронструктора. Данное API зависит от текстового совпадения между конфигурацией менами параметров, поэтому оно является недолговечным, и такого API стоит позможности избегать. Если мы чувствуем, что это нужно использовать только для тоготобы справиться с неопределенностью, наилучшее решение – разработать API, котороозволит нам избавиться от этой неопределенно сти. Чаще всего это приводит еще и учшему дизайну в целом.
В следующем разделе вы увидите, как можно использовать менее неопределенный и болеибкий подход, при котором разрешается любое количество блюд в обеде. Для этого волжны узнать, как StructureMap работает со списками и последовательностями.
Интеграция последовательностей
В разделе 10.3.2 "Разработка пользовательского стиля существования" мы обсуждали, каыполнить рефакторинг явного класса ThreeCourseMeal к более универсальному классу
Meal, который обладает приведенным ниже конструктором:
public Meal(IEnumerable<ICourse> courses)
В данном разделе мы будем рассматривать то, как можно сконфигурировать StructureMaаким образом, чтобы интегрировать экземпляр ы Meal с соответствующимависимостями ICourse. После рассмотрения этого вопроса вы должны будете приобресторошее понимание тех возможностей, которые доступны в случае необходимостонфигурирования экземпляров, имеющих последовательности зависимостей.
Автоматическое инте грирование последовательностей
StructureMap довольно хорошо разбирается в последовательно стях. Если мы хотиспользовать все сконфигурированные экземпляры данного плагина, то в этом случае наужна именно автоматическая интеграция. К примеру, при наличии сконфигурированныкземпляров ICourse из листинга 11-9 можно сконфигурировать плагин IMeaледующим образом:
container.Configure(r => r.For<IMeal>().Use<Meal>());
Обратите внимание на то, что в данном примере приведено совершенно стандартнореобразование абстракции к конкретному типу. StructureMap будет автоматическонимать конструктор Meal и определять, что подходящее направление действий –
разрешение всех экземпляров ICourse. При разрешении IMeal вы получаете экземпляр
441
Meal наряду с экземплярами ICourse, описанными в листинге 11-9: Rillettes,
CordonBleu и MousseAuChocolat.
Примечание
Сравните удобство автоматической интеграции последовательностей в StructureMap аздел 10.3.2 "Разработка пользовательского стиля существования", которыемонстрирует, как сложно обеспечить такую же функциональность в Castle Windsor.
StructureMap автоматически обрабатывает последовательнос ти и, пока мы не укажебратное, он делает то, что мы и предполагали: разрешает последовательностависимостей всех зарегистрированных экземпляров данного типа. Только в тех случаяхогда нам необходимо отобрать всего лишь несколько экземпляро в из огромного набораам нужно выполнить большее количество действий. Давайте посмотрим, как это сделать.
Отбор нескольких экземпляров из большого набора
Чаще всего используемая StructureMap по умолчанию стратегия внедрения всекземпляров является корректной методикой, но, как показывает рисунок 11-6, могуозникать ситуации, когда нам нужно отобрать несколько сконфигурированныкземпляров из большого набора всех сконфигурированных экземпляров.
Рисунок 11-6: В ситуации, приведенной слева, мы хотим явно выбрать только конкретныависимости из большого перечня всех сконфигурированных экземпляров. Даннаитуация отличается от той, которая приведена справа – здесь мы без разбора отбираесе экземпляр ы.
Когда мы ранее позволили StructureMap автоматически интегрировать всконфигурированные экземпляры, это привело к ситуации, изображенной в правой частисунка 11-6. Если мы хотим сконфигурировать экземпляр так, как это показано в левоасти рисунка, мы должны явным образом указать то, какие экземпляры должнспользоваться.
442
Когда у нас есть возможность конфигурировать зависимости и потребителя в одноызове метода Configure, мы можем использовать ссылочные экземпляры так, как вы этидели в листинге 11-11. Следующий листинг демонстрирует эквивалентну онфигурацию сценария, при котором в конструкторе предполагается наличиоследовательности зависимостей.
Листинг 11-12: Использование ссылок на экземпляры для внедрениоследовательностеontainer.Configure(r =>
{
var entree = r.For<ICourse>().Use<Rillettes>();
var entree1 = r.For<ICourse>().Use<LobsterBisque>();
var mainCourse = r.For<ICourse>().Use<CordonBleu>();
var dessert = r.For<ICourse>().Use<MousseAuChocolat>();
r.For<IMeal>().Use<Meal>()
.EnumerableOf<ICourse>()
.Contains(entree, mainCourse, dessert);
});
Аналогично коду из листинга 11-11 вы присваиваете переменную каждому экземпляруоторый возвращается методом Use. Обратите внимание на то, что вы конфигурируететыре экземпляра ICourse, даже если вы используете только три из них для экземпляра
IMeal. Т ем не менее, вам может понадобиться преобразовать ICourse к LobsterBisquля некоторых других целей, непродемонстриро ванных здесь. Поскольку вы нспользуете результирующую переменную entree1, вы могли бы ее полностью опуститьо я решил ее включить для того, чтобы код был последовательным.
Поскольку конструктор Meal принимает в качестве входного параметра
IEnumerable<ICourse>, вы можете использовать метод EnumerableOf для обозначениоследовательности экземпляров ICourse, явно определенных в методе Contains, где вередаете три ссылки на экземпляры, которые собираетесь использовать.
Этот подход хорошо использовать тогда, когда есть возможность сконфигурировать всоответствующие экземпляры ICourse в том же блоке кода, в котором выполняетсонфигурация IMeal. Это не всегда возможно. Может случаться, что конфигурацикземпляров ICourse разделяется на несколько различных регистров из различныборок. В этом случае мы можем прибегнуть к способу обращения к ним по имени.
Следующий листинг демонстрирует один из таких способов.
Листинг 11-13: Внедрение именованных экземпляров в последовательностontainer.Configure(r => r
.For<IMeal>()
.Use<Meal>()
.EnumerableOf<ICourse>().Contains(i =>
{
i.TheInstanceNamed("entree");
i.TheInstanceNamed("mainCourse");
i.TheInstanceNamed("dessert");
}));
При наличии набора именованных экземпляров, аналогичных тем, которые были создан листинге 11-9, вы можете ссылаться на каждый именованный экземпляр пронфигурировании экземпляра IMeal. Как и в листинге 11-12, вы используете цепочкетодов EnumerableOf/Contains для обозначения последовательности зависимостей. На
443
этот момент у вас нет переменных Instance, поэтому вы должны искать их по имени.
Перегрузка метода Contains дает вам возможность использовать Nested Closure, которыбъявляет то, какие именованные экземпляры вы хотите внедрить в экземпляр Meal.
StructureMap понимает последовательно сти. До тех пор пока не появляется необходимосттбирать только некоторые экземпляры из всех плагинов данного типа, StructureMaвтоматически все делает правильно. Автоматическая интеграция применяется не толькля единичных экземпляров, но также и для последовательнос тей. А контейнереобразует последовательнос ть во все сконфигурированные экземпляр оответствующего типа.
Потребители, которые полагаются на последовательности зависимостей, могут бытамыми интуитивно понятными пользователю составными экземплярами одной и той жависимости. Но перед тем как мы полностью отойдем от данной темы, нам необходимассмотреть последний (и, возможно, слегка неожиданный) случай, когда в дело вступаюоставные экземпляры.
Интеграция Decorator'ов
В разделе 9.1.2 "Паттерны и принципы механизма перехвата" мы обсуждали то, насколькаттерн проектирования Decorator полезен при реализации сквозных сущностей. Ппределению Decorator'ы представляют собой составные типы одной и той же абстракции.
У нас есть, по крайней мере, две реализации абстракции: сам Decorator и обернутый тип.
Если бы мы помещали Decorator'ы в стек, то у нас было бы еще больше реализаций.
Это еще один пример составных регистраций одного и того же сервиса. В отличие оредыдущих разделов эти регистрации не являются концептуально равносильными, ависят друг от друга. В данном разделе вы увидите, как сконфигурировать StructureMaаким образом, чтобы он мог работать с этим паттерном. Существует множество способоонфигурирования Decorator'а, и мы рассмотрим три различных способа достиженидного и того же результата. Каждый из них имеет свои собственные достоинства едостатки.
С оздание обертки при помощи ссылок на экземпляры
Давайте посмотрим, как можно сконфигурировать класс Breading, который является
Decorator'ом IIngredient. Этот класс использует Constructor Injection для полученикземпляра, который необходимо обернуть:
public Breading(IIngredient ingredient)
Для того чтобы сделать панированную телячью котлету, вам хотелось бы обернуть
VealCutlet (еще один IIngredient) в класс Breading. Один из способов это сделать –
использовать ссылки на экземпляры в рамках единичного метода Configure:
container.Configure(r =>
{
var cutlet = r.For<IIngredient>().Use<VealCutlet>();
r.For<IIngredient>().Use<Breading>()
.Ctor<IIngredient>().Is(cutlet);
});
444
Как вы уже видели в листингах 11-11 и 11-12, можно использовать возвращаемое методом
Use значение для того, чтобы перехватить ссылку на экземпляры. Переменная cutleредставляет собой сконфигурированно е преобразование IIngredient в VealCutlet. И
вы можете использовать этот факт для того, чтобы объявить, что эта переменная и есть
Instance, который можно использовать в параметре IIngredient конструктора класса
Breading. Поскольку выигрывает последняя конфигурация, Breading Instance нанный момент является используемым по умолчанию Instance.
Когда вы попросите контейнер разрешить IIngredient, он вернет объект, основанный нспользуемом по умолчанию Instance. Это и есть Breading Instance, в котором вредоставили дополнительный намек на то, что он должен разрешить cutlet Instancля параметра IIngredient класса Breading. В результате мы получаем экземпляр
Breading, содержащий экземпляр Cutlet.
Передача объектов безопаснее передачи строк, поэтому нам следует отдаватредпочтение использованию данной методики всякий раз, когда у нас есть возможностонфигурировать Decorator и обернутый тип в одном вызове метода. Тем не менее, это нсегда возможно.
С оздание обертки при помощи именованных экземпляров
Иногда нам приходится прибегать к именам Instance, потому что мы конфигурируеложенные соучастники в разных вызовах метода, возможно, даже в разных регистрахеализованных в отдельных библиотеках. В таких случаях мы не можем передаватбъекты, а должны полагаться на строки, даже если их легко испортить.
Давайте предположим, что вы уже сконфигурировали VealCutlet следующим образом:
container.Configure(r => r
.For<IIngredient>()
.Use<VealCutlet>()
.Named("cutlet"));
Поскольку вы знаете, что имя экземпляра – cutlet, вы можете использовать его длонфигурирования класса Breading:
container.Configure(r => r
.For<IIngredient>()
.Use<Breading>()
.Ctor<IIngredient>()
.Is(i => i.TheInstanceNamed("cutlet")));
Как и в листингах 11-10 и 11-13 вы используете перегрузку метода Is, которая дает ваозможность предоставить блок кода, идентифицирующий именованный экземпляр. И
снова вы видите паттерн Nested Closure в действии.
Если вы сравните два предыдущих примера, то не заметите, что они похожи. В обоилучаях вы использовали метод Ctor<T>, олицетворяющий параметр конструктора.
Единственное отличие заключается в том, как вы идентифицируете параметр с методом
Is.
Цепочка методов Ctor/Is имеет преимущество, заключающееся в том, что мы можеспользовать ее для указания единственного параметра конструктора, даже если
445
рассматриваемый конструктор имеет более одного параметра. Все параметры, которые ме сможем сконфигурировать при помощи метода Ctor, будут автоматическнтегрированы на основании алгоритмов, используемых StructureMap по умолчанию. Этолезно, если мы хотим сконфигурировать только один из нескольких параметров.
Тем не менее, такой вариант не является строго типизированным. Нет ни какой гарантиито рассматриваемый конструктор имеет параметр указанного типа. Он мог его иметь, нотом мы изменили конструкцию, и теперь он принимает параметры другого типа.
Компилятор об этом не знает, поскольку, когда мы вызываем метод Ctor с конкретныргументом типа, он доверяет нам.
Другой вариант предлагает более строго типизированный подход.
С оздание обертки при помощи делегатов
Вместо того чтобы ссылаться на параметр конструктора по типу или имени, мы можеаписать строго типизированный блок кода, в котором используется конструктор.
Несмотря на то, что такой подход также имеет недостатки, к которым мы позднеернемся, его достоинство заключается в том, что он строго типизирован и поэтому болеезопасен с точки зрения момента конструирования.
Это выглядит слегка абстрактным, поэтому давайте рассмотрим примеремонстрирующий, как сконфигурировать Cotoletta следующим образом:
container.Configure(r => r
.For<IIngredient>().Use<VealCutlet>()
.EnrichWith(i => new Breading(i)));
Метод EnrichWith – член generic-класса SmartInstance<T>, который возвращаетсетодом Use. В данном случае вы вызываете метод Use с аргументом типа VealCutlet.
Этот метод возвращает экземпляр SmartInstance<VealCutlet>. Метод EnrichWitринимает в качестве параметра делегат, который, в свою очередь, принимает в качествходного параметра VealCutlet и возвращает объект.
Вы можете сравнить этот делегат с блоком кода, который принимает в качестве входногараметра VealCutlet. Компилятор делает вывод, что переменная i – это экземпляр
VealCutlet, поэтому вы теперь можете реализовать блок кода посредством вызовонструктора Breading с переменной VealCutlet.
Когда вы попросите контейнер разрешить IIngredient, он сначала создаст экземпляр
VealCutlet, а затем передаст этот экземпляр в качестве входной информации в блок кодаоторый вы определили с помощью метода EnrichWith. При выполнении блока кодкземпляр VealCutlet передается в конструктор Breading, и возвращается экземпляр
Breading.
Достоинство данного подхода заключается в том, что в блоке кода вы записываете код, отором используется конструктор Breading. Этот код является такой же строкой кодаак и любая другая строка кода, поэтому она проверяется компилятором. Этбеспечивает вас уверенностью в том, что если метод Configure компилируется, то
VealCutlet будет корректно обернута.
446
Несмотря на то, что строгая типизированност ь безопаснее, ее сложнее поддерживать.
Если вы впоследствии решите добавить еще один параметр в конструктор Breading, блоода больше не будет компилироваться, и вы должны будете вручную справиться анной проблемой. Это было бы не нужно, если бы вы использовали метод Ctor<T>оскольку StructureMap смог бы отсортировать новый параметр благодаря автоматическонтеграции.
Как вы уже видели, существует несколько способов конфигурирования Decorator'ов.
Строго типизированный подход более безопасен, но для него может потребоваться болеложное сопровождение. Более слабо типизированное API – более гибкое, и дает
StructureMap возможность справиться с изменениями нашего API, но ценой менее слабоиповой безопасности.
Примечание
В данном разделе мы не обсуждали механизм перехвата во время выполнения. Несмотра то, что StructureMap имеет Seam'ы, которые разрешают механизм перехвата, он нбладает встроенной поддержкой динамически создаваемых прокси. Можно использоватти Seam'ы для того, чтобы использовать другую библиотеку (например, Castle Dynamic
Proxy) для создания таких классов. Но поскольку они не являются частью StructureMap, ибсуждение выходит за рамки данной главы.
StructureMap позволяет нам работать с составными экземплярами несколькимазличными способами. Мы можем конфигурировать экземпляры как альтернативы друругу, как пиры, разрешенные в виде последовательностей, или как иерархические
Decorator'ы. В большинстве случаев StructureMap поймет, что делать, но мы всегда можевно определить, каким образом скомпоновать сервисы, если нам нужен более явныонтроль.
Кроме того, это может быть необходимо в тех случаях, когда нам приходится иметь дело с
API, которые отклоняются от Constructor Injection. До настоящего момента вы наблюдалиак конфигурировать экземпляры, включая то, как задавать стили существования и кааботать с составными компонентами. Но до настоящего момента вы позволялонтейнеру подключать зависимости, явным образом предполагая, что все компонентспользуют Constructor Injection. Это не всегда так. В следующем разделе мы сделаебзор того, как работать с классами, экземпляр ы которых должны создаваться особымпособами.
447
11.4. Конфигурирование сложных API
До настоящего момента мы рассматривали то, как можно конфигурировать компонентыспользующие Constructor Injection. Одним из главных преимуществ Constructor Injectioвляется то, что DI-контейнеры, например, StructureMap, могут с легкостью понимать, каомпоновать и создавать все классы диаграммы зависимостей.
Все становится менее понятным, когда API не столь хорошо функционируют. В данноазделе вы увидите, как работать с простейшими аргументами конструкторататическими фабриками и Property Injection. Все это требует особого внимания. Давайтачнем с рассмотрения классов, которые принимают в качестве параметров простейшиипы, например, строки и целые числа.
Конфигурирование простейших зависимостей
Пока мы внедряем абстракции в потребителей, все в порядке. Но данный процессложняется, если конструктор зависит от простейшего типа, например, строковогоислового или перечисляемого. Наиболее часто это случается в реализациях доступа анным, которые принимают в качестве параметра конструктора строку соединения. Но о же время это является более общей проблемой, касающейся всех строковых и числовыипов.
В сущности, регистрация строкового или числового типа в качестве компонентонтейнера не имеет особого смысла, а в StructureMap это и вовсе не работает. Если мопытаемся разрешить компонент с простейшей зависимостью, мы получим исключениеаже если простейший тип был до этого зарегистрирован.
Рассмотрите в качестве примера приведенный ниже конструктор:
public ChiliConCarne(Spiciness spiciness)
В этом примере Spiciness имеет перечисляемый тип:
public enum Spiciness
{
Mild = 0,
Medium,
Hot
}
Предупреждение
Согласно эмпирическому правилу перечисления являются code smell'ами и их нужнреобразовывать в полиморфные классы (имеющие разное состояние). Тем не менее, дланного примера они вполне нам подходят.
Необходимо явным образом сообщить StructureMap о том, как разрешать параметонструктора spiciness. Приведенный ниже пример демонстрирует, как можнспользовать метод Ctor<T> для того, чтобы явным образом предоставить значение длараметра конструктора:
448
container.Configure(r => r
.For<ICourse>()
.Use<ChiliConCarne>()
.Ctor<Spiciness>()
.Is(Spiciness.Hot));
В разделе 11.3 "Работа с составными компонентами" вы не раз видели, каким образоожно использовать метод Ctor<T> для того, чтобы переопределить автоматическу нтеграцию для конкретного параметра конструктора. В данном разделе вы косвенныбразом устанавливаете, что, подразумевается, что конструктор ChiliConCarne имееолько один параметр Spiciness. В противном случае вызов метода Ctor<spiciness>()
будет неоднозначным, и вам придется передавать также и имя параметра.
Метод Ctor<T> возвращает SmartInstance<T>, который имеет разнообразные методы.
Существует 5 перегрузок метода Is, а одна из них дает возможность предоставиткземпляр соответствующего типа. Аргументом типа T в данном случае является
Spiciness, поэтому вы предоставляете Spiciness.Hot в качестве конкретного значения.
Как мы уже обсуждали в разделе 11.3 "Работа с составными компонентами"спользование метода Ctor<T> имеет свои преимущества и недостатки. Если нам нужнолее строго типизированная конфигурация, которая вызывает конструктор илтатическую фабрику, мы также можем это сделать.
Создание объектов с помощью блока кода
Экземпляры некоторых классов не могут создаваться посредством открытыонструкторов. Поэтому в таких случаях для создания экземпляро в типов мы должнспользовать некоторого рода фабрику. Это всегда проблематично для DI-контейнеровоскольку по умолчанию они присматривают открытые конструкторы.
Рассмотрим приведенный ниже пример конструктора для открытого класса JunkFood:
internal JunkFood(string name)
Несмотря на то, что класс JunkFood является открытым классом, его конструктор являетснутренним. Очевидно, экземпляры JunkFood должны создаваться посредствотатического класса JunkFoodFactory:
public static class JunkFoodFactory
{
public static IMeal Create(string name)
{
return new JunkFood(name);
}
}
С точки зрения StructureMap, это API проблематично, поскольку не существует каких-
либо определенных и опубликованных соглашений, касающихся статических фабрик.
Поэтому ему необходима помощь, которую вы можете предоставить посредством блокода, который StructureMap может исполнить для того, чтобы создать экземпляр:
449
container.Configure(r => r
.For<IMeal>()
.Use(() =>
JunkFoodFactory.Create("chicken meal")));
К этому времени цепочка методов For/Use должна быть вам уже знакома. Тем не менее, анном случае вы используете перегрузку метода Use, отличную от той, которую вспользовали ранее. Эта перегрузка позволяет вам передавать Func<IMeal>, что велаете посредством блока кода, который вызывает статический метод Create класса
JunkFoodFactory.
Подсказка
Если вы хотите разрешить класс ChiliConCarne из раздела 11.4.1 "Конфигурированиростейших зависимостей" строго типизированным способом, то можете использоватанную перегрузку Use для непосредственного вызова конструктора.
После завершения написания кода, который создает экземпляр, можете ли вы ответитьочему такой подход в любом случае лучше непосредственного вызова кода? Использулок кода внутри оператора For/Use, вы кое-что, таким образом, приобретаете:
? Преобразуете IMeal к JunkFood.
? Стиль существования все еще можно конфигурировать. Несмотря на то, что длоздания экземпляра будет вызываться блок кода, он может и не вызыватьссякий раз, когда запрашивается данный экземпляр. За исключением тех случаевогда вы используете стиль существования Unique, иногда вместо блока кодожет использоваться кэшированный экемпляр.
В общем, существует пять различных перегрузок метода Use. Для задания конкретногипа можно использовать generic-версию, но остальные перегрузки позволяют наередавать конкретный экземпляр или блоки кода, создающие конкретный экземпляр.
Последним общепринятым отклонением от Constructor Injection, которое мы рассмотрим анном разделе, является Property Injection.
Интеграция с помощью Property Injection
Property Injection является не столь четко определенной формой механизма внедрениависимостей, поскольку компилятор не принуждает вас присваивать значение свойствуоступному для записи. Это справедливо и для StructureMap, который будет пропускатоступные для записи свойства до тех пор, пока мы явно не попросим его что-нибудь ими сделать.
Рассмотрите приведенный ниже класс CaesarSalad:
public class CaesarSalad : ICourse
{
public IIngredient Extra { get; set; }
}
Согласно общепринятому заблуждению в салат "Цезарь" входит курица. По существалат "Цезарь" является салатом, но, поскольку с курицей он вкуснее, многие ресторанредлагают возможность добавления в него курицы в качестве дополнительного
450
ингредиента. Класс CaesarSalad моделирует такую возможность посредством доступногля записи свойства под названием Extra.
Если вы конфигурируете только класс CaesarSalad, явно не обращаясь к свойству Extraо этому свойству не будет присвоено значение. Вы все равно можете разрешаткземпляр, но свойство Extra будет иметь значение по умолчанию, которое ему присвоионструктор (если только это имеет место).
Существует несколько способов, с помощью которых можно сконфигурировать
CaesarSalad таким образом, чтобы свойство Extra заполнялос ь соответствующибразом. Один из таких способов – использование ссылок на экземпляр ы. Этот способ вже ранее несколько раз видели в данной главе:
container.Configure(r =>
{
var chicken = r.For<IIngredient>().Use<Chicken>();
r.For<ICourse>().Use<CaesarSalad>()
.Setter<IIngredient>().Is(chicken);
});
Из нескольких предыдущих примеров вы можете вспомнить, что метод Use возвращает
Instance, который вы можете помнить как переменную. В листинге 11-10 и во многиоследующих примерах вы использовали метод Ctor<T> для того, чтобы обозначитараметр конструктора определенного типа. Метод Setter<T> работает аналогичныбразом, но только для свойств. Вы передаете экземпляр chicken в метод Is, чтобаставить StructureMap присвоить значение свойству при построении экземпляра.
Когда вы будете на основании этой конфигурации разрешать ICourse, вы получитбратно экземпляр CaesarSalad, свойству Extra которого будет присвоен экземпляр
Chicken. Это предоставляет вам возможность дифференциро ванного управленионкретными свойствами конкретных типов. API, которое в большей степени основано ноглашениях, предоставляет нам возможность утверждать, что мы хотим, чтобы
StructureMap использовало все свойства данного типа для Property Injection. К примеруы могли бы установить, что все заданные свойства IIngredient должны внедрятьсместе с соответствующим экземпляром.
В случае CaesarSalad вы можете выразить это следующим образом:
container.Configure(r =>
r.For<IIngredient>().Use<Chicken>());
container.Configure(r =>
r.For<ICourse>().Use<CaesarSalad>());
container.Configure(r =>
r.FillAllPropertiesOfType<IIngredient>());
Благодаря методу FillAllPropertiesOfType вы можете установить, что всем доступныля записи свойствам типа IIngredient должно быть присвоено значение. StructureMaудет использовать экземпляр по умолчанию, сконфигурированный для IIngredientоэтому при разрешении ICourse вы получите экземпляр CaesarSalad со свойством
Extra равным Chicken.
FillAllPropertiesOfType будет заполнять любое доступное для записи свойствказанного типа, поэтому, если другие конкретные классы также обладают доступными
451
для записи свойствами того же типа, в них также будут внедрены сконфигурированныкземпляры. Это может быть целесообразным, если мы руководствуемся соглашениемоторое использует Property Injection для определенных типов.
В данном разделе вы увидели, как можно использовать StructureMap для работы с болеложными API создания экземпляров. Для того чтобы задать конкретные экземпляры иллоки кода, которые будут применяться для создания экземпляро в, можно использоватножество перегрузок методов Use и Is. Вы также видели, что Property Injection можнонфигурировать непосредственно при конфигурировании экземпляров или в видоглашения для конкретного типа.
452
11.5. Резюме
Данная глава представляет собой дегустационное меню StructureMap и его возможностей.
Мы соотносим принципы и паттерны остальной части книги с API контейнера
StructureMap. StructureMap – это старейший из доступных в .NET DI-контейнеров, но этоакт ничего не говорит ни о его возрасте, ни о доминирующем использовании вложенныамыканий (Nested Closures), ни о его конфигурационном API, которое обладаевойством типовой безопасности, ни о возможности поиска типов в нем на основаниоглашений.
Использование паттерна Nested Closure, возможно, является одной из самытличительных особенностей StructureMap. Для его использования необходимо хорошазбираться в делегатах и блоках кода.
Начать работать со StructureMap довольно легко. Он поддерживает автоматическунтеграцию и автоматически определяет, каким образом создавать конкретные типы, дажсли они не были явным образом сконфигурированы. Это означает, что вы можетконцентрироваться на преобразовании абстракций в конкретные типы, и, когда вакончите это преобразование, вы сможете разрешать диаграммы объектов. APIспользуемое для поиска типов, даже дает вам возможность сконфигурировать множествервисов посредством всего нескольких строк кода, используя при этом длонфигурирования подход, основанный на соглашениях.
Несмотря на то, что нам не нужно конфигурировать конкретные сервисы, мы можеахотеть сделать это в тех ситуациях, когда нам нужно изменить стиль существования. Пмолчанию используется стиль существования Per Graph, поэтому всякий раз, когда у намеются потоко-безопасные сервисы, мы можем потенциально увеличить эффективностутем конфигурирования их в виде Singleton'ов. Для этого нужен определенный шагесмотря на то, что можно было бы выразить это во время поиска типа посредствоспользования пользовательского соглашения о регистрации.
Не гарантируется, что экземпляры будут отслеживаться контейнером, поэтому
StructureMap не предлагает никакого API для высвобождения конкретной диаграммбъектов. Это эффективно предотвращает утечки памяти для обычных классов, но, ругой стороны, почти гарантирует утечки памяти для устраняемых зависимостей.
Поэтому важно реализовывать все зависимости таким образом, чтобы они самостоятельнправляли всеми внутренними использованиями устраняемых типов.
StructureMap свободно обрабатывает последовательнос ти зависимостей. Когда класависит от последовательности экземпляров одного и того же типа, StructureMap будевтоматически интегрировать экземпляр со всеми экземплярами того типа, который имееависимость. Поведение StructureMap интуитивно понятно, поэтому нам нужно всегишь явно выполнить определенное действие в тех ситуациях, когда нам требуетстобрать только некоторое подмножество экземпляров из всех доступных экземпляров.
Несмотря на то, что мы можем явным образом сконфигурировать Decorator'ы,
StructureMap не имеет никаких соглашений по интеграции Decorator'ов и не обладаеозможностями динамического перехвата. Существуют Seam'ы, которые могуспользоваться для того, чтобы интегрировать в StructureMap динамическое прокси APIсли нам нужно интегрировать Decorator'ы.
453
Поскольку StructureMap столь глубоко полагается на вложенные замыканияеудивительно, что многие методы конфигурации обладают перегрузками, дающими наозможность использовать блок кода, который будет вызываться при созданикземпляров. Несмотря на то, что эти перегрузки не являются необходимыми в теитуациях, когда регистрируемые нами классы используют Constructor Injection, можем использовать их, если один или более одного из наших классов должноздаваться особым образом.
StructureMap – исчерпывающий DI-контейнер, который предлагает широкий набородвинутых возможностей. Он имеет отличное поведение по умолчанию и может егкостью использоваться, особенно в тех случаях, когда дело касается автоматическонтеграции конкретных типов или последовательно стей. С другой стороны, он нбладает возможностями динамического перехвата и не может уничтожать устраняемыависимости. Эти очевидные недостатки являются, главным образом, результатоилософии проектирования. Если мы никогда не будем реализовывать устраняемыервисы и вместо динамического перехвата решим использовать явные Decorator'ы, то том случае StructureMap является отличным вариантом, поскольку он использует этграничения для того, чтобы упростить для пользователей все остальное.
454
12. Spring.NET
Меню:
? Знакомство со Spring.NET
? Управление жизненным циклом
? Работа с составными компонентами
? Конфигурирование сложных API
В предыдущих главах вы наблюдали за тем, как применять к Castle Windsor и
StructureMap принципы и паттерны, описанные в частях 1-3. В данной главе мы то жамое будем делать для DI-контейнера Spring.NET.
Наряду с Castle Windsor и StructureMap контейнер Spring.NET принадлежит к числу DI-
контейнеров .NET "первого поколения". Появился он в 2006 году и даже на сегодняшниомент все еще поддерживает .NET 1.1. Это порт Java-версии Spring Frameworkвляющегос я большим и исчерпывающим фреймворком приложений, который имеет дело множеством различных аспектов программного обеспечения – не только Object
Com position. DI-контейнер – один из множества доступных во фреймворке компонентово его можно отлично использовать и как самостоятельный компонент, не обращаясь пртом к другим компонентам Spring.NET.
В этой главе мы сконцентрируемся на рассмотрении DI-контейнера Spring.NET и опустистальные компоненты фреймворка. Как в предыдущих и последующих главах, мы будезучать то, как можно использовать Spring.NET для применения принципов и паттерновписанных в частях 1-3. Рисунок 12-1 демонстрирует структуру данной главы.
Рисунок 12-1: Данная глава разделена на 4 раздела. Первый раздел знакомит нас с API
Spring.NET и должен рассматриваться в качестве предпосылки следующих трех разделов.
Каждый из четырех разделов данной главы может быть прочитан независимо остальных разделов.
Первый раздел обеспечивает полноценное знакомство со Spring.NET и демонстрирует, каонфигурировать и разрешать объекты. Каждая из трех последующих глав затрагиваеаттерны применения, которые требуют к себе дополнительного внимания. Вы можетитать их по порядку или пропустить некоторые и прочитать только те, которые вантересны.
Данная глава должна дать вам возможность приступить к работе, а также справиться ольшинством общепринятых проблем, которые могут возникнуть при ежедневноспользовании Spring.NET. Это не окончательная трактовка Spring.NET, поскольку
455
всецелое его рассмотрение заняло бы несколько глав или, может быть, даже целую книгу.
В любом случае весь фреймворк Spring.NET в данной книге не рассматривается. К
рассматриваемому вопросу относится только DI-контейнер Spring.NET, поэтому, когда спользую название Spring.NET, я ссылаюсь конкретно на контейнер.
Вы можете прочитать эту главу, не читая при этом остальные главы части 4, специальнля того, чтобы познакомиться со Spring.NET, или можете прочитать ее совместно стальными главами части 4, чтобы сравнить DI-контейнеры. Цель данной главы –
показать, как Spring.NET связан с паттернами и принципами, описанными в частях 1-3, ак он их реализует.
12.1. Знакомство с Spring.NET
12.2. Управление жизненным циклом
12.3. Работа с составными компонентами
12.4. Конфигурирование сложных API
12.5. Резюме
456
12.1. Знакомство с Spring.NET
Из этого раздела вы узнаете, где можно взять Spring.NET, что вы при этом получите и каачать его использовать. Кроме того, мы рассмотрим универсальные вариантонфигурирования. Таблица 12-1 предоставляет основополагающую информациюоторая, скорее всего, понадобится вам для того, чтобы приступить к работе со
Spring.NET.
Таблица 12-1: Краткая информация о Spring.NET
Вопрос Ответ
Откуда мне еголучить?
Перейти на страницу www.sprin gframework.net/do wnload.html агрузить последний релиз.
Из Visual Studio 2010 можно получить его посредством NuGet. Имакета – Spring.Core. Но если вам нужны возможности механизмерехвата, то в этом случае вам нужен пакет Spring.Aop.
Что находится агруженном файле?
Zip-файл, который содержит все вам необходимое:
скомпилированные бинарные файлы, исходный код окументацию.
Какие платформоддерживаются?
Поддерживаются все версии ASP.NET, начиная с .NET 1.1, хотоследующие версии будут поддерживать только версии .NET 2.0 ыше.
Сколько он стоит? Нисколько. Это программное обеспечение с открытым исходныодом.
Откуда мне получитомощь?
Коммерческую поддержку можно получить от SpringSource –
организация, которая занимается разработкой Spring.NET.
Невзирая на коммерческую поддержку, Spring.NET все ещстается программным обеспечением с открытым исходным кодомоторое обладает процветающей экосистемой, поэтому, скоресего (но не гарантированно), помощь можно получить нфициальном форуме http://forum.springframework.net.
На какой версии
Spring.NET основананная глава?
1.3.1
Использование DI-контейнера Spring.NET предполагает выполнение трех шаговродемонстрированных на рисунке 12-2.
457
Рисунок 12-2: Полноценный паттерн применения Spring.NET включает в себя три шага:
сначала мы задаем то, как объекты конфигурируются и компонуются в XML-файле. Затеы загружаем XML-конфигурацию в экземпляр контейнера. На последнем и финальноаге мы можем разрешать объекты из экземпляра контейнера.
После прочтения этого раздела вы приобретете полноценное понимание всей сущностаттерна применения Spring.NET и сможете начать использовать его в сценариях, оторых все компоненты руководствуются должным DI-паттерном, например, Constructor
Injection. Давайте начнем с простейшего сценария и посмотрим, как можно разрешатбъекты с помощью контейнера Spring.NET.
Разрешение объектов
Основная услуга, предоставляемая любым DI-контейнером – компоновка диаграмбъектов, и Spring.NET не является исключением. Поскольку это основная возможностонтейнера, именно сейчас и стоит приступить к знакомству с соответствующим API, чт и буду делать в этом разделе.
В предыдущих главах, посвященных Castle Windsor и StructureMap, вы видели, как эти DI-
контейнеры по-разному подходят к тому, нужно ли конфигурировать компоненты до тогоак можно будет их разрешать. Castle Windsor требует, чтобы мы явно конфигурировалаждый отдельный компонент, а StructureMap может работать с конкретными типами бередварительной конфигурации. Но оба эти DI-контейнера, как и все DI-контейнерыассматриваемые в следующих главах, оперируют типами: мы отправляем в контейнеапрос на разрешение соответствующего типа.
Spring.NET отличается от остальных DI-контейнеров, поскольку его ключевой механизапросов основывается не на типах, а на именах. Вместо того чтобы запрашиватонкретный тип, мы запрашиваем у Spring.NET именованный объект. По аналогии с Castle
Windsor все объекты должны быть сконфигурированы до того, как мы сможем использовать.
Конфигурирование Spring.NET выполняется в XML, поэтому даже самый простоценарий включает в себя фрагмент XML, а также некоторый .NET код. К примеру, длого чтобы разрешить конкретный класс SauceBearnaise, вы должны сначала задатбъект в XML-конфигурации:
<objects xmlns="http://www.springframework.net">
<object id="Sauce"
type="Ploeh.Samples.MenuModel.SauceBearnaise,
? Ploeh.Samples.MenuModel" />
</objects>
В Spring.NET каждый сконфигурированный объект должен отображаться в элементbject. Данный элемент может иметь атрибут id, который присваивает имя объекту, а
458
также атрибут type, который определяет .NET тип объекта. Имя используется в телучаях, когда вы собираетесь разрешить объект.
Для разрешения экземпляра SauceBearnaise вы должны загрузить XML-конфигурацию кземпляр контейнера. При помощи XmlApplicationContext вы можете загрузить XML
из нескольких различных источников, включая вложенные ресурсы и конфигурационныайл приложения. Но в примере ниже используется самостоятельный XML-файл поазванием sauce.xm l:
var context = new XmlApplicationContext("sauce.xml");
SauceBearnaise sauce = (SauceBearnaise)context.GetObject("Sauce");
Для того чтобы разрешить экземпляр SauceBearnaise вы вызываете метод GetObject c
ID, равным Sauce, который вы задали для объекта в XML-конфигурации. ID может бытюбой строкой, но Spring.NET рекомендует использовать Pascal нотацию в качествоглашения по именованию.
Поскольку метод GetObject возвращает слабо типизированный экземпляр System.Objectтобы начать его использовать, вам необходимо привести возвращаемое значение оответствующему типу
Обратите внимание на то, что Spring.NET явным образом не различает конкретные бстрактные типы. В то время как другие DI-контейнеры требуют от нас преобразованибстрактных типов в конкретные, Spring.NET основан только на преобразованиях имен онкретные типы. Как продемонстрирует данная глава, Spring.NET все равно можеазрешать запросы преобразования абстракций в конкретные экземпляр ы, нспользуемый механизм более явный, чем тот, который применяют другие DI-
контейнеры.
Метод GetObject определяется интерфейсом IObjectFactory, который является одним иундаментальных интерфейсов, задаваемых Spring.NET. Как и подразумевает его имянтерфейс IObjectFactory сконцентрирован на создании объектов и не содержит методыозволяющие конфигурировать контейнер. Скорее за это отвечают типы более высокогровня, например, XmlApplicationContext.
Метод GetObject является одним из нескольких методов, которые можно использоватля разрешения объектов. Тем не менее, поскольку все они слабо типизированы, молжны всегда явным образом приводить возвращаемо е значение к типу, с которым мобираемся работать. С помощью метода GetObject мы можем запрашивать объектолько по имени, а не по типу, поэтому, каким образом мы должны выходить из ситуацийогда все, что у нас есть – это тип?
Разрешение запросов типа
Иногда у нас имеется не имя, а экземпляр Type, который мы должны разрешить кземпляр этого типа. Пример этого вы видели в разделе 7.2 "Построение ASP.NET MVC
приложений", где мы обсуждали ASP.NET MVC класс DefaultControllerFactory.
Соответствующий метод приведен ниже:
protected internal virtual IController GetControllerInstance(
RequestContext requestContext, Type controllerType);
459
При наличии типа вместо имени мы могли бы соблазниться заданием и сопровождениевного преобразования типов в имена, но это было бы излишним. Наиболее подходящиариантом было бы использование соглашения по именованию, которое позволяло бы наетерминированно наследовать имя от экземпляра Type. Но интерфейс
IListableObjectFactory, который наследуется напрямую от IObjectFactory, задаеетод под названием GetObjectsOfType, который можно использовать для полученисех объектов, соответствующих данному типу. Полагая, что запрашиваемыontrollerType – уникален в конфигурации Spring.NET, вы можете реализовать метод
GetControllerInstance следующим образом:
IDictionary controllers =
this.context.GetObjectsOfType(controllerType);
return controllers.Values.OfType<IController>().Single();
Поле context – экземпляр IListableObjectFactory, который можно запросить для всебъектов, соответствующих controllerType. Несмотря на то, что вам возвращаетсловарь, вам интересны только значения, и при этом вы предполагаете, что каждыапрашиваемый контроллер будет уникальным в пределах упомянутой выше XML-
конфигурации.
Хотя Spring.NET не предоставляет никакого generic API, вы можете легкнкапсулировать предыдущий запрос в метод расширения:
public static T Resolve<T>(this IListableObjectFactory factory)
{
return factory.GetObjectsOfType(typeof(T))
.Values.OfType<T>().Single();
}
Это позволит вам разрешать тип следующим образом:
SauceBearnaise sauce = context.Resolve<SauceBearnaise>();
Метод GetObjectsOfType возвращает все сконфигурированные объекты, которыоответствуют запрашиваемому типу. Поскольку SauceBearnaise реализует интерфейс
IIngredient, вы можете также разрешить IIngredient из контекста:
IIngredient ingredient = context.Resolve<IIngredient>();
Типичный ASP.NET Controller и любой другой код приложения, который мы, скоресего, напишем, будет иметь сложную иерархию зависимостей. Для того чтобы позволить
Spring.NET компоновать объекты из слабо связанных сервисов, мы должны обеспечитолжную конфигурацию.
Конфигурирование контейнера
Как мы уже обсуждали в разделе 3.2 "Конфигурирование DI-контейнеров", существуеесколько концептуально разных способа конфигурирования DI-контейнера. На рисунке
12-3 представлен обзор возможных вариантов и то, какие варианты подходят для
Spring.NET.
460
Рисунок 12-3: Spring.NET из трех возможных вариантов, перечисленных в главе 3оддерживает, главным образом, XML-конфигурацию. Технология использования кода ачестве конфигурации поддерживается в минимальной степени, а автоматическаегистрация вообще недоступна. Поэтому данные варианты отмечены серым цветом.
Как и другие, имеющие длительную историю DI-контейнеры, Spring.NET сначалспользовал XML в качестве основного источника конфигурации. Но в отличие от Castle
Windsor и StructureMap контейнер Spring.NET продолжает концентрироваться на XMLозможно, из-за его сильных связей с фреймворком Java Spring.
Технология конфигурирования в коде в Spring.NET
В то время, когда я писал эту главу, Spring.NET не поддерживал технологионфигурирования в коде. Тем не менее, буквально за несколько дней до того, как риступил к финальной части книги, SpringSource выпустил Spring CodeConfig, которыбеспечивает поддержку технологии конфигурирования в коде в Spring.NET.
К несчастью, это случилось слишком поздно, и у меня не оставалось времени на то, чтобереписать эту главу.
В данной главе мы будем рассматривать только XML-конфигурацию.
Работа с .NET типами в XML
Spring.NET использует конфигурацию, основанную на XML. Этот XML может браться иазнообразных источников. В большинстве случаев мы будем загружать XML из файла.
В разделе 12.1.1 "Разрешение объектов" вы уже видели простой пример XML-
конфигурации Spring.NET:
461
<objects xmlns="http://www.springframework.net">
<object id="Sauce"
type="Ploeh.Samples.MenuModel.SauceBearnaise,
?Ploeh.Samples.MenuModel" />
</objects>
Не секрет, что XML сам по себе является многословным языком, но когда дело доходит ддентификации типов, он становится чересчур многословным. Для того чтобы должныбразом идентифицировать .NET тип с помощью строки, мы должны прибегнуть валифициро ванным именам сборки. Даже в случаях, когда мы можем опустить Culture,
Version и PublicKeyToken, тип будет чаще всего идентифицироваться при помощлинной строки, содержащей множество повторяющейся информации. Это наносит вреак читабельности, так и удобству сопровождения.
На читабельность оказывается влияние, поскольку соответствующая часть имени типа
(SauceBearnaise) размещена между пространством имен и именем сборки. Удобствопровождения подвергается влиянию, поскольку становится сложнее переименовыватространства имен и сборки. Всякий раз, когда мы что-либо переименовываем, нариходится редактировать потенциально большой набор определений типов.
Допустим, эти проблемы применяются ко всем фреймворкам, в которых типы должнадаваться в виде XML, но тогда это еще одна причина того, почему все остальные DI-
контейнеры используют для конфигурирования контейнера другие варианты. По эторичине я также чаще всего не рекомендую использовать XML-конфигурацию до тех порока она не будет предписана сценарием применения. Тем не менее, когда дело касается
Spring.NET, XML – самый распространенный вариант конфигурирования.
Для облегчения работы с .NET типами в XML SpringSo urce предоставляет такие средстваак XML-схемы и дополнение для Visual Studio с завершением типов и свойств. Сареймворк также позволяет нам задавать набор псевдонимов типов, являющихс окращенными именами, которые можно использовать для определения типов. Это такжыполняется в XML. Псевдоним типа для класса SauceBearnaise может выглядетледующим образом:
<alias name="SauceBearnaise"
type="Ploeh.Samples.MenuModel.SauceBearnaise,
?Ploeh.Samples.MenuModel" />
Имя может быть любым, но мне кажется, чтобы оно было наиболее понятно и его можныло бы легко запоминать, для имени типа следует использовать его псевдоним.
Указанный псевдоним типа позволяет нам переписать предыдущий пример следующибразом:
<object id="Sauce" type="SauceBearnaise" />
Данная возможность может быть полезна, когда нам нужно несколько раз обратиться дному и тому же типу в одном и том же XML-файле. В любом случае это делаеонфигурацию более читабельной. В оставшейся части данной главы я буду использоватсевдонимы типов. Благодаря такому обозначению элемент object начинает походить но, чем он является: преобразование имени в конкретный тип.
462
В такой простой форме это и есть элемент object. При наличии у объектов зависимостеы должны сообщить Spring.NET, как их необходимо разрешать.
Явное конфигурирова ние зависимосте й
Создать класс SauceBearnaise довольно легко, поскольку он имеет конструктор пмолчанию. Ни одному DI-контейнеру не нужно никакой особой помощи для созданиаких типов. Все меняется, когда конструктор по умолчанию отсутствует. К примеруассмотрим конструктор Mayonnaise:
public Mayonnaise(EggYolk eggYolk, OliveOil oil)
Несмотря на то, что рецепт майонеза слегка упрощен, и EggYolk, и OliveOil – этонкретные классы, имеющие конструкторы по умолчанию. Однако, поскольку класс
Mayonnaise не имеет конструктора по умолчанию, вы должны сообщить Spring.NET, каго разрешить. Один из вариантов – явным образом одновременно интегрировать типы:
<object id="EggYolk" type="EggYolk" />
<object id="OliveOil" type="OliveOil" />
<object id="Mayonnaise" type="Mayonnaise">
<constructor-arg ref="EggYolk" />
<constructor-arg ref="OliveOil" />
</object>
Типы EggYolk и OliveOil конфигурируются таким же образом, как это делалось ранее, нлемент Mayonnaise теперь содержит два элемента constructor-arg. Каждый из этилементов ссылается на именованный объект для того, чтобы определить параметронструктора Mayonnaise. Атрибут ref идентифицирует еще один сконфигурированныбъект по имени, таким образом, EggYolk ссылается на имя EggYolk, а не явно на тип
EggYolk.
В предыдущем примере важен порядок элементов constructor-arg, поскольку вы нбращаетесь явным образом к именам параметров, что также возможно.
Несмотря на то, что мы всегда можем сконфигурировать зависимости таким способом, ме получаем никаких преимуществ, которые предлагает нам механизм автоматическонтеграции. В противоположность другим DI-контейнерам при работе с Spring.NET молжны явным образом просить его использовать механизм автоматической интеграции, се равно этот механизм работает только в конкретных случаях.
Автоматическая инте грация зависимостей
Возможности механизма автоматической интеграции в Spring.NET ограничены, но молжны явным образом переключить его на использование XML-атрибута. Вместо явнонтеграции Mayonnaise указанным ранеее способом вы могли бы сконфигурировать егледующим образом:
<object id="EggYolk" type="EggYolk" />
<object id="OliveOil" type="OliveOil" />
<object id="Mayonnaise" type="Mayonnaise"
autowire="autodetect" />
463
Необязательный атрибут autowire можно использовать для включения для этого объектеханизма автоматической интеграции. В данном примере мы используем значениutodetect, которое сообщает Spring.NET о том, что необходимо точно вычислить, какибразом выполняется поиск соответствующих объектов. Остальные доступные параметрозволяют нам указывать, что поиск соответствующих объектов необходимо выполнято именам, типам или другими средствами.
Если мы планируем использовать автоматическу ю интеграцию для всех объектов, то можем разрешить ее для целого блока сконфигурированных объектов вместо того, чтобриписывать атрибут autowire для каждого элемента object:
<objects xmlns="http://www.springframework.net"
default-autowire="autodetect">
<object id="EggYolk" type="EggYolk" />
<object id="OliveOil" type="OliveOil" />
<object id="Mayonnaise" type="Mayonnaise" />
</objects>
Атрибут default-autowire задает стратегию автоматической интеграции по умолчаниля всех объектов в рамках элемента objects. Это самый простой способ включенивтоматической интеграции сразу для всех объектов, но вы должны иметь ввиду, что этоеханизм работает не всегда.
Поддержка автоматической интеграции в Spring.NET основывается на однозначности.
Spring.NET исследует конструктор класса Mayonnaise и определяет, что ему нужнкземпляры EggYolk и OliveOil. Для выделения зависимости EggYolk он выполняеоиск среди всех остальных сконфигурированных элементов с целью обнаруженилемента, который может удовлетворять данному условию (то же самое он делает и длависимости OliveOil).
В предыдущем примере есть только один объект, удовлетворяющий зависимости EggYolkоэтому неоднозначность отсутствует. Однако если бы данному условию удовлетворялолее одного объекта, то возникло бы исключение. Это справедливо не только длонкретных элементов EggYolk, но также и для унаследованных типов.
Примечание
В Spring.NET автоматическая интеграция работает только в тех ситуациях, когдависимости могут разрешаться однозначно. В этом заключается отличие Spring.NET остальных DI-контейнеров.
Условие индивидуальности, обеспечивающее поддержку автоматической интеграцииает нам преимущество, которое заключается в том, что контракт в рамках контейнервляется понятным и явным. Автоматическая интеграция возможна только при отсутствиеопределенности, связанной с разрешенными типами, поэтому риск неправильногонфигурирования становится намного меньше. С другой стороны, такоонструирование усложняет работу с составными объектами, реализующими одну и ту жбстракцию.
Мы рассмотрели некоторые основные опции конфигурации Spring.NET. Несмотря на тото можно, конечно, написать один большой блок неструктурированного XML кодаучше всего разделить конфигурацию на модули. Spring.NET поддерживает такуозможность, позволяя XML загружаться более чем из одного источника.
464
Загрузка XML
Иногда нам может потребоваться упаковать конфигурацию в повторно используемыруппы, и даже когда повторное использование само по себе не является нашим высшириоритетом, нам может понадобиться некоторого рода структура в случаеобходимости конфигурирования большого и сложного приложения.
В рамках Spring.NET мы можем упаковать конфигурацию в отдельные XML элементыоторые определены в разных ресурсах. В таблице 12-2 перечисляются поддерживаемыипы ресурсов. Их легко использовать, но я вкратце расскажу о каждом из них, чтобы ас осталось это в памяти.
Таблица 12-2: Типы ресурсов XML
Тип ресурса Синтаксис URI Описание
FileSystemResour
file://<filename>
Моникер file:// moniker не обязателен.
XML-
конфигурациадается айлах.
ConfigSectionResrce config://<path to section>
XML-
конфигурациадается онфигурациоом файлриложения.
UriResource Поддерживается стандартный синтаксис .NET URI.
XML-
конфигурациитается иакитандартныротоколов
System.Uri, как
HTTP и HTTPS.
AssemblyResource assembly://<AssemblyName>/<NameSpace>/<ResoceName>
XML-
конфигурациложена борку.
InputStreamResoue Не поддерживается
XML-
конфигурациитается из
System.IO.Strm.
Некоторые типы ресурсов поддерживают синтаксис URI, в котором можно использоватоникер для обозначения типа ресурса в качестве составляющей части адресаакодированного строкой. Если моникер не применяется, то предполагается, что ресурвляется файлом.
465
Использование XML-файлов
До настоящего момента вы видели примеры загрузки XML-конфигурации только идного файла. В примере ниже загрузка всей конфигурации выполняется из файлauce.xm l:
var context = new XmlApplicationContext("sauce.xml");
Поскольку о пути не предоставлено никакой явной информации, предполагается, что файauce.xm l располагается в рабочей папке запущенного процесса. Кроме того, можнспользовать и полный путь.
В этом примере моникер не использовался, поэтому Spring.NET принимает в качествначения по умолчанию FileSystemResource. В противном случае вы могли бы явнспользовать моникер file://, как это продемонстрировано ниже:
var context = new XmlApplicationContext("file://sauce.xml");
Этот пример аналогичен предыду щему примеру. Чаще всего работа с XML в виде файлонтуитивно понятна, поэтому в большинстве случаев имеет смысл обойтись без моникерile:// и вместо этого явно прописывать путь к файлу.
Помимо определения XML-конфигурации в текстовых файлах можно такжнтегрировать ее в стандартный конфигурационный файл приложения.
Использование конфигурационных файлов приложения
Если мы предпочитаем интегрировать конфигурацию Spring.NET с остальной частьонфигурации приложения, то можем использовать стандартный .config файл .NET
приложения.
Поскольку система конфигурации .NET приложения предполагает, что разделользовательской конфигурации должны регистрироваться явным образом, мы такжолжны зарегистрировать разделы конфигурации Spring.NET, в которых собираемсспользовать файл .config. Можно регистрировать разнообразные разделы конфигурациио для того чтобы использовать элемент objects, который вы применяли до настоящегомента, необходимо зарегистрировать используемый по умолчанию обработчик раздела
Spring.NET:
<configSections>
<sectionGroup name="spring">
<section name="objects"
type="Spring.Context.Support.DefaultSectionHandler,
?Spring.Core" />
</sectionGroup>
</configSections>
Это позволяет определять объекты напрямую в файле .config, как вы это делали ранее втономных XML-файлах:
<spring>
<objects xmlns="http://www.springframework.net">
<object id="Sauce" type="SauceBearnaise" />
</objects>
</spring>
466
Используя моникер config://, теперь можно загрузить конфигурацию Spring.NET из файла
.config в экземпляр XmlApplicationContext следующим образом:
var context = new XmlApplicationContext("config://spring/objects");
Теперь экземпляр context может безопасно разрешать имя Sauce.
Во многих отношениях интеграция конфигурации Spring.NET в формат стандартногонфигурационного файла .NET приложения является особым случаем использования
XML-файла, поскольку файлы .config также являются XML-файлами. Но помимо этогы можем рассматривать файлы как особый случай загруженного XML из любого URI.
Загрузка XML из URI
При загрузке XML из файлов мы используем моникер в качестве разграничителя URI
схемы. Spring.NET может загружать XML-файлы не из файлов, а из других URIапример, HTTP, HTTPS и FTP. Это столь же просто, как и приведенный ниже код:
var context = new XmlApplicationContext("http://localhost/sauce.xml");
В этом примере файл sauce.xm l размещен на веб-сервере локального компьютера, нспользовать можно любой публично доступный ресурс.
Во всех предыду щих случаях мы могли изменять конфигурацию, заново не компилируриложение. Это невозможно для следующей опции.
Использование вложенных ресурсов
В .NET мы можем скомпилировать ресурсы в сборки. Если мы внедрим XML-
конфигурацию в сборку, то Spring.NET сможет ее загрузить.
Преимущество вложенных XML-файлов заключается в том, что операторы не могулучайно изменить конфигурационные значения, когда они компилируются в сборку.
Только файлы, имеющие параметры, значения которых, возможно, должнстанавливаться операторами, должны передаваться вне сборки в файловую систему, гдх можно редактировать.
При внедрении файла sauce.xml в сборку можно загрузить его в XmlApplicationContexледующим образом:
var context = new XmlApplicationContext(
"assembly://Ploeh.Samples.Menu.SpringNet/
?Ploeh.Samples.Menu.SpringNet/sauce.xml");
Для того чтобы выполнить загрузку из вложенного ресурса, мы можем сконструироваттроку ресурса из моникера assem bly://, за которым следует название сборкиространство имен и название самого вложенного ресурса. В таблице 12-2 показаребуемый формат, используемый для обращения к вложенному ресурсу.
AssemblyResources позволяет нам загружать конфигурацию Spring.NET не только инешне заданных XML-файлов и URI, но и из вложенных ресурсов. Если мы храним
467
XML-конфигурацию в других местах, то нам может понадобиться такая возможность, катение из потоков.
Использование потоков
До настоящего момента мы рассматривали загрузку XML из статических ресурсовапример, из файлов, конфигурации приложения, веб-ресурсов и вложенных ресурсов.
Иногда нам нужно загружать XML из других источников или, возможно, необходиминамически создавать XML-конфигурацию. Один из способов достижения этой цели –
загружать конфигурацию прямиком из потока.
Поскольку поток не является статическим ресурсом, Spring.NET не поддерживаеозможность идентификации его по строке. У нас нет возможности использовать класс
XmlApplicationContext, и вместо него мы должны прибегнуть к одному иногочисленных контекстных классов Spring.NET:
var resource = new InputStreamResource(stream, "");
var context = new XmlObjectFactory(resource);
InputStreamResource выступает в роли адаптера для объекта System.IO.Stream. Объекtream содержит XML-конфигурацию, которую вы собираетесь загрузить. Мы можеагрузить XML в поток из множества различных источников, включая строку, илосредством построения XML модели с помощью технологии LINQ to XML. Пустатрока, используемая в конструкторе InputStreamResource – это описание. Мы можеередать соответствующее описание, но это необязательно.
Благодары resource (или любой реализации IResource), мы теперь можем создаткземпляр XmlObjectFactory. Этот класс предлагает функционально сть, аналогичную
XmlApplicationContext, но загружает конфигурацию напрямую из экземпляра IResourcместо того, чтобы загружать ее из строк, представляющих собой статические ресурсы.
Интерфейс IResource – это универсальный интерфейс для всех рассматриваемых нами
XML ресурсов. Мы можем предоставить пользовательску ю реализацию IResource спользовать ее тем же самым способом, что и InputStreamResource, или можеарегистрировать ее с помощью собственного моникера. Но рассмотрение этого вариантже выходит за рамки этой главы.
До настоящего момента вы наблюдали, как загружать одну XML-конфигурацию из одногесурса, но для того чтобы достичь модульности, мы чаще всего будем организовыватасти конфигурации больших приложений в разных модулях.
Комбинирование XML ресурсов
Для большого приложения потребуется большое количество кода XML-конфигурации.
Чтобы обеспечить наилучшее сопровождение конфигурации, мы, возможно, захотиазделить конфигурацию на несколько небольших документов. Может быть, мы дажахотим хранить их в отдельных местах: некоторые в XML-файлах, некоторые в файле
.config, а некоторые – в виде вложенных ресурсов.
XmlApplicationContext позволяет комбинировать несколько разных ресурсов, посколькн получает каждую строку ресурса как часть массива параметров.
468
Ниже приведена сигнатура конструктора, который вы использовали на протяжении всегтого времени:
public XmlApplicationContext(params string[] configurationLocations)
Обратите внимание на то, что параметр configurationLocations задан в виде массивараметров. До настоящего момента вы за один раз использовали только один ресурриведенным ниже способом:
var context = new XmlApplicationContext("sauce.xml");
Однако вы можете использовать произвольное количество строк в конструкторе дломбинирования в одном контексте нескольких ресурсов:
var context = new XmlApplicationContext(
"config://spring/objects",
"meat.xml",
"file://course.xml");
В этом примере комбинируются три разных ресурса, каждый из которых определяерагмент единого целого. Одна часть конфигурации задается и загружается ионфигурационного файла приложения, в то время как две остальные части загружаютсз XML-файлов: одна – посредством использования для имен файлов неявногинтаксиса, а другая – с помощью явного использования моникера file://. Вместе эти частормируют полноценную систему конфигурации, которая определяет
XmlApplicationContext.
Еще один способ комбинирования составных ресурсов – посредством элемента import
XML-файла:
<objects xmlns="http://www.springframework.net">
<import resource="config://spring/objects" />
<import resource="meat.xml" />
<import resource="file://course.xml" />
</objects>
Эта конфигурация аналогична предыдущему примеру.
Как вы уже видели, существует несколько различных способов, с помощью которыожно загрузить XML-конфигурацию в Spring.NET. Поскольку мы можем загрузить омбинировать конфигурацию из более чем одного ресурса, это дает нам некоторутепень модульности, которая очень нужна нам для обеспечения сопровождаемости.
Но мы не должны забывать о том, что в целом XML-конфигурация не самый лучшипособ конфигурирования DI-контейнера. Это очень хрупкий и слишком подробныпособ, и к тому же он сложен для разрешения.
Этот раздел познакомил нас с DI-контейнером Spring.NET и продемонстрироваундаментальные принципы: как конфигурировать контейнер с помощью XML последствии использовать его для разрешения объектов. Разрешение объектоыполняется посредством единичного вызова метода GetObject, поэтому вся сложностаключается в конфигурировании контейнера. До настоящего момента мы рассматривалолько самое основное API. Но есть и более продвинутые области, которые мы еще не
469
рассмотрели. Один из самых важных вопросов – как управлять жизненным циклоомпонентов.
470
12.2. Управление жизненным циклом
В главе 8 мы обсуждали процесс управления жизненным циклом, в том числе такие самыниверсальные концептуальные стили существования, как Singleton и T ransient.
Spring.NET поддерживает несколько других стилей существования и позволяет наонфигурировать жизненные циклы всех объектов. Стили существованияродемонстрированные в таблице 12-3 доступны в виде составляющей пакета.
Примечание
В документации к Spring.NET стили существования называются област ями примененибъектов.
Реализации Singleton и Transient в Spring.NET аналогичны основным стиляуществования, описанным в главе 8, поэтому в данной главе я не буду уделять им многнимания.
Таблица 12-3: Стили существования Spring.NET
Название Комментарии
Singleton Стиль существования по умолчанию.
Prototype Название стиля существования Transient, используемое в рамках Spring.NET.
Экземпляр ы контейнером не отслеживаются.
Request Название стиля существования Web Request Context, используемое в рамках
Spring.NET. Корректно только в контексте IApplicationContext.
Session Для одной HTTP-сессии создается один экземпляр. Используйте сторожностью. Корректно только в контексте IApplicationContext.
Application Расширяет определение одного объекта до жизненного цикла веб-приложения.
Корректно только в контексте IApplicationContext.
Примечание
По умолчанию в Spring.NET используется стиль существования Singleton. Этим отличается от большинства других контейнеров. Как уже обсуждалось в главе 8, Singleton
– это самый эффективный, хотя и не всегда безопасный, из всех стилей существованибъектов. В Spring.NET эффективность приоритетнее безопасности.
Три веб стиля (Request, Session и Application) тесно связаны между собооотвествующими IApplicationContexts и не работают с XmlApplicationContext или с
XmlObjectFactory, которые мы рассматривали до настоящего момента. Доступные нанный момент реализации настолько сильно связаны с ASP.NET Web Forms, чтаставить их работать с ASP.NET MVC довольно трудно. Откровенно говоря, эти стиловольно запутаны и не используются, поэтому в этой главе мы не будем иассматривать. Предполагается, что в последующих версиях Spring.NET этот вопроудет модернизирован.
В этой главе я продемонстрирую вам, как конфигурировать области применения объектоа примере стилей Singleton и Transient. Поскольку Spring.NET не поддерживает
471
пользовательские стили существования, эта глава будет краткой. После прочтения этолавы вы сможете использовать стили существования объектов в Spring.NET.
Конфигурирование областей применения
Области применения конфигурируются в качестве составляющей части конфигурацибъектов в XML.
Для того чтобы сконфигурировать объект как Transient, необходимо установить атрибутingleton значение false:
<object id="Sauce" type="SauceBearnaise" singleton="false" />
Изменив значение атрибута на true, мы сконфигурируем объект как Singleton:
<object id="Sauce" type="SauceBearnaise" singleton="true" />
Атрибут singleton является необязательным, поскольку стиль Singleton используется пмолчанию, за исключением тех случаев, когда он неявным образом конфигурируется как
Singleton. Именно это вы и будете делать далее в этой главе.
Предотвращение утечек памяти
Как и любой другой DI-контейнер Spring.NET создает диаграммы объектов. Однако он ныполняет за нас отслеживание созданных объектов. Он может отслеживать созданныбъекты для своих собственных целей, но все это зависит от стиля существованибъекта. Например, для реализации области применения Singleton Spring.NET должеранить ссылку на созданный экземпляр. С другой стороны, область применения Transienе отслеживает объекты, созданные Spring.NET. Как вы уже видели в листингах 8-7 и 8-8кземпляры объектов создаются и возвращаются без внутреннего сопровождения. Все этмеет некоторые достоинства и преимущества.
Поскольку Spring.NET не держится за экземпляры, риск случайных утечек памяти нелик. При использовании таких контейнеров, как Castle Windsor, утечки памятарантированы, если вы забыли вызвать метод Release для всех разрешенных диаграмбъектов. В Spring.NET все не так, поскольку объекты будут автоматически уничтожаться
"сборщиком мусора", как только они будут выходить за рамки области применения.
Недостаток заключается в том, что устраняемые объекты нельзя детерминированнничтожать. Поскольку мы не можем явно высвобождать диаграмму объектов, мы ножем уничтожать любые устранямые объекты. Это означает, что наибольшуначимость приобретает заворачивание устраняемых API в неустраняемые сервисы, чтбсуждалось в разделе 6.2.1.
Короче говоря, Spring.NET ведет себя подобающим образом и позволяет объектаничтожаться "сборщиком мусора", когда они выходят за рамки области применениашего кода. Но при этом необходимо, чтобы ваши собственные классы также вели себодобающим образом. Поскольку в вопросе уничтожения любого сервиса мы не можеолагаться на контейнер или код, выполняющий вызов, мы должны продолжатспользовать устраняемые объекты в рамках единичных методов.
472
Эта глава предоставила удивительно краткий обзор областей применения объектоврименяемых в Spring.NET. По этому вопросу особо и нечего сказать. Единственныовсеместно доступные области применения – это Singleton и Transient, тогда как парстальных областей применения полагается на конкретные реализации
IApplicationContext. При конфигурировании объектов мы можем конфигурироватекоторые из них как Singleton, а некоторые – как Transient, и это справедливо даже, когды конфигурируем составные реализации одной и той же абстракции. Мы ужассматривали то, как работать с составными компонентами, поэтому давайтереключим наше внимание в этом направлении.
473
12.3. Работа с составными компонентами
DI-контейнеры процветают благодаря их индивидуа льности, но их неопределенносторождает ряд трудностей. При использовании Constructor Injection единичныонструктор предпочтительнее перегружаемых конструкторов, поскольку в этом случасно, какой конструктор использовать в ситуации, когда у вас нет выбора. То же самоасается и преобразования абстракций к конкретным типам. Если мы пытаемсреобразовать конкретные составные типы к одной и той же абстракции, это приводит еопределенности.
Несмотря на столь нежелательну ю особенность как неопределенность, нам частриходится работать с составными реализациями единичного интерфейса. Это можероисходить в следующих ситуациях:
? Для разных потребителей должны использоваться разные специфичные типы
? Зависимости являются последовательнос тями
? Используются Decorator'ы
Мы рассмотрим каждую из этих ситуаций и увидим, как Spring.NET поочередправляется с каждой из них. После прочтения раздела вы должны будете уметегистрировать и разрешать компоненты даже тогда, когда в дело вступают составныеализации одной и той же абстракции.
Как вы уже видели в разделе 12.1.2 "Конфигурирование контейнера", по сравнению ольшинством других DI-контейнеров автоматическая интеграция не являетсоведением по умолчанию в Spring.NET. Более разветвленно е управление интеграциетоль же проверенная опция и может использоваться для осуществления выбора междоставными кандидатами.
Выбор из составных кандидатов
В Spring.NET можно использовать механизм автоматической интеграции, но для этогеобходимо, чтобы сервисы были индивидуа льными. Пока у нас есть только одидинственный объект, соответствующий конкретной абстракции, никаких проблем нет, нак только мы введем больше реализаций одного и того же интерфейса, возникаееопределенность.
Для того чтобы побороть эту неопределеннос ть, мы можем использовать явнунтеграцию зависимостей, которую вы уже видели в некоторых примерах.
Конфигурирова ние составных реализаций одной и той же абстракции
До настоящего момента вы конфигурировали именованные объекты, но у объектоеобязательно должны быть имена. Вы можете конфигурировать составные объекты, нрисваивая им имена:
<objects xmlns="http://www.springframework.net">
<object type="SauceBearnaise" />
<object type="Steak" />
</objects>
474
Классы SauceBearnaise и Steak конфигурируются без имен. Поскольку вы явныбразом не задали имена для объектов SauceBearnaise и Steak, Spring.NET присваиваеаждому из них автоматически сгенерированное имя. Если бы вы знали алгоритмоторый Spring.NET использует для генерирования имени, то вы могли бы запрашиватбъекты посредством метода GetObject. Но это может стать некоторого рода хрупкиешением. Вместо этого метода вы можете использовать метод GetObjectsOfTypeоторый также был введен в разделе 12.1.1 "Разрешение объектов". Как только мконфигурируем в Spring.NET тип, мы сможем извлечь его с помощью типов, от которын унаследован.
Чтобы получить экземпляр конкретного класса Steak, например, можно сочетать метод
GetObjectsOfType с парой методов расширения LINQ:
var meat = context.GetObjectsOfType(typeof(Steak))
.Values
.OfType<Steak>()
.FirstOrDefault();
Вы запрашиваете тип Steak в методе GetObjectsOfType. Spring.NET найдет всконфигурированные объекты, соответствующие запрашиваемому типу (независимо оого, именованные они или нет), и вернет их в виде словаря. Ключевыми словами данногловаря являются имена объектов, но поскольку вы не знаете имен, вас интересуют толькначения.
Свойство Values – это экземпляр не generic-интерфейса ICollection, поэтому для тогтобы использовать LINQ, мы должны каким-либо образом привести его к generic-
последовательности. Один и вариантов – использовать метод Cast<T>, но более безопасно
– использовать фильтр OfType<T>. Несмотря на то, что метод Cast мог бы выдатсключение в случае наличия элемента, который нельзя привести к желаемому типуетод OfType фильтрует последовательно сть. Наконец, мы получаем иоследовательности объект. В данном случае мы использовали FirstOrDefault, но болетрогое ограничение вводится с помощью метода расширения Single.
Оба класса SauceBearnaise и Steak реализуют интерфейс IIngredient. Пронфигурировании объектов Spring.NET не накладывает никаких ограничений на токолько объектов данного интерфейса мы можем сконфигурировать, но он все равнозволяет нам разрешать их с помощью метода GetObjectsOfType:
var ingredients = context.GetObjectsOfType(typeof(IIngredient));
При наличии предыдущей конфигурации возвращаемый словарь ingredients будеодержать экземпляры как SauceBearnaise, так и Steak, и для извлечения конкретнынтересующих нас элементов мы можем использовать LINQ-запросы, как делали это редыдущем примере.
Несмотря на то, что мы можем сконфигурировать несколько объектов IIngredient бемен, при необходимости мы можем присвоить им имена:
<objects xmlns="http://www.springframework.net">
<object id="Sauce" type="SauceBearnaise" />
<object id="Meat" type="Steak" />
</objects>
475
Это позволяет нам разрешать каждый из объектов по его имени:
var meat = context.GetObject("Meat");
var sauce = context.GetObject("Sauce");
Это не спасает нас от использования метода GetObjectsOfType, поэтому все предыдущиримеры также применимы.
Принимая как должное то, что мы всегда должны разрешать сервисы в единственном
Composition Root, мы не должны ожидать возникновения неопределенно сти на эторовне. Но для осуществления выбора между составными альтернативами пронфигурировании зависимостей этого потребителя мы можем использовать именованныбъекты.
Конфигурирова ние именованных зависимостей
Интеграция объектов с именованными объектами – центральная возможность Spring.NETесмотря на то, что возможности интеграции в Spring.NET ограничены. Даже если позможности мы должны выбирать автоматическую интеграцию, существуют ситуацииогда нам необходимо обращаться к неопределенно му API. В качестве примерассмотрим приведенный ниже констуктор:
public ThreeCourseMeal(ICourse entree,
ICourse mainCourse, ICourse dessert)
В этом примере у нас есть три идентично типизированных зависимости, каждая иоторых представляет собой сущность, отличную от остальных. В большинстве случаеы не хотим преобразовывать каждую зависимость в отдельный тип. В следующеистинге демонстрируется то, как мы могли бы сконфигурировать объекты ICourse и
ThreeCourseMeal.
Листинг 12-1: Интеграция списка зависимостей
<object id="Entree" type="Rillettes" />
<object id="MainCourse" type="CordonBleu" />
<object id="Dessert" type="MousseAuChocolat" />
<object id="Meal" type="ThreeCourseMeal">
<constructor-arg ref="Entree" />
<constructor-arg ref="MainCourse" />
<constructor-arg ref="Dessert" />
</object>
Три реализации ICourse конфигурируются в виде именованных объектов. Пронфигурировании объекта ThreeCourseMeal мы можем ссылаться на имена, когднтегрируем аргументы конструктора. Элемент constructor-arg также принимаееобязательные атрибуты name или index, которые мы можем использовать, чтобы точнказать, на какой параметр мы ссылаемся. Но в этом примере мы перечисляем их все оответствующем порядке.
Явное преобразование аргументов конструктора в именованные объекты – повсеместнрименяемое решение. Сделать это мы можем, даже если конфигурируем именованныбъекты в одном XML ресурсе, а конструктор – в совершенно другом ресурсе, посколькдинственное средство идентификации, которое связывает именованный объект с
476
аргументом, – это имя. Это всегда выполнимо, но может стать хрупким решением, еслам придется управлять большим количеством имен.
Когда основной причиной, побуждающей нас отказаться от автоматической интеграциивляется неопределенно сть, наилучшее решение – сконструировать API, помогающее назбавиться от этой неопределенно сти. Все это также приводит к лучшей конструкции елом.
В следующем разделе вы увидите, как можно использовать менее неопределенный и болеибкий подход, при котором разрешается использовать в обеде несколько блюд. Теперы должны изучить то, как Spring.NET работает со списками и последовательностями.
Интеграция последовательностей
В разделе 10.3.2 "Разработка пользовательского стиля существования" мы обсуждали, каыполнить рефакторинг явного класса ThreeCourseMeal к более универсальному классу
Meal, который обладает приведенным ниже конструктором:
public Meal(IEnumerable<ICourse> courses)
Вы можете сконфигурировать Spring.NET так, чтобы интегрировать экземпляр ы Meal оответствующими зависимостями ICourse, и я покажу вам, как это сделать. Послассмотрения этого вопроса вы должны будете приобрести хорошее понимание теозможностей, которые доступны в случае необходимости конфигурированикземпляров, имеющих последовательности зависимостей.
Автоматическая инте грация последовательностей
Spring.NET хорошо разбирается в массивах, но не в других типах последовательностей.
Если нам необходим массив конкретных абстракций, и мы собираемся использовать всти сконфигурированные абстракции, то в этом случае применяется автоматическантеграция. К примеру, представьте себе, что класс Meal предлагает следующу ерегрузку конструктора:
public Meal(params ICourse[] courses)
Если мы хотим, чтобы все сконфигурированные объекты ICourse были внедрены в Mealо мы можем предоставить следующу ю конфигурацию:
<object id="Entree" type="Rillettes" />
<object id="MainCourse" type="CordonBleu" />
<object id="Dessert" type="MousseAuChocolat" />
<object id="Meal" type="Meal" autowire="autodetect" />
Объект Meal конфигурируется для автоматической интеграции, и, поскольку Spring.NET
по существу понимает массивы, он находит все объекты, которые реализуют интерфейс
ICourse, и снабжает их конструктором Meal. Автоматически интегрировать массивависимостей довольно легко.
А теперь представьте себе, что перегрузки конструктора, которая принимает в качествараметра массив ICourse, не существует. У вас имеется только конструктор, которыринимает в качестве параметра IEnumerable<ICourse>. Хотя в этом случае
477
автоматическая интеграция и не работает, вы можете воспользоваться преимуществамстроенного понимания массивов, определив простой Decorator, экземпляры котороголжны создаваться с помощью массива. Приведенный ниже листинг демонстрируеeneric-реализацию. Не забывайте о том, что принятие IEnumerable<ICourse> в качествараметра конструктора указывает на статически типизированный запрос данноонкретной зависимости. Все, что вам необходимо сделать, является столь же простымак и преобразование этого запроса в запрос массива того же типа.
Листинг 12-2: Преобразование запросов последовательностей в запросы массивов
1. public class ArrayEnumerable<T> : IEnumerable<T>
2. {
3. private readonly IEnumerable<T> sequence;
4. public ArrayEnumerable(params T[] items)
5. {
6. if (items == null)
7. {
8. throw new ArgumentNullException("items");
9. }
10. this.sequence = items;
11. }
12. public IEnumerator<T> GetEnumerator()
13. {
14. return this.sequence.GetEnumerator();
15. }
16. }
Строка 1: Определение последовательности
Строка 4: Необходим массив
ArrayEnumerable<T> реализует IEnumerable<T>, таким образом, он подходит для любогонструктора, которому необходима такая последовательность. С другой стороны, длего нужен массив такого же типа. Поскольку Spring.NET в сущности знает, как работат массивами, ему может подойти закрытый ArrayEnumerable, снабженный всембъектами, которые совпадают с типом элемента T.
Для того чтобы соответствующим образом интегрировать класс Meal со всеми объектами
ICourse, вы можете сконфигурировать контекст следующим образом:
<object id="Entree" type="Rillettes" />
<object id="MainCourse" type="CordonBleu" />
<object id="Dessert" type="MousseAuChocolat" />
<object id="Courses"
type="ArrayEnumerable<ICourse>"
autowire="autodetect" />
<object id="Meal" type="Meal" autowire="autodetect" />
Вы задаете Courses в виде ArrayEnumerable<ICourse> с включенной возможностьвтоматической интеграции. Поскольку только для его конструктора необходим массив
ICourse'ов, Spring.NET автоматически интегрирует его со всеми реализациями ICourseоторые только может найти: Rillettes, CordonBleu и MousseAuChocolat.
Для класса Meal нужен IEnumerable<ICourse>, и, кроме того, он конфигурируется такибразом, чтобы иметь возможность автоматически интегрироваться. Когда вы отправите
Spring.NET запрос на разрешение объекта Meal, он будет искать сконфигурированный
478
объект, который реализует IEnumerable<ICourse>, и найдет объект Courses. Все трбъекта ICourse будут внедрены в объект Meal посредством объекта Courses.
Класс ArrayEnumerable<T> – это небольшая забава, которая заполняет маленький пробе Spring.NET. Это чисто инфраструктурный компонент, который можно упаковать овторно используемую библиотеку.
Spring.NET автоматически обрабатывает массивы и, благодаря небольшой помощи
ArrayEnumerable<T>, также обрабатывает и другие запросы последовательно стей путеазрешения их в последовательности объектов, реализующих запрашиваемый тип.
Единственное, что вам нужно сделать, – сконфигурировать ArrayEnumerablоответствующего типа элемента. Только в случае, когда вам необходимо явно отобратесколько компонентов из большого набора, вам нужно выполнить больше действий. Этозможно благодаря более явной конфигурации.
Отбор нескольких объектов из большого набора
Когда мы используем возможность Spring.NET разрешать массивы все объектнедряются в потребителей. Чаще всего это корректное поведение. Однако, как показана рисунке 12-4, могут возникать ситуации, когда нам необходимо отобрать несколькомпонентов из большого набора всех зарегистрированных компонентов.
Рисунок 12-4: В ситуации, продемонстрированной слева, мы хотим явным образотобрать определенные зависимости из большого списка всех сконфигурированныбъектов. Это отличается от ситуации, приведенной справа, когда мы отбираем все беазбора.
Когда мы ранее позволяли Spring.NET автоматически интегрировать всконфигурированные объекты, это соответствовало ситуации, продемонстрированной равой части рисунка 12-4. Если нам нужно сконфигурировать экземпляр так, как это
479
показано в левой части рисунка, мы должны явным образом определить, какие объектеобходимо использовать.
Это легко сделать с помощью именованных объектов, поскольку это более или менедиоматичный способ конфигурирования Spring.NET, который позволяет использоваттдельный XML элемент list для обращения к конкретному сценарию. В следующеистинге продемонстрирован соответствующий пример.
Листинг 12-3: Внедрение именованных объектов в последовательнос ть
1. <object id="Entree" type="Rillettes" />
2. <object id="Entree1" type="LobsterBisque" />
3. <object id="MainCourse" type="CordonBleu" />
4. <object id="Dessert" type="MousseAuChocolat" />
5. <object id="Meal" type="Meal">
6. <constructor-arg>
7. <list element-type="ICourse">
8. <ref object="Entree" />
9. <ref object="MainCourse" />
10. <ref object="Dessert" />
11. </list>
12. </constructor-arg>
13. </object>
Строка 7: Указывает на список
Строка 8-10: Именованные объекты
Элемент list можно использовать для указания на то, что следующие элементы являютслементами списка. Когда Spring.NET интегрирует список, он создает массив, тиоторого задан атрибутом element-type. Элемент list может содержать множествазличных дочерних элементов. Элемент ref используется для обращения к другименованным объектам.
При разрешении объекта Meal вы получите экземпляр Meal с Rillettes, CordonBleu и
MousseAuChocolat в качестве содержащихся в нем блюд, при этом LobsterBisque нспользуется.
Еще раз вы видите, что Spring.NET по существу работает с массивами. Несмотря нтсутствие поддержки других типов последовательностей вы можете обойти этграничение посредством заворачивания последовательнос тей в класс наподобие
ArrayEnumerable<T>.
Потребители, которые полагаются на последовательности зависимостей, могут выступат роли самого интуитивного использования составных экземпляров одной и той жбстракции. Но до того как мы перестанем заниматься этим вопросом, нам необходимассмотреть еще один случай, когда в дело вступают составные экземпляры.
Интеграция Decorator'ов
В разделе 9.1.2 "Паттерны и принципы механизма перехвата" мы обсуждали то, насколькаттерн проектирования Decorator полезен при реализации сквозных сущностей. Ппределению Decorator'ы представляют собой составные типы одной и той же абстракции.
У нас есть, по крайней мере, две реализации абстракции: сам Decorator и вложенный в
480
него тип. Если бы мы помещали Decorator'ы в стек, то у нас было бы еще большеализаций.
Это еще один пример составных объектов, которые реализуют одну и ту же абстракцию.
В отличие от предыдущих разделов эти объекты не являются концептуальнавносильными, а зависят друг от друга. Я продемонстрирую вам два разных способонфигурирования Spring.NET, используемых для работы с этим паттерном.
С оздание обертки с помощью именованных объектов
На протяжении всей этой главы вы видели множество примеров того, как обращаться менованным объектам как к аргументам конструктора. Кроме того, вы можетспользовать этот идиоматичный подход для конфигурирования Decorator'ов.
Класс Breading – это Decorator для IIngredient. Для получения экземпляра, которыеобходимо в него вложить, он использует Constructor Injection:
public Breading(IIngredient ingredient)
Для того чтобы получить Cotoletta, вам хотелось бы вложить VealCutlet (еще один
IIngredient) в класс Breading. Поскольку вы уже знаете, как соединять именованныбъекты с аргументами конструктора, вам будет привычно выполнять действияналогичные следующим:
<object id="Breading" type="Breading">
<constructor-arg ref="Cutlet" />
</object>
<object id="Cutlet" type="VealCutlet" />
Строка 2: Ссылка на именованный объект
На данный момент этот подход должен быть вам знаком. Для интеграции объекта
Breading с объектом Cutlet вы используете ссылку на именованный объект. Поскольку
Spring.NET явным образом не работает с преобразованиями абстракций в конкретныипы, каждый из этих двух элементов является таким же самым объектом, как стальные элементы object. Т о, что они оба реализуют интерфейс IIngredient, никак нлияет на способ их конфигурирования.
При разрешении имени Breading вы получаете экземпляр Breading, в который вложен
VealCutlet.
Это общепринятый способ создания обертки для компонента, но в тех случаях, когда вае интересует вложенный экземпляр, вы можете воспользоваться более неявныпособом.
С оздание обертки с помощью вложенных объектов
Если вам никогда не потребуется разрешать вложенные компоненты напрямую, вожете воспользоваться более неявным способом создания их обертки. Представьте себето вам никогда не нужно будет разрешать VealCutlet непосредственно как IIngredient.
Когда вам нужен IIngredient, вам всегда нужен Cotoletta.
481
В таких случаях нет нужды явным образом конфигурировать VealCutlet в видезависимого объекта. Вместо этого вы можете воспользоваться преимуществаминтаксиса вложенных объектов Spring.NET:
<object id="Breading" type="Breading">
<constructor-arg>
<object type="VealCutlet" />
</constructor-arg>
</object>
Spring.NET позволяет вам задавать объекты в виде вложенных элементов. Вместо тогтобы ссылаться на именованный объект, элемент constructor-arg может содержатонфигурации всего объекта. Поскольку предполагается, что кроме как из конфигурацисылаться на объект VealCutlet откуда-то еще вам не нужно будет, вы можетредоставить неименованный элемент object с корректным атрибутом type. Будучложенным в элемент constructor-arg, тип VealCutlet будет разрешаться в видервого аргумента конструктора класса Breading.
Существует несколько доступных вариантов конфигурирования Decorator'ов. В отличит Castle Windsor Spring.NET явно не понимает Decorator'ы, что может показаться слегкдивительным, поскольку, как и Windsor, он предполагает максимальную поддержкаттерна Decorator: механизм перехвата.
Создание перехватчиков
В разделе 9.3.3 "Пример: перехват с помощью Windsor" вы видели пример того, каобавить в WCF-приложение обработчик ошибок и Circuit Breaker с помощьозможности динамического перехвата, предлагаемой Castle Windsor. Чтобродемонстрировать возможности перехвата в Spring.NET и сравнить их с Castle Windso Unity, я разберу точно такой же пример, но реализованный с помощью Spring.NET.
Как показано на рисунке 12-5, добавление аспекта в Spring.NET – довольно простороцесс.
Рисунок 12-5: Простой процесс добавления аспекта в Spring.NET.
Основная часть работы заключается в разработке самого перехватчика, но после созданиерехватчика необходимо добавить его в контейнер. Это, как и все другое, делается в
XML конфигурации.
Однако мы не можем конфигурировать перехватчики, пока не реализуем их. Поэтомервый шаг – написать некоторый код для обработчика ошибок и перехватчиков Circuit
Breaker. После создания обработчика ошибок и перехватчика Circuit Breaker можем с помощью них сконфигурировать контейнер.
Реализация перехватчика обработчика исключений
Реализация перехватчика в Spring.NET требует от нас реализации интерфейса
IMethodInterceptor. В следующем листинге демонстрируется, как реализовать
482
стратегию обработки исключений из главы 9 "Механизм перехвата". Эта конкретнаеализация, приведенная для Spring.NET, соответствует листингу 9-8, приведенному для
Castle Windsor и листингу 14-13, приведенному для Unity.
Листинг 12-4: Реализация обработчика исключений IMethodInterceptor
1. public class ErrorHandlingInterceptor : IMethodInterceptor
2. {
3. public object Invoke(IMethodInvocation invocation)
4. {
5. try
6. {
7. return invocation.Proceed();
8. }
9. catch (CommunicationException e)
10. {
11. this.AlertUser(e.Message);
12. }
13. catch (InvalidOperationException e)
14. {
15. this.AlertUser(e.Message);
16. }
17. return null;
18. }
19. private void AlertUser(string message)
20. {
21. var sb = new StringBuilder();
22. sb.AppendLine("An error occurred.");
23. sb.AppendLine("Your work is likely lost.");
24. sb.AppendLine("Please try again later.");
25. sb.AppendLine();
26. sb.AppendLine(message);
27. MessageBox.Show(sb.ToString(), "Error",
28. MessageBoxButton.OK, MessageBoxImage.Error);
29. }
30. }
Строка 3: Реализация логики перехвата
Строка 5-8: Попытка вернуть результат
Строка 9-16: Обработка исключений
Класс ErrorHandlingInterceptor реализует интерфейс IMethodInterceptor, которыпределяет только единственный метод Invoke. Именно здесь вы должны определитогику перехвата. Единственный аргумент метода – экземпляр интерфейса
IMethodInvocation. Благодаря его методу Proceed вы пытаетесь вызвать вложенныетод и вернуть результат. Однако, поскольку цель перехватчика заключается в обработкзвестных исключений, вызов метода Proceed вставляется в блок try.
Если метод Proceed (или лучше вложенный метод, который вызывает Proceed) выдаедно из известных исключений, перехватчик ловит его и предупреждает пользователя ошибке. В данном примере совокупность известных исключений жестко закодирована амом перехватчике, но более общепринятая реализация могла бы вместо такоговедения подавить исключения или выдать их повторно в соответствии с внедреннопецификацией.
483
Поскольку метод Invoke должен возвращать объект, он возвращает null, когда выдаетссключение и завершает свое выполнение. Это корректное значение для тех случаевогда вложенный метод возвращает значение типа void, но когда метод возвращаееальные значения, это может стать проблемой, поскольку все это легко может привести к
NullReferenceExceptions. Т ем не менее, мы можем создать другой перехватчик, которыстанавливает соответствующие значения по умолчанию для различных типоозвращаемого результата. Это было бы более корректно, нежели попытка предугадаторректное значение по умолчанию в рамках ErrorHandlingInterceptor, являющегос ниверсальным перехватчиком, который можно использовать для перехвата любогнтерфейса. Кроме того, это соответствовало бы принципу единичной ответственности.
ErrorHandlingInterceptor заботится об обработке конкретных исключений, полученныля вложенного компонента. Данный компонент сам по себе может являться другиерехватчиком в виде Circuit Breaker.
Реализация Circuit Breaker перехватчика
Circuit Breaker перехватчик слегка более сложен, поскольку для него нужнависимость ICircuitBreaker, но, как показывает следующий листинг, мы обращаемся ему путем применения стандартного паттерна Constructor Injection. Когда дело доходио компоновки класса, Spring.NET поступает с ним так же, как и с любым другибъектом, поэтому, пока он может разрешать зависимость, все идет хорошо.
Листинг 12-5: Реализация Circuit Breaker перехватчика IMethodInterceptor
1. public class CircuitBreakerInterceptor :
2. IMethodInterceptor
3. {
4. private readonly ICircuitBreaker breaker;
5. public CircuitBreakerInterceptor(
6. ICircuitBreaker breaker)
7. {
8. if (breaker == null)
9. {
10. throw new ArgumentNullException("breaker");
11. }
12. this.breaker = breaker;
13. }
14. public object Invoke(IMethodInvocation invocation)
15. {
16. this.breaker.Guard();
17. try
18. {
19. var result = invocation.Proceed();
20. this.breaker.Succeed();
21. return result;
22. }
23. catch (Exception e)
24. {
25. this.breaker.Trip(e);
26. throw;
27. }
28. }
29. }
Строка 1-2: Реализация IMethodInterceptor
484
Строка 4-13: Constructor Injection
Строка 19: Получения результата вложенного метода
Строка 20: Запись успешного результата
Строка 25: Отключение прерывателя
CircuitBreakerInterceptor необходимо делегировать его реальную реализацикземпляру ICircuitBreaker. Поскольку Spring.NET, как и любой другой объект, можевтоматически интегрировать перехватчик, для внедрения ICircuitBreaker вы можетоспользоваться стандартным паттерном Constructor Injection.
В методе Invoke вам необходимо реализовать идиоматическое выражение Guard-
Succeed/Trip, которое вы уже видели в листингах 9-4 и 9-9. Как и в листинге 12-4, вызываете вложенный метод путем вызова метода Proceed, но вместо того, чтобы сразе вернуть значение, вам необходимо присвоить его локальной переменной result, чтобы могли идентифицировать успешный результат для Circuit Breaker. Не забывайтето это может привести к закрытию другого открытого прерывателя.
Любое исключение, которое может выдаваться вложенным методом, выдается зановеизменнным с помощью метода Proceed, поэтому вы можете поймать его и отключитрерыватель, как вы обычно и делаете.
После того как и ErrorHandlingInterceptor, и CircuitBreakerInterceptoеализованы, приходит время конфигурирования контейнера таким образом, чтобы ооздавал обертку для объекта IProductManagementAgent.
Конфигурирова ние механизма перехвата
Все, что нам фактически необходимо сделать, – перехватить объект
IProductManagementAgent вместе с Circuit Breaker и обработчиком ошибок такибразом, чтобы в тех случаях, когда при взаимодействии с веб-сервисом возникаесключение, открывался Circuit Breaker и обрабатывалось исключение, что давало бриложению возможность восстановиться, как только веб-сервис или сеть восстановявою работу.
Конфигурировать механизм перехвата в Spring.NET довольно легко. Все, что вам нужнделать, – выполнить конфигурацию самих перехватчиков:
<objects xmlns="http://www.springframework.net"
default-autowire="constructor">
<object id="ErrorHandlingInterceptor"
type="ErrorHandlingInterceptor" />
<object id="CircuitBreakerInterceptor"
type="CircuitBreakerInterceptor" />
</objects>
Не обладая особой фантазией, я присвоил объектам id, совпадающие с их type. Обратитнимание на то, что Constructor Injection, основанный на автоматической интеграцииключен по умолчанию. В то время как ErrorHandlingInterceptor обладаеонструктором по умолчанию, CircuitBreakerInterceptor для запрашивания
485
ICircuitBreaker использует Constructor Injection. Механизм автоматической интеграциаботает как для CircuitBreakerInterceptor, так и для ErrorHandlingInterceptor, акже для большинства других объектов конфигурации, поэтому включение его пмолчанию является самым простым способом.
После того как вы разместили перехватчики, осталось только сконфигурировать объект
IProductManagementAgent с необходимыми перехватчиками. На рисунке 12-6
продемонстрирована нужная вам конфигурация.
Рисунок 12-6: IProductManagementAgent должен быть вложен в Circuit Breakeерехватчик таким образом, чтобы при выдаче агентом исключения цепь на некотороремя открывалась Поскольку Circuit Breaker лишь регистрирует исключения, а нбрабатывает их, за это несет отвественность перехватчик обработчика ошибок, которыолжен, по крайней мере, уметь обрабатывать исключения, возникающие в обоих агентах также в Circuit Breaker.
Как показывает следующий листинг, делается это при помощи синтаксиса конфигурации
XML, а также специального пространства имен и классов, которые Spring.NET
предоставляет для этих целей. Основная концепция конфигурирования механизмерехвата заключается в отделение того, что делать, от того, где это делать. Мы должнредоставить ответ на оба эти вопроса, но отвечаем на них по отдельности, а затевязываем ответы вместе.
Листинг 12-6: Конфигурирование перехватчиков
1. <object type="WcfProductManagementAgent" />
2. <object id="AgentPointCut"
3. type="RegularExpressionMethodPointcut">
4. <property name="patterns">
5. <list>
6. <value>.*WcfProductManagementAgent.*</value>
7. </list>
8. </property>
9. </object>
10. <aop:config>
11. <aop:advisor pointcut-ref="AgentPointCut"
12. advice-ref="ErrorHandlingInterceptor"
13. order="1" />
14. <aop:advisor pointcut-ref="AgentPointCut"
15. advice-ref="CircuitBreakerInterceptor"
16. order="2" />
17. </aop:config>
486
Строка 1: Объект для перехвата
Строка 2-9: Указание того, в каком месте выполнять перехват
Строка 10-17: Привязка перехватчиков к спецификации
В предыдущем коде вы регистрировали перехватчики, но помимо этого вам необходимарегистрировать классы, которые нужно будет перехватить. В этом примере один таколасс, но при желании вы можете перехватить множество различных классов с помощьдного и того же набора перехватчиков.
Чтобы указать, какие классы или методы нужно перехватить, вы должны задать таазываемое Pointcut, придуманное название для правила, определяющего, что нужнерехватить. Если вы вспомните первоначальное введение в механизм перехватариведенное в главе 9, то поймете, что Pointcut соответствует
IModelInterceptorsSelector, используемому в Castle Windsor и реализованно му истинге 9-10. Как и Castle Windsor, Spring.NET позволяет писать императивный кодпределяющий Pointcut, но помимо этого он предоставляет некоторые декларативные
Pointcut'ы. Одним из таких статических Pointcut'ов является
RegularExpressionMethodPointcut, который можно использовать для заданиоответствующего правила с регулярным выражением. При каждом вызове метода оудет пытаться сопоставить полное имя метода с регулярным выражением. В этоонкретном случае вы планируете сопоставить только члены класса
WcfProductManagementAgent.
Наконец, вам нужно связать Pointcut с перехватчиками, которые вы уже зарегистрироваланее. Делается это с помощью последовательности элементов advisor, которыбъявляют перехватчики и порядок их компоновки. Заметьте, что поскольку вы сначалказываете ErrorHandlingInterceptor, он становится крайним перехватчикомерехватывающим CircuitBreakerInterceptor.
Последнее, что вам нужно сделать для того, чтобы сконфигурировать приложение, отором используется сильное управление внешним взаимодействием, – убедиться, чтсе зависимости могут удовлетворять требуемым условиям. Поскольку для
CircuitBreakerInterceptor нужен ICircuitBreaker, вы также должнконфигурировать и этот объект:
<object type="CircuitBreaker" autowire="no">
<constructor-arg value="00:01:00" />
</object>
Для конструктора CircuitBreaker нужна задержка в виде экземпляра TimeSpan, и вудете задавать это элементарное значение как вложенное. Для этого вы должнтключить используемые по умолчанию настройки автоматического интегрирования ем, чтобы явно установить задержку, равной одной минуте.
Для большей эффективности важно наличие только одного экземпляра Circuit Breaker
(по крайней мере, для одного внешнего ресурса), но, поскольку по умолчаниспользуется область применения Singleton, вам не нужно явным образом выражатанное требование.
487
Этот пример продемонстрировал, как реализовать механизм динамического перехвата в
Spring.NET. По-моему, я получил сложность, сравнимую с поддержко й контейнерами
Castle Windsor и Unity механизма перехвата. Будучи не таким уже незначительнымолученное преимущество становится довольно значимым.
Механизм перехвата – динамическая реализация паттерна Decorator, а сам паттерн
Decorator является сложным применением составных объектов одного и того же типа.
Spring.NET дает нам возможность работать с составными компонентами несколькимазличными способами. Мы можем конфигурировать их в виде альтернатив друг другу, иде пиров, которые разрешаются в виде последовательно стей, или в виде иерархических
Decorator'ов, или даже в виде перехватчиков. Когда дело дойдет до массивов, Spring.NET
поймет, что делать, но при этом мы часто можем преобразовывать в массивы и другиипы последовательност ей, используя такой адаптер, как класс ArrayEnumerable<T>.
Кроме того, все это позволяет нам явным образом задавать, как компонуются сервисы лучае, если нам необходим более явный контроль.
Помимо этого такие ситуации могут возникать, когда нам приходится иметь дело с APIтклоняющимися от Constructor Injection. До настоящего момента вы наблюдали за темак конфигурировать объекты, включая то, как определять области применения, и кааботать с составными компонентами. Но до этого момента мы позволяли контейнеродключать зависимости, явным образом предполагая, что все компоненты используют
Constructor Injection. Поскольку это не всегда происходит именно так, в следующеазделе мы сделаем краткий обзор того, как работать с классами, экземпляры которыолжны создаваться особым образом.
488
12.4. Конфигурирование сложных API
До настоящего момента мы рассматривали то, как можно конфигурировать компонентыспользующие Constructor Injection. Одним из главных преимуществ Constructor Injectioвляется то, что DI-контейнеры, например, Spring.NET, могут с легкостью понимать, каомпоновать и создавать все классы диаграммы зависимостей.
Все становится менее понятным, когда API не столь хорошо функционируют. В этоазделе вы увидите, как работать с простейшими аргументами конструкторататическими фабриками и Property Injection. Все это требует особого внимания. Давайтачнем с рассмотрения классов, которые принимают в качестве параметров простейшиипы, например, строки и целые числа.
Конфигурирование простейших зависимостей
Пока мы внедряем абстракции в потребителей, все в порядке. Но этот процессложняется, если конструктор зависит от простейшего типа, например, строковогоислового или перечисляемого. Наиболее часто это случается в реализациях доступа анным, которые принимают в качестве параметра конструктора строку соединения. Но о же время это является более общей проблемой, касающейся всех строковых и числовыипов.
В сущности, регистрация строкового или числового типа в качестве компонентонтейнера не имеет особого смысла, а в Spring.NET невозможно зарегистрироватначение простейшего типа в качестве объекта.
Рассмотрим в качестве примера приведенный ниже конструктор:
public ChiliConCarne(Spiciness spiciness)
В этом примере Spiciness имеет перечисляемый тип:
public enum Spiciness
{
Mild = 0,
Medium,
Hot
}
Предупреждение
Согласно эмпирическому правилу перечисления являются code smell'ами и их нужнреобразовывать в полиморфные классы (имеющие разное состояние). Тем не менее, длтого примера они вполне нам подходят.
Необходимо явным образом передать значение параметра конструктора spiciness в видоставляющей конфигурации объекта ChiliConCarne:
1. <object id="Course" type="ChiliConCarne">
2. <constructor-arg value="Hot" />
3. </object>
489
Строка 2: Передача значения
Spring.NET снабжен конвертерами нескольких типов, которые конвертируют текстовылементы в экземпляры необходимых типов. Один из встроенных конвертерореобразует текст в элемент перечисляемого типа, что позволяет нам сделать текст "Hot"
значением элемента constructor-arg. Spring.NET смотрит на тип параметронструктора класса ChiliConCarne, определяет, что это параметр перечисляемого типа спользует конвертер соответствующего типа для преобразования текста "Hot" в значение
Spiciness.Hot.
Эта возможность Spring.NET предназначена для тех ситуаций, в которых нам необходимередавать простейшие значения в виде аргументов. В примере аргумент ChiliConCarnыл передан в конструктор, но иногда встречаются ситуации, когда класс не имееткрытого конструктора.
Конфигурирование статических фабрик
Экземпляры некоторых классов нельзя создать с помощью открытого конструктора. В
этом случае для создания экземпляро в типа мы должны использовать некоторого родабрику. Это всегда проблематично для DI-контейнеров, поскольку по умолчанию иужны открытые конструкторы.
Рассмотрим приведенный ниже пример конструктора открытого класса JunkFood:
internal JunkFood(string name)
Даже если класс JunkFood является открытым, конструктор расположен внутри него.
Очевидно, экземпляры JunkFood должны создаваться с помощью статического класса
JunkFoodFactory:
public static class JunkFoodFactory
{
public static IMeal Create(string name)
{
return new JunkFood(name);
}
}
С точки зрения Spring.NET, это проблемное API, поскольку в нем отсутствуют точныраженные и заданные соглашения касательно статических фабрик. Тут требуетсомощь – и мы можем предоставить ее при конфигурировании объекта:
<object id="Meal"
type="JunkFoodFactory"
factory-method="Create">
<constructor-arg value="chicken meal" />
</object>
Как и всегда, конфигурация объекта выражается в элементе object, но вместо заданиипа самого объекта, вы задаете тип фабрики. Помимо этого вы должны определить, чтменем factory-method будет Create. Заметьте, что хотя метод Create по существу и нвляется конструктором, вы все равно используете элемент constructor-arg для тоготобы задать значение аргумента name метода Create.
490
Хотя атрибут type задается как тип фабрики, а не тип результата, Spring.NET достаточнмен, чтобы понять, что выходной тип метода Create – это JunkFood. Это означает, чты можете не использовать атрибут id и создать неименованный объект, как вы этелали в разделе 12.3.1 "Выбор из составных кандидато в", и вы все равно сможетазрешить объект JunkFood с помощью метода GetObjectsOfType.
Последним рассматриваемым нами отклонением от паттерна Constructor Injection является
Property Injection.
Property Injection – это менее определенная форма механизма внедрения зависимостейоскольку компилятор не принудает нас задавать значение свойства, доступного длаписи. Все-таки, Spring.NET понимает Property Injection и работает с ним интуитивныбразом. Если мы разрешим автоматическое интегрирование, то Property Injection будеаботать, но, помимо этого, он будет работать и посредством прямого интегрирования.
Рассмотрим класс CaesarSalad:
public class CaesarSalad : ICourse
{
public IIngredient Extra { get; set; }
}
По всеобщему заблуждению в состав салата "Цезарь" входит курица, но это не правда. Пуществу "Цезарь" является салатом, но, поскольку с курицей он вкуснее, то ее частредлагают использовать в нем в качестве дополнительного ингредиента. Класс
CaesarSalad моделирует такую возможность посредством доступного для записвойства под названием Extra.
Если вы конфигурируете только класс CaesarSalad, явно не обращаясь к свойству Extraо этому свойству не будет присвоено значение. Вы все равно можете разрешаткземпляр, но свойство Extra будет иметь значение по умолчанию, которое ему присвоионструктор (если только это имеет место).
Явное интегрирование свойств
Существует несколько способов, с помощью которых можно сконфигурировать
CaesarSalad таким образом, чтобы свойство Extra заполнялос ь соответствующибразом. Один из таких способов – явным образом интегрировать свойство менованным объектом:
<object id="Course" type="CaesarSalad">
<property name="Extra" ref="Chicken" />
</object>
<object id="Chicken" type="Chicken" />
Элемент property указывает на то, что именем свойства является "Extra", и что в качествго значения необходимо использовать объект Chicken. Вместо того чтобы использоватсылку на именованный объект, вы можете использовать вложенный объект:
<object id="Course" type="CaesarSalad">
<property name="Extra">
<object type="Chicken" />
</property>
</object>
491
Вы всегда можете явным образом интегрировать свойства с элементом property, носкольку свойство идентифицируется по имени, это довольно хрупкий подход. Если возднее переименуете свойство, большинство инструментов рефакторинга не смогудентифицировать и изменять значение атрибута name в различных XML-файлах. Этожет привести к ошибкам во время выполнения.
Наилучшее решение – автоматически интегрировать объекты.
Автоматическое инте грирование свойств
Как вы помните из раздела 12.1.2 "Конфигурирование контейнера", вы должны явназрешить автоматическое интегрирование в Spring.NET, но как только вы это сделаетеаработает Property Injection. Если зависимость не удовлетворяет условиям, то свойствгнорируется:
<objects xmlns="http://www.springframework.net">
<object id="Course" type="CaesarSalad"
autowire="autodetect" />
</objects>
В этом примере объект Course – единственный объект, сконфигурированный длонтейнера. Несмотря на то, что он сконфигурирован с возможностью автоматическонтеграции, свойству Extra никогда не будет присвоено значение, поскольку отсутствуеоступный объект IIngredient. Выдается исключение, а свойство просто игнорируется.
Все меняется, как только объект IIngredient становится доступным:
<object id="Course" type="CaesarSalad"
autowire="autodetect" />
<object type="Chicken" />
Теперь при разрешении объекта Course вы будете получать экземпляр CaesarSalad свойством Extra, имеющим значение Chicken.
Использование автоматического интегрирования – более ясный способ, поскольку можем переименовывать свойства, не опасаясь, что конфигурация Spring.NET будеазрушена во время выполнения.
Вы видели, как использовать Spring.NET для работы с более сложными API разработки. В
общем случае вы всегда можете явным образом конфигурировать интегрирование омощью XML-конфигурации, но вы также видели и то, что паттерн Property Injectioожно сконфигурировать таким образом, что он будет поддерживать возможноствтоматической интеграции.
492
12.5. Резюме
Среди рассматриваемых в этой главе DI-контейнеров Spring.NET уникален тем, что этдинственный контейнер, реализованный как порт из Java. И это более очевидный фактем то, что Spring.NET в большой степени полагается на XML-конфигурацию.
Большинство из старейших DI-контейнеров в начале своего пути были сильнфокусированы на XML. Но если другие DI-контейнеры продвинулись вперед, Spring.NET
не сделал ни одного шага в эту сторону.
Несмотря на то, что в последующих версиях Spring.NET возможно в большей степенудут поддерживаться технологии использования кода в качестве конфигурации и дажонфигурация на основании соглашений, применение Spring.NET на сегоднящний денесет за собой большое количество XML-кода.
Возможно, самым слабым местом Spring.NET является ограниченная поддержкеханизма управления жизненным циклом. С одной стороны, Spring.NET, как и
StructureMap, явным образом не поддерживает высвобождение диаграммы объектов (этожно рассматривать как отсутствие каких-либо возможностей). С другой стороны,
Spring.NET не поддерживает пользовательские области применения объектов.
Хотя возможности механизма управления жизненными циклами не столь примечательны,
Spring.NET – один из нескольких DI-контейнеров, предлагающих встроенный механизерехвата.
Spring.NET все еще базируется на .NET 1.1, что, возможно, для некоторых является реимуществом. Мы получаем полноценный пакет документации и возможность покупкоммерческого сопровождения. Поэтому, несмотря на то, что вцелом Spring.NET можеоказаться старомодным, он все равно является одним из профессиональных пакетов.
Мы можем рассматривать Spring.NET как устаревший, но проверенный фреймворк. В
противоположность этому в следующей главе рассматривается один из самыовременных DI-контейнеров: Autofac.
493
13. Autofac
Меню:
? Знакомство с Autofac
? Управление жизненным циклом
? Работа с составными компонентами
? Конфигурирование сложных API
В предыдущих главах вы наблюдали за тем, как применять к конкретным DI-контейнераринципы и паттерны, описанные в частях 1-3. В этой главе мы то же самое будем делатля DI-контейнера Autofac.
Autofac – это пример так называемых "DI-контейнеров второго поколения".
Примечание
Примерами DI-контейнеров второго поколения являются DI-контейнеры Ninject и Unity.
В основе DI-контейнеров второго поколения лежит .NET 3.5, поэтому их структуры чащсего базируются напрямую на возможностях языка и платформы, которые былоступны в то время. Они не только отлично понимают дженерики, но и используюножество лямбда-выра жений в качестве центральных API элементов. Несмотря на тото большинство развитых DI-контейнеров также поддерживают эти более современныонструкции языка, в основе их центральных движков обычно лежат более ранние версии
.NET. Поскольку контейнеры второго поколения не обладают таким наследием, обычно х основе заложены самые базовые составляющие этих возможностей.
Autofac – это достаточно исчерпывающий DI-контейнер, имеющий тщательнпроектированный и логичный API. Он начал развиваться с конца 2007 года и, кажетсямеет достаточно обширную клиентскую базу.
В этой главе мы рассмотрим то, как можно использовать Autofac для применениринципов и паттернов, описанных ранее в частях 1-3. На рисунке 13-1
продемонстрирована структура этой главы.
Рисунок 13-1: Эта глава состоит из четырех разделов. Первый раздел знакомит нас с API
Autofac и должен рассматриваться в качестве предпосылки следующих трех разделов.
Каждый из четырех разделов может быть прочитан независимо от остальных разделовесмотря на то, что в четвертом разделе используются методы, которые вводятся ретьем разделе. Тема четвертого раздела значительно отличается от темы третьегооэтому читать их можно независимо друг от друга. Но, все-таки, вам можеонадобиться более детальная информация о некоторых составляющих API.
494
Эта глава должна дать вам возможность приступить к работе, а также справиться ольшинством общепринятых проблем, которые могут возникнуть при ежедневноспользовании Autofac. Это не окончательная трактовка Autofac, поскольку всецелое егассмотрение заняло бы несколько глав или, может быть, даже целую книгу. Но если ваочется получить больше информации об Autofac, то лучше всего начать изучения лавной страницы сайта Autofac – http://autofac.org.
Вы можете прочитать эту главу, не читая при этом остальные главы части 4, специальнля того, чтобы познакомиться с Autofac, или можете прочитать ее совместно стальными главами части 4, чтобы сравнить DI-контейнеры. Цель данной главы –
показать, как Autofac связан с паттернами и принципами, описанными в частях 1-3, и кан их реализует.
13.1. Знакомство с Autofac
13.2. Управление жизненным циклом
13.3. Работа с составными компонентами
13.4. Регистрация сложных API
13.5. Резюме
495
13.1. Знакомство с Autofac
Из этого раздела вы узнаете, где можно взять Autofac, что вы при этом получите и каачать его использовать. Кроме того, мы рассмотрим универсальные вариантонфигурирования, а также то, как пакетировать настройки конфигурации в повторнспользуемые компоненты. В таблице 13-1 содержится основополагающая информацияоторая, скорее всего, понадобится вам для того, чтобы приступить к работе с Autofac
Таблица 13-1: Краткая информация об Autofac
Вопрос Ответ
Откуда мне еголучить?
Перейдите на страницу http://autofac.org и нажмите ноответствующу ю ссылку в списке рекомендуемых загрузок.
Из Visual Studio 2010 можно получить его посредством NuGet. Имакета – Autofac.
Что находится агруженноайле?
Можно загрузить zip-файл, содержащий предварительнкомпилированные бинарные файлы. Кроме того, можно загрузитсходный код и скомпилить его самостоятельно, хотя при этом будерудно определить, какие изменения к какому релизу относятся.
Последняя составляющая номера сборки (например, длспользуемой в этой главе сборки это 724) соответствует ревизисходного кода, но для того, чтобы ее определить, понадобитсистема управления версиями Mercurial.
Какие платформоддерживаются?
Поддерживаются версии .NET 3.5 SP1, .NET 4, Silverlight 3, Silverlight
4. Кроме того, доступны и другие версии, поддерживающие .NET 2.0,
3.0 и Silverlight 2 (для этого во вкладке Download (Загрузить)
выберите пункт All Releases (Все релизы)).
Сколько он стоит? Нисколько. Это программное обеспечение с открытым исходныодом.
Откуда мнолучить помощь?
Коммерческую поддержку можно получить от компаний, связанных азработчиками Autofac. Подробную информацию можно получить найте http://code.google.com/p/autofac/wiki/CommercialSupport.
Невзирая на коммерческую поддержку, Autofac все еще остаетсрограммным обеспечением с открытым исходным кодом, которобладает процветающей экосистемой, поэтому, скорее всего (но нарантированно), помощь можно получить на официальном форумttp://groups.google.com/gro up/autofac
На какой версии
Autofac основанта глава?
2.4.5.724.
Процесс использования Autofac слегка отличается от процесса использования других DI-
контейнеров. Как показывает рисунок 13-2, это более явный процесс, состоящий из двуагов: сначала мы конфигурируем ContainerBuilder, а затем с помощью него создаеонтейнер, который можно использовать для разрешения компонентов.
496
Рисунок 13-2: При работе с Autofac сначала создается и конфигурируется экземпляр
ContainerBuilder. Затем с помощью него создается контейнер, который впоследствиожно использовать для разрешения компонентов. Обратите внимание на то, чтоследовательность действий больше похожа на работу с контейнерами Castle Windsoли StructureMap: конфигурируем, а затем разрешаем. Тем не менее, концепциазделения понятий при работе с Autofac гораздо понятнее. ContainerBuilder не умееазрешать компоненты, и поэтому мы не сможем сконфигурировать контейнер.
После прочтения этого раздела вы приобретете полноценное понимание всей сущностаттерна применения Autofac и сможете начать использовать его в сценариях, в которысе компоненты руководствуются должными DI-паттернами, например, Constructor
Injection. Давайте начнем с простейшего сценария и посмотрим, как можно разрешатбъекты с помощью контейнера Autofac.
Разрешение объектов
Основная услуга, предоставляемая любым DI-контейнером – разрешение компонентов. В
этом разделе мы рассмотрим API, которое позволяет разрешать компоненты при помощи
Autofac.
Вспоминая обсуждение процесса разрешения компонентов при помощи Castle Windsor и
StructureMap, вы, возможно, припомните, что Windsor требует, чтобы перед тем, как сталозможным разрешение компонентов, все соответствующие компоненты должны бытарегистрированы. В отличие от Castle Windsor StructureMap делает все возможное, чтобделать это за нас, когда мы запрашиваем конкретные типы с открытыми конструкторами.
Autofac может вести себя и как Castle Windsor, и как StructureMap, хотя по умолчанию еговедение совпадает с поведением Castle Windsor. Перед разрешением компонентов молжны их зарегистрировать, поэтому одним из самых простых способов применения
Autofac является приведенный ниже пример:
var builder = new ContainerBuilder();
builder.RegisterType<SauceBearnaise>();
var container = builder.Build();
SauceBearnaise sauce = container.Resolve<SauceBearnaise>();
Как уже было замечено ранее на рисунке 13-2, для конфигурирования компонентоеобходим экземпляр ContainerBuilder. В примере выше регистрируется конкретныласс SauceBearnaise с помощью builder, чтобы при запросе создания контейнерыходной экземпляр container компоновался классом SauceBearnaise. Все это даеозможность разрешать класс SauceBearnaise из контейнера.
497
Если компонент SauceBearnaise не был зарегистрирован, то попытка разрешить егриведет к исключению ComponentNotRegisteredException.
Если сравнивать этот самый простейший из всех сценариев с аналогичными фрагментамода Castle Windsor и StructureMap, то Autofac покажется слегка более подробным. Однакся эта подробность возникает, главным образом, благодаря дополнительно му шагоздания контейнера из ContainerBuilder, поэтому в более крупных и сложныонфигурациях Autofac будет сравним с другими DI-контейнерами.
По умолчанию Autofac требует явно регистрировать все соответствующие компоненты.
Такое поведение присуще и Castle Windsor. Если вам необходимо поведение, болеохожее на StructureMap, то можно поступить следующим образом:
var builder = new ContainerBuilder();
builder.RegisterSource(
new AnyConcreteTypeNotAlreadyRegisteredSource());
var container = builder.Build();
SauceBearnaise sauce = container.Resolve<SauceBearnaise>();
Единственное отличие от предыдущего примера – отсутствие явной регистрации класса
SauceBearnaise. Вместо этого вы регистрируете IRegistrationSource, называемый
AnyConcreteTypeNotAlreadyRegisteredSource. Это название довольно труднроизносить, но оно более или менее отражает функцию
AnyConcreteTypeNotAlreadyRegisteredSource: он выступает в роли источникегистраций любого конкретного типа, который ранее не был зарегистрирован. Пробавлении AnyConcreteTypeNotAlreadyRegisteredSource не нужно явно добавлять тип
SauceBearnaise, поскольку SauceBearnaise является конкретным классом с открытыонструктором, а источник регистраций может автоматически обеспечивать егегистрацию.
Источники регистраций
Дополнительная особенность Autofac – способность предоставлять большее количествополнительных источников регистраций, нежели при прямом использовании APIоторое раскрывается с помощью ContainerBuilder. Это механизм расширяемостиоторый Autofac использует для реализации различных возможностей, но, поскольку основан на открытом интерфейсе под названием IRegistrationSource, можнспользовать его и как механизм расширяемости.
Единственной открытой реализацией IRegistrationSource, которая входит в состав
Autofac, является AnyConcreteTypeNotAlreadyRegisteredSource, которую вы уже виделанее, но в Autofac есть и другие внутренние реализации интерфейса.
Идея, лежащая в основе IRegistrationSource, заключается в том, что реализации могуыступать в роли резервных механизмов или более эвристических источникоегистраций компонентов, чем те, которые может обеспечить обычное API. Помимышеупомянутых источников конкретных типов использовать IRegistrationSourcожно также и для того, чтобы превратить Autofac в автоматический mock-контейнер. Всто выходит за рамки этой книги, и для эффективного использования Autofac нееобходимости более подробно рассматривать IRegistrationSource.
498
Фактически, регистрация AnyConcreteTypeNotAlreadyRegisteredSource приводит ому, что контейнер начинает вести себя как StructureMap, а не как Castle Windsor. Теперонтейнер может не только разрешать конкретные типы, обладающие конструкторами пмолчанию, но и автоматически интегрировать тип с другими конкретнымависимостями, не используя при этом явную регистрацию. Кроме того, сразу после тогоак было введено слабое связывание, Autofac необходимо сконфигурировать нреобразование абстракций в конкретные типы.
Преобразование абстракций в конкретные типы
Несмотря на то, что время от времени способность Autofac автоматически интегрироватонкретные типы может становиться довольно полезной, обычно слабое связываниодразумевает преобразование абстракций в конкретные типы. Создание экземпляров нсновании таких преобразований – ключевая возможность, которую предлагает любой DI-
контейнер, но для начала нужно еще определить такие преобразования.
В приведенном ниже примере выполняется преобразование интерфейса IIngredient онкретный класс SauceBearnaise, что позволяет успешно разрешать IIngredient:
var builder = new ContainerBuilder();
builder.RegisterType<SauceBearnaise>().As<IIngredient>();
var container = builder.Build();
IIngredient ingredient = container.Resolve<IIngredient>();
Для регистрации типов и определения преобразований используется экземпляр
ContainerBuilder. Метод RegisterType дает возможность зарегистрировать конкретныип. Как вы уже видели в первом примере этой главы, можно остановиться и на этом, еслашей целью является только регистрация класса SauceBearnaise. Кроме того, промощи метода As можно продолжить пример и определить, каким образом необходимегистрировать конкретный тип.
Примечание
При использовании Autofac мы начинаем работать с конкретным типом, а затереобразовываем его в абстракцию. Такая последовательно сть полностьротивоположна работе с большинством других DI-контейнеров: в них абстракциреобразуется к конкретному типу.
Предупреждение
По сравнению с Castle Windsor и StructureMap в Autofac, в сущности, отсутствуюграничители generic-типа между типами, определенными методами RegisterType и As. А
это означает, что можно преобразовывать несовместимые типы. Код будеомпилироваться, но во время выполнения, когда ContainerBuilder будет создаватонтейнер, возникнет исключение.
В большинстве случаев нам нужно только generic API. Несмотря на то, что generic API, тличие от других DI-контейнеров, не обеспечивает должную типовую безопасность, этсе равно хороший способ конфигурирования контейнера. Однако в некоторых ситуацияеобходим и более слабо типизированный способ разрешения сервисов. Это тожозможно.
499
Разрешение слабо типизированных сервисов
В некоторых случаях нельзя использовать generic API, поскольку на этапе проектированиожет быть неизвестно, какой тип нужен. Все, что у нас есть – экземпляр Type, но, все жеам может потребоваться и экземпляр этого типа. Пример такой ситуации приведен азделе 7.2 "Построение ASP.NET MVC приложений", где мы обсуждали ASP.NET MVC
класс DefaultControllerFactory. Соответствующий метод приведен ниже:
protected internal virtual IController GetControllerInstance(
RequestContext requestContext, Type controllerType);
Поскольку в наличии у нас только экземпляр Type, мы не можем использовать дженерики должны прибегнуть к слабо типизированному API. В Autofac есть слабо типизированнаерегрузка метода Resolve, которая позволяет реализовывать метод
GetControllerInstance следующим образом:
return (IController)this.container.Resolve(controllerType);
Слабо типизированная перегрузка метода Resolve позволяет передавать параметontrollerType прямо в Autofac, но при этом необходимо приводить возвращаемоначение к IController.
Независимо от используемой перегрузки метода Resolve Autofac гарантирует, что этерегрузка будет возвращать экземпляр необходимого типа или выдавать исключение лучае отсутствия подходящих зависимостей. После того, как все необходимыависимости должным образом сконфигурированы, Autofac может автоматическнтегрировать необходимый тип.
В предыдущем примере this.container – это экземпляр Autofac.IContainer. Длбеспечения возможности разрешать необходимый тип все слабо связанные зависимостеобходимо сначала сконфигурировать. Autofac можно конфигурировать несколькимпособами. В следующем разделе приведена информация о самых универсальных из этипособов.
Конфигурирование ContainerBuilder
Как уже говорилось в разделе 3.2 "Конфигурирование DI-контейнеров", существуеесколько концептуально разных способов конфигурирования DI-контейнера. На рисунке
13-3 представлен обзор возможных вариантов.
500
Рисунок 13-3: Концептуально разные варианты конфигурирования. Использование кода ачестве конфигурации подразумевает строгую типизированность и имеет тенденцию вному определению. XML, с другой стороны, предполагает позднее связывание, но тожклонно к явному определению. Автоматическая регистрация, напротив, полагается ноглашения, которые могут быть и строго типизированными, и более слабпределенными.
Будучи DI-контейнером второго поколения, Autofac первоначально не имел в своеснове XML конфигурации, но позднее его API было заменено на программное API
конфигурации подобно некоторым наиболее развитым контейнерам. Конечно, егоздавали с заложенной в него возможностью эффективно использовать множествазличных источников конфигурации, и XML – это один из возможных вариантов.
Центральное API конфигурации сконцентрировано на коде и поддерживает каехнологию конфигурации в коде, так и автоматическую регистрацию на основаниоглашений, а XML остается одним из возможных вариантов.
Autofac поддерживает все три подхода и даже позволяет сочетать их в рамках одного ого же контейнера. Поэтому в этом отношении он обеспечивает нас всем, что толькогло бы нам понадобиться. В этом разделе описаны способы применения всех треипов источников конфигурации.
Конфигурация в коде
В разделе 13.1.1 "Разрешение объектов" уже приводился краткий обзор строгипизированного API конфигурации контейнера Autofac. В этом разделе мы рассмотриго более подробно.
501
В Autofac в любом типе конфигурации применяется API, раскрываемое классом
ContainerBuilder, несмотря на то, что большинство используемых нами методовляются методами расширений. Один из общепринято используемых методов – этетод RegisterType, о котором уже упоминалось ранее:
builder.RegisterType<SauceBearnaise>().As<IIngredient>();
Как и при работе с Castle Windsor, регистрация класса SauceBearnaise в виде
IIngredient скрывает конкретный класс так, что разрешать класс SauceBearnaise омощью этой регистрации больше невозможно. Тем не менее, с этим легко можнправиться с помощью перегрузки метода As, которая позволяет определить, чтонкретный тип преобразуется к нескольким зарегистрированным типам:
builder.RegisterType<SauceBearnaise>()
.As<SauceBearnaise, IIngredient>();
Вместо того чтобы регистрировать класс только в виде IIngredient, вы можетарегистрировать его и как класс, и как интерфейс, который он реализует. Это позволяеонтейнеру разрешать запросы и SauceBearnaise, и IIngredient.
Помимо этого еще один вариант – это связать в цепочку вызовы метода Call:
builder.RegisterType<SauceBearnaise>()
.As<SauceBearnaise>().As<IIngredient>();
Получаем результат, аналогичный только что рассмотренному примеру.
Существует три generic-перегрузки метода As, которые позволяют задать один, два илри типа соответственно. Если необходимо задать большее количество типов, то для этогуществует не generic-перегрузка. С помощью нее можно задать любое количество типов.
Подсказка
Если необходимо с помощью метода As задать более трех типов, то следует рассматриватго как smell-эскиз регистрируемого класса. Если он будет реализовывать столь многнтерфейсов, то, скорее всего, он нарушит принцип единичной ответственности.
В подлинных приложениях нам всегда приходится преобразовывать более однобстракции, поэтому приходится конфигурировать несколько преобразований. Делаетсто при помощи нескольких вызовов метода RegisterType:
builder.RegisterType<SauceBearnaise>().As<IIngredient>();
builder.RegisterType<Course>().As<ICourse>();
Здесь IIngredient преобразуется в SauceBearnaise, а ICourse – в Course. Наложениипов не происходит, поэтому вполне очевидно, что будет происходить. Тем не менеедну и ту же абстракцию можно зарегистрировать несколько раз:
builder.RegisterType<SauceBearnaise>().As<IIngredient>();
builder.RegisterType<Steak>().As<IIngredient>();
В этом примере IIngredient регистрируется дважды. При разрешении IIngredienолучаем экземпляр Steak. Выигрывает последняя регистрация, но предыду щие
502
регистрации тоже не забыты. Autofac правильно обрабатывает составные конфигурацидной и той же абстракции, но к этому мы еще вернемся в разделе 13.3.
При конфигурировании Autofac можно использовать и дополнительные опции, нолноценно сконфигурировать приложение можно и с помощью продемонстрированных том разделе методов. Однако чтобы оградить себя от слишком явного сопровожденионфигурации контейнера, вместо этих методов можно использовать другой подходснованный на соглашениях – автоматическу ю регистрацию.
Автоматическая регистрация
Чаще всего большинство регистраций будут аналогичны друг другу. Такие регистрацичень утомительно сопровождать, а явная регистрация каждого компонента, возможно, нвляется самым продуктивным подходом.
Рассмотрим библиотеку, в которой содержится множество реализаций интерфейса
IIngredient. Можно выполнять индивидуальну ю конфигурацию каждого класса, но этриведет к многочисленным схожим вызовам метода RegisterType. Что еще хуже, всякиаз при добавлении новой реализации IIngredient необходимо явно регистрировать еместе с ContainerBuilder, чтобы она была доступна для использования. Было бы болеродуктивно установить, что все реализации IIngredient, найденные в этой сборкееобходимо регистрировать.
Это можно выполнить с помощью метода расширения RegisterAssemblyTypes. Метод
RegisterAssemblyTypes позволяет указывать сборку и конфигурировать все выбраннылассы этой сборки посредством одного единственного оператора. Для полученикземпляра Assembly можно использовать представительский класс. В этом примераким классом является Steak:
builder.RegisterAssemblyTypes(typeof(Steak).Assembly)
.As<IIngredient>();
Метод RegisterAssemblyTypes возвращает тот же интерфейс, что и метод RegisterTypeоэтому можно использовать большинство таких же опций конфигурации, что и прспользовании метода RegisterType. Это поистине значительная возможность, посколькна означает, что для использования автоматической регистрации не нужно разбиратьси с каким новым API. В предыду щем примере для регистрации всех типов сборки в видервисов IIngredient использовался метод As.
Примечание
Несмотря на то, что типы возвращаемых значений совпадают, возвращаемый методом
RegisterAssemblyTypes интерфейс – это сложный generic-интерфейс. А посколькольшинство используемых нами API реализуются в виде методов расширений, не всетоды можно использовать в любой ситуации. Возможность их использования зависит типа аргументов возвращаемого generic-интерфейса.
В предыдущем примере, безусловно, конфигурируются все реализации интерфейса
IIngredient, но существует возможность использовать фильтры, которые позволяыбирать только необходимое подмножество реализаций. Ниже приведен примеснованного на соглашениях отбора, при котором добавляются только те классы, чье имачинается со слова "Sauce":
503
builder.RegisterAssemblyTypes(typeof(Steak).Assembly)
.Where(t => t.Name.StartsWith("Sauce"))
.As<IIngredient>();
При регистрации всех типов сборки для определения критерия отбора можнспользовать предикат. Единственное отличие от предыду щего примера – это импликациетода Where, в котором отбираются только те типы, имена которых начинаются со слова
"Sauce". Обратите внимание на то, что это тот же самый синтаксис, которыспользовался для фильтрации типов и в Castle Windsor, и в StructureMap.
Существует множество других методов, позволяющих задавать различные критеритбора. Метод Where позволяет отфильтровывать только те типы, которые совпадают редикатом, но есть еще метод Except, который работает совсем по-другому.
Помимо отбора из сборки соответствующих типов еще одной составляющевтоматической регистрации является определение соответствующего преобразования. В
предыдущих примерах использовался метод As с конкретным интерфейсом с тем, чтобарегистрировать все выбранные типы относительно этого интерфейса.
Тем не менее, иногда бывает необходимо использовать различные соглашения.
Предположим, что вместо интерфейсов мы используем абстрактные базовые классы обираемся зарегистрировать все типы сборки, имена которых заканчиваются на "Policy".
Для этих целей существует несколько перегрузок метода As, включая ту, которая ачестве входного параметра принимает Func<Type, Type>:
builder.RegisterAssemblyTypes(typeof(DiscountPolicy).Assembly)
.Where(t => t.Name.EndsWith("Policy"))
.As(t => t.BaseType);
Блок кода, заданный для метода As, будет использоваться для всякого типа, имя которогаканчивается на "Policy". Такой подход гарантирует, что все классы, имеющие суффикс
"Policy" будут зарегистрированы относительно их базового класса таким образом, что прапросе базового класса контейнер будет разрешать его в тип, преобразованный омощью этого соглашения.
В рамках Autofac достаточно легко выполнять регистрацию на основании соглашенийри этом используется API, которое практически отражает API, раскрываемое единичныетодом RegisterType.
Подсказка
RegisterAssemblyTypes считается множественной формой метода RegisterType.
Метод RegisterAssemblyTypes принимает в качестве параметра массив paramsостоящий из экземпляров Assembly, поэтому в одном соглашении можно использоватколь угодно много сборок. Поиск сборок в папке и применение всех найденных сбороля реализации дополнительной функциональности, при которой возможно добавлятасширения без повторной компиляции основного приложения – это не надуманная идея.
Это один из способов реализации позднего связывания. Еще один способ реализациозднего связывания – использование XML конфигурации.
504
XML конфигурация
XML конфигурацию хорошо использовать в тех ситуациях, когда должна существоватозможность изменять конфигурацию без повторной компиляции приложения.
Подсказка
Используйте XML конфигурацию только для тех типов, изменить которые вам нужно, ныполняя при этом повторной компиляции приложения. В остальных случаях применяйтвтоматическую регистрацию или технологию конфигурирования в коде.
Самый естественный способ использования XML конфигурации – внедрить ее тандартный конфигурационный файл .NET приложения. Это возможно, но при этомтобы изменить конфигурацию Autofac независимо от стандартного .config файларидется использовать еще и автономный XML-файл. Независимо от выбранного способспользуется практически одинаковое API.
Примечание
Поддержка контейнером Autofac XML конфигурации реализована в отдельной сборкеоэтому, чтобы воспользоваться этой возможностью необходимо добавить ссылку нборку Autofac.Configuration.
После добавления ссылки на Autofac.Configuration можно отправить
Container.Builder запрос на считывание регистраций компонентов из стандартного
.config файла следующим образом:
builder.RegisterModule(new ConfigurationSettingsReader());
Детальное обсуждение модулей Autofac приведено в разделе 13.1.3, а пока все, что ваеобходимо знать – это то, что ConfigurationSettingsReader – это класс, которытвечает за объединение XML конфигурации с остальными регистрациямирименяемыми к Container.Builder. При использовании конструктора по умолчанироисходит автоматическое считывание из раздела конфигурации стандартногонфигурационного файла приложения, но с помощью еще одной перегрузки можнказать и другой XML-файл, из которого будет считываться конфигурация.
Примечание
К сожалению, API, которое позволило бы нам считывать XML из других источников, римеру, из потоков или узлов, не существует.
Чтобы разместить конфигурацию Autofac в конфигурационном файле, для началеобходимо добавить раздел конфигурации с помощью стандартного .NET APIредназначенного для определения пользовательских разделов конфигурации:
<configSections>
<section name="autofac"
type="Autofac.Configuration.SectionHandler,
?Autofac.Configuration"/>
</configSections>
505
Этот код позволяет добавить в конфигурационный файл раздел конфигурации autofac.
Ниже приведен простой пример преобразования интерфейса IIngredient в класс Steak:
<autofac defaultAssembly="Ploeh.Samples.MenuModel">
<components>
<component type="Ploeh.Samples.MenuModel.Steak"
service="Ploeh.Samples.MenuModel.IIngredient" />
</components>
</autofac>
В элемент components можно добавить сколько угодно элементов component. В каждолементе с помощью атрибута type необходимо задать конкретный тип. Этдинственный обязательный атрибут, а для преобразования класса Steak в IIngredienожно использовать также необязательный атрибут service. Тип указывается с помощьолностью квалифицированного имени типа, но, если тип задан в сборке по умолчаниюо имя сборки можно опустить. Атрибут defaultAssembly является необязательным, нри этом довольно значительной возможностью, которая в случае наличия в одной и тое сборке множества типов позволяет избавиться от большого количества определениипов.
XML конфигурацию хорошо использовать, когда необходимо изменить конфигурацидного или нескольких компонентов без повторной компиляции приложения. Носкольку XML конфигурация может быть довольно хрупкой, необходимо прибегать ей только в указанных случаях и использовать для основной части конфигурационтейнера либо автоматическую регистрацию, либо конфигурацию в коде.
Подсказка
Не забыли, что выигрывает последняя конфигурация? Такое поведение можнспользовать для переписывания жестко закодированной с помощью XML конфигурации.
Для этого необходимо не забывать считывать XML конфигурацию после завершенионфигурирования любого другого компонента.
В этом разделе, главным образом, рассматривались различные API конфигурационтейнера Autofac. Хотя можно написать один большой блок неструктурированного кодонфигурации, лучше всего разделить конфигурацию на отдельные составляющие.
Autofac поддерживает эту возможность с помощью "модулей".
Пакетирование конфигурации
Иногда существует необходимость упаковать логику конфигурации в повторнспользуемые группы. И даже в тех случаях, когда само по себе повторное использование является высшим приоритетом, при конфигурировании больших и сложныриложений может появиться необходимость создать некоторого рода структуру.
При работе с Autofac конфигурацию можно упаковывать в модули. Модуль – это классеализующий интерфейс IModule, но в большинстве случаев проще всего выполнитаследование от абстрактного класса Module. На рисунке 13-4 продемонстрированерархия типов.
506
Рисунок 13-4: Повторно используемые конфигурации можно упаковывать в реализацинтерфейса IModule. Самый простой способ реализации IModule – наследование обстрактного класса Module, что и делает IngredientModule.
Все, что делается в дальнейшем, можно выполнить и внутри модуля. В следующеистинге представлен модуль, который регистрирует все реализации IIngredient.
Листинг 13-1: Реализация модуля в Autofaublic class IngredientModule : Module
{
protected override void Load(ContainerBuilder builder)
{
var a = typeof(Steak).Assembly;
builder.RegisterAssemblyTypes(a).As<IIngredient>();
}
}
IngredientModule наследуется от абстрактного класса Module и переопределяет метод
Load этого класса. Метод Load – это метод, определенный классом Module для облегчениеализации интерфейса IModule. Посредством метода Load вы получаете экземпляр
ContainerBuilder, который можно использовать для регистрации компонентов таким жамым способом, что и без применения Module. Знание способов использования API
ContainerBuilder упрощает реализацию Module.
Чтобы применить Module, можно воспользоваться вызовом одной из перегрузок
RegisterModule. Когда Module имеет конструктор по умолчанию, можно использоватокращенную generic-версию:
builder.RegisterModule<IngredientModule>();
Кроме того, существует перегрузка, которая позволяет создать экземпляр, используемый итуациях, в которых Module требуется создавать вручную:
builder.RegisterModule(new IngredientModule());
Конфигурировать модули можно и в XML:
<modules>
<modulype="Ploeh.Samples.Menu.Autofac.IngredientModule,
? Ploeh.Samples.Menu.Autofac" />
</modules>
507
Эти три примера функционально эквивалентны.
Подсказка
Модули Autofac позволяют пакетировать и структурировать код конфигурационтейнера. Используйте модули вместо однострочной конфигурации, и ваша Com position
Root станет более читабельной.
С помощью модулей конфигурацию контейнера Autofac можно выполнять любым иледующих способов: осуществлять конфигурацию в коде, использовать автоматическуегистрацию или XML. Кроме того, можно сочетать между собой указанные подходы.
После завершения конфигурации контейнера можно отправлять запросы на разрешениервисов.
Раздел 13.1 "Знакомство с Autofac" познакомил нас с DI-контейнером Autofac родемонстрировал фундаментальные принципы: как сконфигурировать
ContainerBuilder и впоследствии использовать созданный контейнер для разрешениервисов. Разрешение сервисов с легкостью выполняется посредством единичного вызоветода Resolve, поэтому вся сложность заключается в конфигурировании контейнера.
Конфигурировать контейнер можно несколькими способами, включая императивный ко XML. До настоящего момента мы рассматривали только самое основное API, а болеродвинутые вопросы в этом разделе еще не охватывались. Одна из самых важныроблем – управление жизненным циклом компонентов.
508
13.2. Управление жизненным циклом
В главе 8 обсуждался процесс управления жизненным циклом, в том числе наиболениверсальные стили существования, к примеру, Singleton и Transient. Autofaоддерживает несколько стилей существования и позволяет конфигурировать жизненныиклы всех сервисов. Продемонстрированные в таблице 13-2 стили существованивляются частью API.
Примечание
В Autofac стили существования называются областями применения экземпляров.
Таблица 13-2: Стили существования Autofac
Название Комментарии
Per
Dependency
Стандартный Transient. Эта область применения экземпляра используетсо умолчанию. Отслеживание экземпляров выполняет контейнер.
Single Instance Стандартный Singleton.
Per Lifetime
Scope
Связывает жизненные циклы компонентов с областью примененионтейнера (см. раздел 13.2.1).
Contextual Более расширенная версия Per Lifetime Scope
Реализации в Autofac стилей существования Transient и Singleton эквивалентны стиляуществования, описанным в главе 8, поэтому в этой главе я не буду тратить время на иассмотрение.
Подсказка
Используемый по умолчанию стиль Transient – самый безопасный, но не всегда являетсамым эффективным. Для потоко-безопасных сервисов Singleton – самый эффективнытиль, но вы не должны забывать о явной регистрации этих сервисов.
В этом разделе вы познакомитесь со способами определения стилей существования дломпонентов – как с помощью кода, так и при помощи XML. Кроме того, мы рассмотриущность областей применения и то, как их можно использовать для реализации Web
Request Context и других аналогичных стилей существования. После прочтения этогаздела вы уже сможете использовать стили существования Autofac в своем собственнориложении.
Начнем с рассмотрения способов конфигурирования областей применения дломпонентов.
Конфигурирование областей применения экземпляров
В этом разделе мы рассмотрим процесс управления областями применения экземпляров омощью Autofac. Конфигурирование области применения выполняется в рамкаегистрации компонентов, а определить ее можно либо с помощью кода, либо промощи XML. Поочередно рассмотрим каждую из этих возможностей.
509
Конфигурирова ние области применения с помощью кода
Область применения определяется как часть регистраций, которые мы выполняем длкземпляра ContainerBuilder. Это столь же просто, как и приведенный ниже код:
builder.RegisterType<SauceBearnaise>().SingleInstance();
В этом примере конкретный класс SauceBearnaise конфигурируется в виде Singletoаким образом, что каждый раз при запросе SauceBearnaise возвращается один и тот жкземпляр. Если нам необходимо преобразовать абстракцию в конкретный класс, которымеет конкретный жизненный цикл, то мы можем воспользоваться обычным методом As азместить вызов метода SingleInstance в любом удобном для нас месте. Приведенныиже регистрации эквивалентны:
builder
.RegisterType<SauceBearnaise>()
.As<IIngredient>()
.SingleInstance();
builder
.RegisterType<SauceBearnaise>()
.SingleInstance()
.As<IIngredient>();
Единственное различие между двумя примерами заключается в том, что мы меняеестами вызовы методов As и SingleInstance. Лично я предпочитаю использовать кодродемонстрированный сверху, поскольку вызовы методов RegisterType и Aормируют преобразование между конкретным классом и абстракцией. Размещение иядом друг с другом делает регистрацию более читабельной, и после этого мы можепределять область применения как изменение этого преобразования.
Несмотря на то, что стиль Transient используется по умолчанию, мы все равно можепределить его явным образом. Приведенные ниже примеры эквивалентны:
builder
.RegisterType<SauceBearnaise>();
builder
.RegisterType<SauceBearnaise>();
.InstancePerDependency();
Конфигурирование областей применения для регистраций, основанных на соглашенияхыполняется тем же самым методом, который используется и для обычных регистраций:
builder.RegisterAssemblyTypes(typeof(Steak).Assembly)
.As<IIngredient>()
.SingleInstance();
Чтобы задать область применения для всех регистраций соглашения, можноспользоваться методом SingleInstance и другими подходящими методами. В
предыдущем примере мы определяли все IIngredient как Singleton'ы.
Аналогично регистрации компонентов с помощью кода и XML, мы также можеконфигурировать область применения этими же способами.
510
Конфигурирова ние области применения с помощью XML
При возникновении необходимости определения компонентов с помощью XML вам такжахочется иметь возможность конфигурировать в этом же самом месте областрименения этих компонентов. Осуществить это можно в виде составляющей части XML-
схемы, которую вы уже видели в разделе 13.1.2 "Конфигурирование ContainerBuilder".
Для объявления стиля существования можно использовать необязательный атрибуnstance-scope:
<component type="Ploeh.Samples.MenuModel.Steak"
service="Ploeh.Samples.MenuModel.IIngredient"
instance-scope="single-instance" />
Отличие этого примера от примера, приведенного в разделе 13.1.2 "Конфигурирование
ContainerBuilder", заключается в добавленном атрибуте instance-scope, которыонфигурирует экземпляр в виде Singleton. Ранее, когда вы опускали этот атрибутвтоматически использовался стиль Transient.
Как с помощью кода, так и с помощью XML конфигурировать области примененикземпляров для компонентов довольно легко. Во всех случаях выполняется это в слегкекларативной форме. Несмотря на то, что конфигурация выполняется довольно простоы не должны забывать о том, что некоторые стили существования содержат объекты-
долгожители, которые пользуются ресурсами на протяжении всего своего жизненногикла.
Высвобождение компонентов
Как уже говорилось в разделе 8.2.2 "Управление устраняемыми зависимостями", важнысвободить объекты после завершения работы с ними. Autofac не имеет явного метода
Release, и вместо него использует так называемые области применения жизненногикла. Область применения жизненного цикла можно рассматривать как неиспользуемуопию контейнера. Как демонстрирует рисунок 13-5, область применения определяераницу, в рамках которой могут повторно использоваться компоненты.
511
Рисунок 13-5: Области применения контейнера Autofac выступают в роли контейнеровоторые могут совместно использовать компоненты в течение ограниченного времени илля ограниченного круга целей. Компонент с ограниченной областью применения – это
Singleton-компонент, расположенный в пределах этой области применения. Независимо оого, сколько раз мы запрашиваем этот компонент, мы получаем один и тот же экземпляр.
Другая область применения содержит свой собственный экземпляр, и родительскионтейнер управляет поистине совместно используемыми Singleton-компонентами.
Transient-компоненты никогда не используются совместно, но их срок действиаканчивается, когда устраняется область применения.
Област ь применения жизненного цикла определяет производный контейнер, которыожно использовать для конкретного срока действия или для конкретной цели. Наиболечевидным примером является веб-запрос. Мы порождаем область применения оонтейнера таким образом, что область применения наследует все Singleton'ытслеживаемые родительским контейнером, а область применения, помимо этого, играеоль контейнера "локальных Singleton'ов". Когда из области применения запрашиваетсомпонент, относящийся к этой области применения, мы всегда получаем один и тот жкземпляр. Отличие от настоящих Singleton'ов – при запросе второй области применениы получаем другой экземпляр.
Однако Transient-компоненты функционируют так, как им и положено, независимо оого, разрешаем ли мы их из корневого контейнера или из области применения.
512
Подсказка
Области применения можно использовать для реализации контекстных стилеуществования, например, стиля существования Web Request Context: создайте новубласть применения в начале каждого контекста и используйте его для разрешениомпонентов. А после завершения запроса устраните область применения. Тем не менеето касается области применения веб-запроса, Autofac имеет встроенную возможностнтеграции как с W eb Forms, так и с ASP.NET MVC, поэтому нам не нужно выполнять этнтеграцию самостоятельно.
Одна из важных характеристик областей применения – они позволяют нам должныбразом высвобождать компоненты по истечении срока действия этих областерименения. Новая область применения создается с помощью метода
BeginLifetimeScope и высвобождает все соответствующие компоненты посредствоызова метода Dispose:
using (var scope = container.BeginLifetimeScope())
{
var meal = scope.Resolve<IMeal>();
}
Строка 3: Уничтожение meal
Область применения создается из container посредством вызова метода
BeginLifetimeScope. Возвращаемое значение реализует интерфейс IDisposable, поэтоможно поместить это значение в оператор using. Поскольку возвращаемое значение онтейнер реализуют один и тот же интерфейс, scope можно использовать для разрешениомпонентов таким же образом, как и в случае работы с самим контейнером.
После окончания работы с областью применения ее можно устранить. При использованиператора using область применения автоматически устраняется при выходе иператора. Но это также можно сделать и явным образом путем вызова метода Dispose.
При устранении scope мы также высвобождаем все компоненты, созданные с помощьбласти применения. В этом случае это означает, что вы высвобождаете диаграммбъектов meal.
Примечание
Не забывайте, что высвобождение устранимого компонента и устранение компонента –
это не одно и то же. Это сигнал контейнеру о том, что компонент может завершить сворок действия. Если это T ransient-компонент или он ограничен областью применения, тн будет устранен. А если это Singleton компонент, то он будет продолжать действовать.
Ранее в этом разделе уже рассматривались способы конфигурирования компонентов иде Singleton'ов или Transient-компонентов. Конфигурирование компонента с цельолучения границ этого экземпляра, ограниченных областью применения, выполняетсналогичным образом:
builder.RegisterType<SauceBearnaise>()
.As<IIngredient>()
.InstancePerLifetimeScope();
513
Подобно методам SingleInstance и InstancePerDependency метод
InstancePerLifetimeScope можно использовать для указания того, что жизненный цикомпонента должен соответствовать области применения, которая создала экземплятого компонента.
Подсказка
Autofac отслеживает большинство Transient-компонентов, даже устраняемых, поэтомажно не забывать разрешать все компоненты области применения и устранять этбласть после окончания ее использования.
Пока жизненный цикл компонента не закончен, Singleton'ы, в соответствии с иущностью не высвобождаются. Однако если нам больше не нужен контейнер, мы можеысвобождать даже эти компоненты. Выполняется это посредством устранения самогонтейнера:
container.Dispose();
На практике это не столь важно, поскольку жизненный цикл контейнера находится лизких взаимоотношениях с жизненным циклом поддерживаемого им приложения.
Обычно мы сохраняем контейнер активным до тех пор, пока выполняется приложениеоэтому мы устраняем его только, когда приложение закрывается, при этом операционнаистема восстанавливает память.
Области применения позволяют нам обращаться ко множеству сценариев, в которых мо обыкновению используем Web Request Context или другой контекстный стилуществования. Это идиоматический способ реализации пользовательского жизненногикла с помощью Autofac.
На этом наш обзор процесса управления жизненным циклом в рамках Autofaавершается. Компоненты можно конфигурировать с помощью сочетания областерименения экземпляров, и это справедливо даже при регистрации составных реализацидной и той же абстракции. Мы еще не касались способов работы с составнымомпонентами, поэтому давайте направим все наше внимание в этом направлении.
514
13.3. Работа с составными компонентами
DI-контейнеры процветают благодаря их индивидуа льности, но их неопределенносторождает ряд трудностей. При использовании Constructor Injection единичныонструктор предпочтительнее перегружаемых конструкторов, поскольку в этом случасно, какой конструктор использовать в ситуации, когда у вас нет выбора. То же самоасается и преобразования абстракций к конкретным типам. Если мы пытаемсреобразовать конкретные составные типы к одной и той же абстракции, это приводит еопределенности.
Несмотря на столь нежелательну ю особенность как неопределенность, нам частриходится работать с составными реализациями единичного интерфейса. Это можероисходить в следующих ситуациях:
? Для разных потребителей должны использоваться разные специфичные типы
? Зависимости являются последовательнос тями
? Используются Decorator'ы
Мы рассмотрим каждую из этих ситуаций и увидим, как Autofac поочереди справляется аждой из них. После прочтения раздела вы должны будете уметь регистрировать азрешать компоненты даже тогда, когда в дело вступают составные реализации одной ой же абстракции.
Рассмотрим сначала способы предоставления более тщательного контроля, нежели тототорый предоставляет механизм автоматической интеграции.
Выбор среди составных кандидатов
Автоматическая интеграция – удобный и мощный инструмент, но предоставляет наеньшие возможности контроля. Пока все абстракции преобразуются в конкретные типтдельно друг от друга, никаких трудностей не возникает, но как только мы вводиольшее количество реализаций для одного и того же интерфейса, возникаееопределенность.
Давайте для начала повторим, как Autofac работает с составными регистрациями одной ой же абстракции.
Конфигурирова ние составных реализаций одного и того же сервиса
Как вы уже видели в разделе 13.1.2 "Конфигурирование ContainerBuilder", вы можетонфигурировать составные реализации одного и того же интерфейса:
builder.RegisterType<SauceBearnaise>().As<IIngredient>();
builder.RegisterType<Steak>().As<IIngredient>();
В этом примере классы Steak и SauceBearnaise регистрируются в виде сервиса
IIngredient. Выигрывает последняя регистрация, поэтому, если мы будем разрешать
IIngredient с помощью container.Resolve<IIngredient>(), то получим экземпляр
Steak.
515
Подсказка
Выигрывает последняя регистрация данного сервиса. Она определяет экземпляры этогипа, используемые по умолчанию.
Можно попросить контейнер разрешить все компоненты IIngredient. Autofac обладаепециально предназначеным для этих целей методом, но вместо того, чтобы егспользовать Autofac полагается на типы взаимосвязей. Тип взаимосвязи – это типбозначающий взаимосвязь, которую может интерпретировать контейнер. К примеру, длбозначения того, что нам нужны все сервисы, мы можем использовать IEnumerable<T>:
var ingredients = container.Resolve<IEnumerable<IIngredient>>();
Обратите внимание на то, что мы используем обычный метод Resolve, но запрашиваем
IEnumerable<IIngredient>. Autofac интерпретирует эту конструкцию как соглашение тдает нам все компоненты IIngredient, которыми он обладает.
Подсказка
В противоположност ь IEnumerable<T> мы можем также запросить массив. Результаты боих случаях будут одинаковы: мы получим все компоненты запрашиваемого типа.
В случае наличия регистраций, которые невозможно разрешить при запрашивании всеервисов определенного типа, Autofac выдает исключение, поясняющее, что существуюависимости, неудовлетвор яющие условиям. Такое поведение соответствует разрешенидиничного компонента, но отличается от поведения Castle Windsor или MEF.
При регистрации компонентов каждой регистрации можно присвоить свое собственномя, которое в дальнейшем можно использовать для осуществления выбора междазличными компонентами:
builder.RegisterType<Steak>()
.Named<IIngredient>("meat");
builder.RegisterType<SauceBearnaise>()
.Named<IIngredient>("sauce");
Как обычно мы начинаем с метода RegisterType, но вместо того, чтобы после негспользовать метод As, мы используем метод Named, чтобы задать тип сервиса, а также егазвание. Это позволяет нам разрешать именованные сервисы путем передачи этого жмени в метод ResolveNamed:
var meat = container.ResolveNamed<IIngredient>("meat");
var sauce = container.ResolveNamed<IIngredient>("sauce");
Примечание
Именованный компонент не считается компонентом по умолчанию. Если мегистрируем только именованные компоненты, то не сможем разрешать экземпляервиса, используемый по умолчанию. Тем не менее, ничто не мешает нам регистрироватомпонент по умолчанию (неименованный) с помощью метода As, а сделать это можно дном и том же операторе с помощью цепочки методов.
516
Присваивание имен компонентам с помощью строк – довольно универсальнаозможность DI-контейнеров, но Autofac также позволяет идентифициро вать компонент помощью произвольных ключей:
var meatKey = new object();
builder.RegisterType<Steak>().Keyed<IIngredient>(meatKey);
В роли ключа может выступать любой объект, который впоследствии можно использоватля разрешения компонента:
var meat = container.ResolveKeyed<IIngredient>(meatKey);
Подразумевая необходимость, всегда разрешать сервисы в одном Composition Root, мыкорее всего, не должны ждать появления такой неопределенности на этом уровне.
Подсказка
Если вы обнаружите, что вызываете метод Resolve с конкретным именем или ключомодумайте над тем, сможете ли вы сменить свой подход на менее неопределенный.
Тем не менее, именованные экземпляры или экземпляры, идентифицируе мые с помощьлюча, можно использовать для осуществления выбора среди нескольких экземплярори конфигурировании зависимостей данного сервиса.
Регистрация именованных зависимостей
Иногда бывает необходимо переопределить обычное поведение для того, чтоббеспечить более разветвленный контроль над тем, куда какая зависимость отправляется.
Кроме того, возможны ситуации, при которых приходится сталкиваться еопределенным API. В качестве примера рассмотрим следующий конструктор:
public ThreeCourseMeal(ICourse entree,
ICourse mainCourse, ICourse dessert)
В этом примере присутствуют три одинаковым образом типизированных зависимостиаждая из которых является отдельной сущностью, не похожей на другие. В большинствлучаев необходимо преобразовывать каждую из этих зависимостей в отдельный тип. В
следующем листинге продемонстрированы способы регистрации преобразований
ICourse.
Листинг 13-2: Регистрация именованных coursuilder.RegisterType<Rillettes>()
.Named<ICourse>("entree");
builder.RegisterType<CordonBleu>()
.Named<ICourse>("mainCourse");
builder.RegisterType<MousseAuChocolat>()
.Named<ICourse>("dessert");
В этом примере вы регистрируете три именованных компонента, преобразуя Rilettes кземпляр под названием "entree", CordonBleu – в экземпляр с именем "mainCourse", а
MousseAuChocolat – в экземпляр под названием "dessert".
517
При такой конфигурации вы теперь можете регистрировать класс ThreeCourseMeal омощью именованных регистраций. Оказывается, это довольно сложно. В следующеистинге я сначала продемонстрирую вам, на что это похоже, а затем мы подробназберем этот пример, чтобы понять, что происходит.
Листинг 13-3: Переопределение автоматической интеграции
1. builder.RegisterType<ThreeCourseMeal>()
2. .As<IMeal>()
3. .WithParameter(
4. (p, c) => p.Name == "entree",
5. (p, c) =>
6. c.ResolveNamed<ICourse>("entree"))
7. .WithParameter(
8. (p, c) => p.Name == "mainCourse",
9. (p, c) =>
10. c.ResolveNamed<ICourse>("mainCourse"))
11. .WithParameter(
12. (p, c) => p.Name == "dessert",
13. (p, c) =>
14. c.ResolveNamed<ICourse>("dessert"));
Строка 3: Определение параметра
Строка 4: Фильтры
Строка 5-6: Определение значений
Метод WithParameter позволяет предоставлять значения параметров для конструктора
ThreeCourseMeal. Одна из этих перегрузок принимает в качестве входных параметров двргумента. Первый аргумент – предикат, который определяет, является ли этот параметезультатом этого конкретного вызова метода. Для первого параметра вы задаете условието он касается только параметра под названием entree. Если это выражение имееначение true, то выполняется второй блок кода, определяющий значение для параметрntree. Параметр c – это экземпляр IComponentContext, который можно использоватля разрешения именованного компонента entree.
Подсказка
Аргументы метода WithParameter – это разновидность паттерна Tester-Doer.
Рассмотрим подробнее то, что происходит. Метод WithParameter действительно являетсберткой класса ResolvedParameter, который обладает следующим конструктором:
public ResolvedParameter(
Func<ParameterInfo, IComponentContext, bool> predicate,
Func<ParameterInfo, IComponentContext, object> valueAccessor);
Параметр predicate – это тест, который определяет, будет ли вызываться делегаalueAccessor: если параметр predicate возвращает true, то для определения значениараметра вызывается valueAccessor. Оба делегата принимают в качестве входныанных одну и ту же информацию: информацию о параметре в виде объекта
ParameterInfo и IComponentContext, который можно использовать для разрешениругих компонентов. Когда Autofac использует экземпляр ы ResolvedParameter, то прызове делегатов он возвращает оба эти значения. Иногда нет другого варианта, кроме как
518
старательно использовать метод WithParameter для каждого параметра конструктора. Н остальных случаях можно воспользоваться преимуществами соглашений.
Разрешение именованных компонентов с помощью соглашения
Если вы внимательно проанализировали листинг 13-3, то возможно обратили внимание новторяющийся паттерн. Каждый вызов метода WithParameter относится только дному параметру конструктора, но каждый valueAccessor выполняет то же самое: оспользует IComponentContext для разрешения компонента ICourse, имеющего то жазвание, что и параметр.
Нет никакого требования, согласно которому мы обязаны были бы называть компонент есть параметра конструктора. Но всякий раз, когда мы так поступаем, мы можеоспользоваться преимуществами этого соглашения и переписать листинг 13-3 болеростым образом. В следующем листинге продемонстрировано, как это сделать.
Листинг 13-4: Переопределение автоматической интеграции с помощью соглашениuilder.RegisterType<ThreeCourseMeal>()
.As<IMeal>()
.WithParameter(
(p, c) => true,
(p, c) => c.ResolveNamed(p.Name, p.ParameterType));
Возможно, это покажется удивительным, но обратиться ко всем трем параметраонструктора класса ThreeCourseMeal можно с помощью одного и того же вызова метода
WithParameter. Осуществить это можно, сформулировав соглашение о том, что этокземпляр будет управлять всяким параметром, какой Autofac смог бы ему передать.
Поскольку вы используете этот метод только для конфигурирования класса
ThreeCourseMeal, соглашение применяется только в рамках этой ограниченной области.
Поскольку предикат всегда возвращает значение true, второй блок кода будет вызыватьсля всех трех параметров конструктора. Во всех трех случаях этот блок кода будеросить IComponentContext разрешить компонент, имеющий те же самые имя и тип, чт параметр. Функционально это аналогично тому, что вы делали в листинге 13-3.
Предупреждение
Идентифицировать параметры по их именам удобно, но это не безопасно длефакторинга. Если вы переименуете параметр, то можете разрушить конфигурацию (этависит от используемого вами инструмента рефакторинга).
Переопределение автоматической интеграции посредством явного преобразованиараметров в именованные компоненты – это повсеместно используемое решение.
Сделать это можно даже в тех случаях, когда именованные компоненты конфигурируютс одном модуле, а потребитель находится совсем в другом модуле. Это возможнооскольку единственной идентификацией, связывающей именованный компонент араметром, является имя.
Такой подход можно использовать всегда, но, если нам придется управлять большиоличеством имен, то это будет довольно хрупким решением. Когда первоначальноричиной, побуждающей нас использовать именованные компоненты, является борьба еопределенностью, наилучшим решением этой проблемы станет создание своего
519
собственного API, которое позволит избавиться от этой неопределенности. Все этриводит к улучшению всего дизайна приложения.
В следующем разделе мы рассмотрим возможность использования менее неопределенног более гибкого подхода, при котором обед может состоять из нескольких блюд. Перетим нам необходимо изучить то, как Autofac работает со списками оследовательностями.
Интеграция последовательностей
В разделе 10.3.2 "Разработка пользовательского стиля существования" мы обсуждали, каыполнить рефакторинг явного класса ThreeCourseMeal к более универсальному классу
Meal, который обладает приведенным ниже конструктором:
public Meal(IEnumerable<ICourse> courses)
В этом разделе мы рассмотрим то, как можно сконфигурировать Autofac, чтобы онтегрировал экземпляры Meal с соответствующими зависимостями ICourse. Послассмотрения этого вопроса вы должны будете приобрести хорошее понимание теозможностей, которые доступны в случае необходимости конфигурированикземпляров, имеющих последовательности зависимостей.
Автоматическая инте грация последовательностей
Autofac довольно хорошо разбирается в последовательностях, поэтому, если наеобходимо использовать все зарегистрированные компоненты этого сервиса, то наужен как раз механизм автоматической интеграции. Например, имеконфигурированные в листинге 13-2 экземпляры ICourse, можно сконфигурироватервис IMeal следующим образом:
builder.RegisterType<Meal>().As<IMeal>();
Обратите внимание на то, что это совершенно стандартное преобразование конкретногипа в абстракцию. Autofac будет автоматически понимать конструктор Meal пределять, что правильным направлением действия является разрешение всеомпонентов ICourse. При разрешении IMeal вы получите экземпляр Meal, компонентамоторого являются ICourse из листинга 13-2: Rillettes, CordonBleu и
MousseAuChocolat.
Autofac автоматически управляет последовательностями и, пока мы не укажем обратноеыполняет то, чего мы от него и ждем: разрешает последовательность зависимостей всеарегистрированных компонентов этого типа. Только если нам нужно отобрать лишекоторые компоненты из большого набора, нам приходится выполнять больше действий.
Рассмотрим то, как это можно сделать.
О тбор нескольких компонентов из большого набора
Используемая Autofac по умолчанию стратегия внедрения всех компонентов зачастувляется правильной линией поведения. Но, как показывает рисунок 13-6, возможнлучаи, когда нам нужно отобрать только несколько зарегистрированных компонентов иольшого набора всех зарегистрированных компонентов.
520
Рисунок 13-6: В ситуации, продемонстрированной слева, мы хотим явным образотобрать определенные зависимости из большого списка всех зарегистрированныомпонентов. Это отличается от ситуации, приведенной справа, когда мы отбираем всез разбора.
Когда мы ранее позволяли Autofac автоматически интегрировать все сконфигурированныкземпляр ы, это соответствовало ситуации, изображенной в правой части рисунка 13-6.
Если нам нужно зарегистрировать компонент так, как это показано в левой части рисункао мы должны явно определить, какие компоненты необходимо использовать.
Для получения такого результата можно еще раз применить метод WithParameter так, каы уже использовали его в листингах 13-3 и 13-4. Все это время вы работали онструктором Meal, который в качестве входной информации принимал только один-
единственный параметр. В следующем листинге продемонстрировано, как можнеализовать составляющу ю метода WithParameter, которая предоставляет значениараметра, так, чтобы явным образом отбирать именованные компоненты из
IComponentContext.
Листинг 13-5: Внедрение именованных компонентов в последовательностuilder.RegisterType<Meal>()
.As<IMeal>()
.WithParameter(
(p, c) => true,
(p, c) => new[]
{
c.ResolveNamed<ICourse>("entree").ResolveNamed<ICourse>("mainCourse").ResolveNamed<ICourse>("dessert")
});
521
Как вы уже видели в разделе 13.3.1 "Выбор среди составных кандидатов", метод
WithParameter в качестве входных параметров принимает два делегата. Первый – этредикат, который используется для того, чтобы определить, должен ли вызыватьсторой делегат. В этом примере мне захотелось полениться, и я вернул значение true. Внаете, что у конструктора класса Meal есть только один параметр, поэтому метод
WithParameter будет работать. Тем не менее, если вы впоследствии измените класс Meaаким образом, что у его конструктора будет два параметра, метод WithParameter уже нудет работать корректно. Поэтому безопаснее всего будет установить явную проверкмени параметра.
Второй делегат предоставляет значение для параметра. Для разрешения тременованных компонентов в массив вы используете IComponentContext. В результатолучаем массив ICourse, который сравним с IEnumerable<ICourse>.
Autofac понимает последовательности. До тех пор пока не появляется необходимосттбирать только некоторые компоненты из всех сервисов указанного типа, Autofaвтоматически все делает правильно. Автоматическая интеграция применяется не толькля единичных экземпляров, но также и для последовательнос тей. А контейнереобразует последовательнос ть во все сконфигурированные экземпляр оответствующего типа.
Потребители, которые полагаются на последовательности зависимостей, могут бытамыми интуитивно понятными пользователю составными экземплярами одной и той жбстракции. Но перед тем как мы полностью отойдем от данной темы, нам необходимассмотреть последний (и, возможно, слегка неожиданный) случай, когда в дело вступаюоставные экземпляры.
Интеграция Decorator'ов
В разделе 9.1.2 "Паттерны и принципы механизма перехвата" мы обсуждали то, насколькаттерн проектирования Decorator полезен при реализации сквозных сущностей. Ппределению Decorator'ы представляют собой составные типы одной и той же абстракции.
У нас есть, по крайней мере, две реализации абстракции: сам Decorator и вложенныйй тип.
Если бы мы помещали Decorator'ы в стек, то у нас было бы еще больше реализаций.
Это еще один пример составных регистраций одного и того же сервиса. В отличие оредыдущих разделов эти регистрации не являются концептуально равносильными, ависят друг от друга. В этом разделе я рассмотрю два разных способа конфигурирования
Autofac для работы с данным паттерном.
С оздание обертки с помощью метода WithParameter
Метод WithParameter предлагает универсальный способ определения того, как создаютс внедряются компоненты. В разделах 13.3.1 "Выбор среди составных кандидатов" и
13.3.2 "Интеграция последовательност ей" вы уже видели, как можно использовать метод
WithParameter для отбора конкретных компонентов для параметров конструктора. Кромого, метод WithParameter – это отличный способ предоставления параметров для
Decorator'ов.
522
Рассмотрим способы использования метода WithParameter для конфигурирования класса
Breading, который является оберткой IIngredient. Для получения экземпляра, оберткооторого должен стать WithParameter, он использует паттерн Constructor Injection:
public Breading(IIngredient ingredient)
Чтобы получить Cotoletta, вам следует обернуть VealCutlet (еще один IIngredient) ласс Breading. То есть вы собираетесь внедрить VealCutlet в Breading. В следующеистинге продемонстрировано, как для этих целей можно использовать метод
WithParameter.
Листинг 13-6: Создание обертки с помощью метода WithParameteuilder.RegisterType<VealCutlet>().Named<IIngredient>("cutlet");
builder.RegisterType<Breading>()
.As<IIngredient>()
.WithParameter(
(p, c) => p.ParameterType == typeof(IIngredient),
(p, c) => c.ResolveNamed<IIngredient>("cutlet"));
Breading – это Decorator, но вам же нужно что-то обертывать, поэтому вы регистрируете
VealCutlet в виде именованного компонента. В этом примере вы регистрируете
VealCutlet перед Breading, но можно сделать это и по-другому. Порядок регистраций нмеет значения.
При регистрации Breading для определения параметра ingredient конструктора класса
Breading вы используете метод WithParameter. Вы реализуете предикат, проверяя, чтип параметра – IIngredient, и предоставляете значение для параметра путеазрешения именованного компонента cutlet из заданного IComponentContext.
В этом примере вы использовали именованную регистрацию IIngredient длегистрации компонента VealCutlet. Это делает компонент Breading компонентом
IIngredient по умолчанию. Еще один вариант – регистрировать VealCutlet и как
IIngredient, и как VealCutlet. В следующем примере продемонстрирован этот подход очетании со строго типизированным делегатом.
С оздание обертки с помощью делегатов
Вместо того чтобы обращаться к параметрам конструктора по типу или имени, мы можеаписать строго типизированный блок кода, в котором используется конструктор:
builder.RegisterType<VealCutlet>()
.As<IIngredient, VealCutlet>();
builder.Register(c => new Breading(c.Resolve<VealCutlet>()))
.As<IIngredient>();
В качестве альтернативы регистрации VealCutlet в виде именованного компонентожно также регистрировать его и как IIngredient, и как VealCutlet. При такоодходе важно делать это до регистрации Breading, псокольку в противном случае
VealCutlet станет компонентом IIngredient по умолчанию.
Вместо метода RegisterType, который вы в основном использовали до настоящегомента, можно также зарегистрировать сервис и с помощью метода под названием
Register. Существует две перегрузки этого метода, и каждая из них принимает в качестве
523
входного параметра делегат, который создает рассматриваемый сервис. Чтобарегистрировать сервис IIngredient, вы реализуете блок кода, который создает новыкземпляр Breading путем прямого вызова конструктора. Чтобы передать значение араметр конструктора ingredient, вы разрешаете тип VealCutlet из переданного
IComponentContext. Это возможно, поскольку вы зарегистрировали VealCutlet каонкретный тип, а также как IIngredient.
Примечание
Вы также могли бы разрешить VealCutlet по имени, если бы зарегистрировали его в видменованного компонента, как делали это в предыдущем примере.
Если вы попросите контейнер разрешить IIngredient, он передаст IComponentContext ачестве входного параметра в блок кода, который вы определили в методе Register. Прыполнении блока кода из контекста разрешается экземпляр VealCutlet и передается онструктор Breading, который возвращает экземпляр Breading.
Преимущество такого подхода заключается в том, что в блоке кода вы пишете код, отором используется конструктор Breading. Это обычная строка кода, поэтому онроверяется компилятором. Это придает вам уверенности в том, что если метод Registeомпилируется, значит, обертка для VealCutlet будет создаваться корректно.
Несмотря на то, что строгая типизированност ь более безопасна, ее еще и сложнопровождать. Если вы впоследствии решите добавить в конструктор Breading еще одиараметр, то блок кода больше не будет компилироваться, и вам придется вручнуешить эту проблему. Это не было бы столь необходимо, если бы вы использовали метод
WithParameter, поскольку Autofac смог бы разобрать новый параметр с помощьеханизма автоматической интеграции.
Как вы видели в этом разделе, существуют различные способы конфигурирования
Decorator'ов. Строго типизированный подход более безопасен, но может потребоватольше затрат на сопровождение. Более слабо типизированное API является более гибкиешением и позволяет Autofac справляться с изменениями вашего API, но ценой меньшеиповой безопасности.
Примечание
В этом разделе мы не обсуждали механизм перехвата во время выполнения. Несмотря но, что Autofac имеет Seam'ы, которые позволяют использовать механизм перехвата, оакже обладает встроенной поддержкой динамически создаваемых прокси. Эти Seam'ожно применять, чтобы использовать для создания таких классов другие библиотеки
(например, Castle Dynamic Proxy). Но поскольку они не являются частью Autofac, эта темыходит за рамки этой главы.
Autofac позволяет нам работать с составными экземплярами разными способами. Можем регистрировать компоненты в виде альтернатив друг другу, в виде пиров, которыазрешаются в виде последовательностей, или в виде иерархических Decorator'ов. В
большинстве случаев Autofac поймет, что надо делать, но мы всегда можем задать, каомпонуются сервисы, если нам нужен более явный контроль.
524
Кроме того, это может происходить в ситуации, когда нам нужно иметь дело с APIтклоняющимися от Constructor Injection. До настоящего момента вы наблюдали за темак регистрировать компоненты, включая то, как определять области применения, и кааботать с составными компонентами. Но до этого момента мы позволяли контейнеродключать зависимости, явным образом предполагая, что все компоненты используют
Constructor Injection. Поскольку это не всегда происходит именно так, в следующеазделе мы сделаем краткий обзор того, как работать с классами, экземпляры которыолжны создаваться особым образом.
525
13.4. Регистрация сложных API
До настоящего момента мы рассматривали то, как можно конфигурировать компонентыспользующие Constructor Injection. Одним из главных преимуществ Constructor Injectioвляется то, что DI-контейнеры, например, Autofac, могут с легкостью понимать, каомпоновать и создавать все классы диаграммы зависимостей.
Все становится менее понятным, когда API не столь хорошо функционируют. В данноазделе вы увидите, как работать с простейшими аргументами конструкторататическими фабриками и Property Injection. Все это требует особого внимания. Начнем ассмотрения классов, конструкторы которых принимают в качестве параметроростейшие типы, например, строки и целые числа.
Конфигурирование простейших зависимостей
Пока мы внедряем абстракции в потребителей, все в порядке. Но этот процессложняется, если конструктор зависит от простейшего типа, например, строковогоислового или перечисляемого. Наиболее часто это случается в реализациях доступа анным, которые принимают в качестве параметра конструктора строку соединения. Но о же время это является более общей проблемой, касающейся всех строковых и числовыипов.
В сущности, регистрация строкового или числового типа в качестве компонентонтейнера не имеет особого смысла. Но в рамках Autofac это, по крайней мересуществимо.
Рассмотрим в качестве примера приведенный ниже конструктор:
public ChiliConCarne(Spiciness spiciness)
В этом примере Spiciness имеет перечисляемый тип:
public enum Spiciness
{
Mild = 0,
Medium,
Hot
}
Предупреждение
Согласно эмпирическому правилу перечисления являются code smell'ами и их нужнреобразовывать в полиморфные классы (имеющие разное состояние). Тем не менее, дланного примера они вполне нам подходят.
Если вы хотите, чтобы все потребители Spiciness использовали одно и то же значениеожно зарегистрировать Spiciness и ChiliConCarne независимо друг от друга:
builder.Register<Spiciness>(c => Spiciness.Medium);
builder.RegisterType<ChiliConCarne>().As<ICourse>();
526
Когда вы впоследствии будете разрешать ChiliConCarne, его Spiciness будет иметначение Medium, как и все остальные компоненты, зависимые от Spiciness.
Если вы будете достаточным образом контролировать взаимосвязь Spiciness и
ChiliConCarne, вы сможете использовать метод WithParameter таким же образом, как и истингах 13-4, 13-5, 13-6:
builder.RegisterType<ChiliConCarne>()
.As<ICourse>()
.WithParameter("spiciness", Spiciness.Hot);
Поскольку вы собираетесь передать в параметр spiciness конкретное значение, вожете воспользоваться другой перегрузкой метода WithParameter, которая в качествходных данных принимает имя и значение параметра. Эта перегрузка делегируеолномочия другому WithParameter путем создания экземпляра NamedParameter имени и значения параметра. NamedParameter также наследуется от Parameter, как и
ResolvedParameter.
Оба описанных здесь варианта стимулируют автоматическую интеграцию нредоставление конкретного значения для компонента. Как уже обсуждалось в разделе
13.3 "Работа с составными компонентами", такой подход имеет как свои преимуществаак и недостатки. Если вам нужна строго типизированная конфигурация, котораызывает конструктор или статическую фабрику, вы также сможете это сделать.
Регистрация объектов с помощью блоков кода
Еще один вариант создания компонента с примитивным значением – использовать метод
Register, позволяющий передавать делегат, который создает компонент:
builder.Register<ICourse>(c =>
new ChiliConCarne(Spiciness.Hot));
Вы уже видели метод Register, когда мы обсуждали Decorator'ы в разделе 13.3.3
"Интеграция Decorator'ов". Всякий раз при разрешении компонента ICourse будеызываться конструктор ChiliConCarne с параметром Spiciness.Hot.
Примечание
Метод Register имеет безопасный тип, но не позволяет использовать автоматическунтеграцию.
Когда дело касается класса ChiliConCarne, вам предоставляется выбор междвтоматической интеграцией и использованием блока кода. Но другие классы болеграничены: их экземпляры нельзя создать с помощью открытого конструктора. Чтобоздать экземпляры типа, вместо открытого конструктора вам приходится использоватекоторого рода фабрику. Для DI-контейнеров это всегда проблематично, поскольку пмолчанию им нужны открытые конструкторы.
Рассмотрим приведенный ниже пример конструктора открытого класса JunkFood:
internal JunkFood(string name)
527
Даже если класс JunkFood является открытым, конструктор расположен внутри него.
Очевидно, экземпляры JunkFood должны создаваться с помощью статического класса
JunkFoodFactory:
public static class JunkFoodFactory
{
public static IMeal Create(string name)
{
return new JunkFood(name);
}
}
С точки зрения Autofac, это проблемное API, поскольку в нем отсутствуют точныраженные и заданные соглашения касательно статических фабрик. Тут требуетсомощь – и мы можем предоставить ее посредством блока кода, который Autofac можесполнять для того, чтобы создать экземпляр:
builder.Register(c =>
JunkFoodFactory.Create("chicken meal"));
В этот раз вы используете метод Register для создания компонента, вызывататическую фабрику в рамках блока кода. Всякий раз при разрешении IMeal будеызываться JunkFoodFactory.Create и возвращаться результат.
Является ли написание блока кода для создания экземпляра лучшим вариантом, нежелрямой вызов кода? При использовании блока кода внутри вызова метода Register мриобретаем следующие преимущества:
? IMeal преобразуется в JunkFood.
? Область применения экземпляра остается доступной для конфигурирования.
Несмотря на то, что для создания экземпляра вызывается блок кода, он может и нызываться всякий раз при запросе экземпляра. По умолчанию он вызывается, нсли мы изменим область применения экземпляра на Singleton, то блок кода будеызываться только один раз, а результат будет кэшироваться и впоследствиовторно использоваться.
Последним рассматриваемым нами отклонением от Constructor Injection является Property
Injection.
Интегрирование с помощью Property Injection
Property Injection – это менее определенная форма механизма внедрения зависимостейоскольку компилятор не принудает нас задавать значение свойства, доступного длаписи. Это касается и Autofac, который будет оставлять доступные для записи свойствезаполненными до тех пор, пока мы явно не попросим его заполнить их.
Рассмотрим класс CaesarSalad:
public class CaesarSalad : ICourse
{
public IIngredient Extra { get; set; }
}
528
По всеобщему заблуждению в состав салата "Цезарь" входит курица, но это не правда. Пуществу "Цезарь" является салатом, но, поскольку с курицей он вкуснее, то ее частредлагают использовать в нем в качестве дополнительного ингредиента. Класс
CaesarSalad моделирует такую возможность посредством доступного для записвойства под названием Extra.
Если вы конфигурируете только класс CaesarSalad, явно не обращаясь к свойству Extraо этому свойству не будет присвоено значение. Вы все равно можете разрешаткземпляр, но свойство Extra будет иметь значение по умолчанию, которое ему присвоионструктор (если только это имеет место).
Существует несколько способов, с помощью которых можно сконфигурировать
CaesarSalad таким образом, чтобы свойство Extra заполнялос ь соответствующибразом. Самым простым способом является использование метода
PropertiesAutowired:
builder.RegisterType<CaesarSalad>()
.As<ICourse>()
.PropertiesAutowired();
builder.RegisterType<Chicken>().As<IIngredient>();
Поскольку метод PropertiesAutowired является частью простого API регистрации, вожете вызвать его для того, чтобы сообщить Autofac, что ему необходимо автоматическнтегрировать доступные для записи свойства класса CaesarSalad. Autofac будевтоматически интегрировать только те свойства, о способе заполнения которых осведомлен, поэтому вы также регистрируете Chicken в виде IIngredient. Если бы вто не сделали, то свойство Extra было бы проигнорировано.
Когда вы на основании этой регистрации разрешаете ICourse, вы получаете экземпляр
CaesarSalad, свойству Extra которого присвоен экземпляр Chicken.
Если вам нужен более подробный контроль, нежели тот, который предоставляетсосредством метода PropertiesAutowired, то вы можете воспользоваться методом
WithProperty, который похож на метод WithParameter, используемый вами ранее:
builder.RegisterType<Chicken>().As<IIngredient>();
builder.RegisterType<CaesarSalad>()
.As<ICourse>(
.WithProperty(new ResolvedParameter(
(p, c) => p.Member.Name == "set_Extra",
(p, c) => c.Resolve<IIngredient>()));
Метод WithProperty отражает уже полюбившийся вам метод WithParameter: оринимает в качестве входных данных только один аргумент Parameter и также обладаеерегрузкой, которая в качестве параметров принимает имя и значение свойства.
Чтобы должным образом разрешить метод Extra, можно воспользоваться довереннылассом ResolvedParameter. Что касается свойств, переданный нами предикат имееебольшую отличительную черту, поскольку Autofac вызывает блок кода с аргументом
ParameterInfo, а не с PropertyInfo. Параметр p олицетворяет параметр value, которысегда потенциально доступен при реализации свойства, поэтому нам необходимерейти к Member, который определяет этот параметр. Member – это экземпляр MethodInfo,
529
поэтому нам нужно ознакомиться с тем, как реализуются C# свойства на уровннтерфейса: в действительности свойства Extra – это метод под названием set_Extra.
Когда предикат передан, легко реализовать получение значения путем разрешения
IIngredient из переданного IComponentContext.
Использование метода WithProperty дает нам более разветвленный уровень контроля над
Property Injection, при этом мы сохраняем слабое связывание. Если нам нужен друготрого типизированный подход, то это тоже возможно.
Autofac позволяет нам использовать блоки кода, которые будут вызываться в течениизненного цикла компонента при возникновении определенного события. Мы можеерехватывать эти события, чтобы заполнять свойства по мере того, как создаетсомпонент.
Одно из таких событий – событие OnActivating, которое Autofac вызывает всякий раз проздании нового экземпляра компонента. Это событие можно использовать длаполнения свойства Extra, пока Autofac не вернет экземпляр CaesarSalad:
builder.RegisterType<Chicken>().As<IIngredient>();
builder.RegisterType<CaesarSalad>()
.As<ICourse>()
.OnActivating(e =>
e.Instance.Extra = e.Context.Resolve<IIngredient>());
Метод OnActivating дает вам возможность выполнить какое-нибудь действие наомпонентом, пока Autofac не вернет его тому объекту, который его запрашивает. В
качестве единственного параметра он принимает
Action<IActivatingEventArgs<CaesarSalad>>, который можно использовать длеализации выбранной вами логики постобработки. Параметр e олицетворяет аргументобытия, а также обладает свойством Instance типа CaesarSalad и свойством Contextоторое можно использовать для разрешения других компонентов. Это сочетание вспользуете для того, чтобы разрешить IIngredient и вернуть результат в свойство
Extra. При разрешении ICourse вы получите экземпляр CaesarSalad, свойство Extrоторого имеет значение Chicken.
Поскольку свойство Instance привязано к аргументу интерфейса
IActivatingEventArgs<T>, имеющему generic-тип, этот подход является строгипизированным и влечет за собой свои преимущества и недостатки.
В этом разделе вы увидели, как можно использовать Autofac для работы с более трудными
API разработки. Для интеграции конструкторов и свойств с сервисами можнспользовать различные отклонения от абстрактного класса Parameter, чтобы при этооблюсти сходство с автоматической интеграцией, или можно воспользоваться методом
Register и блоком кода, чтобы соблюсти большую типовую безопасность.
В целом Property Injection отлично поддерживается и механизмом автоматическонтеграции и строго типизированными присваиваниями.
530
13.5. Резюме
В этой главе вы опробовали в действии DI-контейнер Autofac. Несмотря на то, что Autofac
– это контейнер второго поколения, он все равно достаточно комплексный и подходит длольшинства каверзных ситуаций, с которыми мы сталкиваемся при использовании DI-
контейнеров. Архитектура этого контейнера напрямую построена на особенностях .NET
3.5 и C# 3.0, но, хотя внутри Autofac использует делегаты и блоки кода, общее API прост использовании.
Важным вопросом, касающимся Autofac, является недвусмысленность. Он не пытаетсредугадать, что мы имеем ввиду, а предлагает легкое в использовании API, котороредоставляет нам возможность явным образом разрешать различные возможности.
Одним из примеров такой недвусмысленности является то, что в отличие от других DI-
контейнеров Autofac навязывает более строгую концепцию разделения между процессоонфигурирования и потребления контейнера. Компоненты мы конфигурируем омощью экземпляра ContainerBuilder, но ContainerBuilder не умеет разрешатомпоненты. После окончания процесса конфигурирования ContainerBuilder, мспользуем его для создания IContainer, который можно использовать для разрешениомпонентов.
Мы можем конфигурировать ContainerBuilder любым возможным способом: с помощьмперативного кода, посредством XML или путем задания соглашений. А конфигурациы можем пакетировать в модули.
То, как Autofac использует механизм управления жизненным циклом, нескольктличается от того, как его используют другие DI-контейнеры. Такие стандартные стилуществования, как Transient и Singleton являются встроенными. Но другие контекстнытили существования, например, Web Request Context, необходимы для областерименения, в которых мы явным образом взаимодейству ем с контейнером с цельпределить контекст, в рамках которого разрешаются и высвобождаются компоненты.
Это в полной мере касается стиля Web Request Context. С другой стороны, эта модель нозволяет нам реализовывать пользовательский стиль существования Pooled илэшированный стиль существования. Таким образом, простого способа реализациользовательских стилей существования с помощью Autofac нет. По мнению Николаса
Блумхардта (создателя Autofac), такие ситуации никогда не встречались нискуссионных форумах, поэтому, вероятнее всего, это не столь большая проблема. Чащсего предлагаемого Autofac механизма управления жизненным циклом бывает более чеостаточно.
Autofac – современный DI-контейнер, который предлагает достаточно исчерпывающиабор возможностей. В следующей главе мы рассмотрим еще один DI-контейнер второгоколения – Unity.
531
14. Unity
Меню:
? Знакомство с Unity
? Управление жизненным циклом
? Работа с составными компонентами
? Конфигурирование сложных API
В предыдущей главе мы рассматривали контейнер Autofac – один из недавноявившихся DI-контейнеров. Еще один современный DI-контейнер – это Unity. Его мы ассмотрим в этой главе.
Autofac можно назвать DI-контейнером второго поколения, поскольку он зародился азвивался прямиком на .NET 3.5, и не был нагружен никакими чертами более ранниерсий .NET. Несмотря на то, что Unity появился примерно в то же самое время, онаследовал более консервативный подход. Unity 1.0 был выпущен в мае 2008 года, ноздавался он под .NET 2.0, поскольку его разработчики осознавали, что большинстврганизаций потребуется некоторое время на то, чтобы перейти на версию .NET 3.5.
Unity – это модуль приложений, разработанный группой Patterns&Practices компании
Microsoft. Но не обращайте внимание на это название: модуль приложений – это простовторно используемая библиотека с соответствующей документацией и примерами.
Unity и Enterprise Library
Некоторые путают Unity и Enterprise Library (еще одно решение группы
Patterns&Practices) или, по крайней мере, то, как они взаимосвязаны друг с другом.
Давайте внесем некоторую ясность.
Unity – это самостоятельная библиотека. Ему не нужна Enterprise Library.
С другой стороны, в состав Enterprise Library входит Unity, хотя и выступает он в этолучае всего лишь в роли контейнера по умолчанию для Enterprise Library. Преобходимости Unity в Enterprise Library может быть заменен другим DI-контейнером.
Согласно некоторому совершенно не научному интернет-исследованию, Unity являетсамым широко используемым DI-контейнером. Это довольно удивительно, но, скоресего, связано с тем фактом, что разработала его компания Microsoft. Существующионкуренты, к примеру, Castle Windsor или StructureMap, не были отмечены в этосследовании, поэтому, вероятнее всего, Unity познакомил с понятием DI-контейнероовершенно новый сегмент пользователей, которые ранее ничего о нем не знали.
В этой главе мы в такой же последовательно сти, как делали это и для других DI-
контейнеров, рассмотрим контейнер Unity. Вы увидите, как можно использовать Unity длрименения принципов и паттернов, приведенных ранее в частях 1-3. На рисунке 14-1
представлена структура главы.
Рисунок 14-1: Эта глава состоит из четырех разделов. Первый раздел знакомит нас с
Unity и демонстрирует способы конфигурирования и разрешения компонентов.
Следующие три раздела связаны с паттернами применения, которые требуют
532
дополнительного внимания. Их можно прочитать по порядку или же пропуститекоторые из этих разделов и прочитать только те, которые вас интересуют.
Первый раздел знакомит нас с API контейнера Unity и должен рассматриваться в качествредпосылки следующих трех разделов. Каждый из четырех разделов может бытрочитан независимо от остальных разделов, несмотря на то, что в четвертом разделспользуются некоторые классы, которые вводятся в третьем разделе. Эти классы имеютносительно ясные имена, поэтому четвертый раздел можно прочитать, не читая перетим третий. Но, с другой стороны, у вас случайно может появиться необходимостернуться к этому разделу.
Подобно Castle Windsor контейнер Unity поддерживает несколько дополнительныозможностей, например, пользовательские жизненные циклы и механизм перехвата. В
этой главе приводятся примеры и того, и другого явления, а также множество другиолее универсальных возможностей DI-контейнера. Все эти возможности суммированыменно поэтому эта глава является одной из самых длинных глав этой книги.
Эта глава должна дать вам возможность приступить к работе, а также справиться ольшинством общепринятых проблем, которые могут возникнуть при ежедневноспользовании Unity. Это не окончательная трактовка Unity, а более подробнунформацию о Unity можно получить онлайн. Возможно, из доступных на сегодняшниомент DI-контейнеров Unity лучше всего задокументирован.
Вы можете прочитать эту главу, не читая при этом остальные главы части 4, специальнля того, чтобы познакомиться с Unity, или можете прочитать ее совместно с остальнымлавами части 4, чтобы сравнить DI-контейнеры. Цель данной главы – показать, как Unitвязан с паттернами и принципами, описанными в остальной части книги, и как он иеализует.
14.1. Знакомство с Unity
14.2. Управление жизненным циклом
14.3. Работа с составными компонентами
14.4. Конфигурирование сложных API
14.5. Резюме
533
14.1. Знакомство с Unity
Из этого раздела вы узнаете, где можно взять Unity, что вы при этом получите и каачать его использовать. Кроме того, мы рассмотрим универсальные вариантонфигурирования, а также то, как пакетировать настройки конфигурации в повторнспользуемые компоненты. В таблице 14-1 содержится основополагающая информацияоторая, скорее всего, понадобится вам для того, чтобы приступить к работе с Unity.
Таблица 14-1: Краткая информация об Unity
Вопрос Ответ
Откуда мне еголучить?
Лучше всего начать с сайта http://unity.codeplex.com/. На главнотранице приведены ссылки на самые последние релизы, которыбычно перенаправляют пользователей на веб-узел Microsoft
Download Center.
Из Visual Studio 2010 можно получить его посредством NuGet. Имакета – Unity.
Что находится агруженном файле?
В отличие от других контейнеров Unity загружается в виде .msайла. После его установки создаются ярлыки в меню Пуск, инарные файлы и исходный код помещаются в папку Program
Files. Но поскольку у вас теперь есть бинарные файлы, вы можетазвернуть их с помощью Xcopy, если предпочитаете эту форму.
Какие платформоддерживаются? .NET 3.5 SP1 и .NET 4.0. Silverlight 3 и 4.
Сколько он стоит?
Нисколько. По сути Unity – это программное обеспечение ткрытым исходным кодом, несмотря на то, что группа
Patterns&Practices не принимает внесенные в исходный козменения.
Откуда мнолучить помощь?
Unity – это предложение группы Patterns&Practices, а не продукомпании Microsoft. В связи с этим он не сопровождается компанией
Microsoft, но зато существует довольно оживленный дискуссионныорум – http://unity.codeplex.com/discussion s.
На какой версии
Unity основана этлава?
2.0.
Как и при работе с Castle Windsor и StructureMap, при использовании Unity соблюдаетсростая цикличность, проиллюстриро ванная на рисунке 14-2.
534
Рисунок 14-2: Сначала конфигурируется контейнер, а затем из него разрешаютсомпоненты. В большинстве случаев создается экземпляр класса UnityContainerоторый полностью конфигурируется перед началом разрешения компонентов.
Компоненты разрешаются из того же экземпляра, который перед этим конфигурировался.
После прочтения этого раздела вы приобретете полноценное понимание всей сущностаттерна применения Unity и сможете начать использовать его в сценариях, в которых всомпоненты руководствуются должными DI-паттернами, например, Constructor Injection.
Давайте начнем с простейшего сценария и посмотрим, как можно разрешать объекты омощью контейнера Unity.
Разрешение объектов
Основная услуга, предоставляемая любым DI-контейнером – разрешение компонентов. В
этом разделе мы рассмотрим API, которое позволяет разрешать компоненты с помощью
Unity.
Из предыду щих глав вы узнали, что при работе с некоторыми контейнерами (например,
Castle Windsor) перед тем, как начать разрешать компоненты, необходимо обязательнвным образом сконфигурировать все компоненты с помощью этого контейнера. В то жремя остальные контейнеры (например, StructureMap) полностью понимают, кавтоматически интегрировать запрашиваемые компоненты, поскольку они являютсонкретными типами с открытыми конструкторами. В сущности, можно сказать, что Unitаспознал последнюю из указанных выше категорий, будучи первым DI-контейнеромоддерживающим эту возможность, поэтому самым простым возможным способоспользования контейнера Unity является следующий:
var container = new UnityContainer();
SauceBearnaise sauce = container.Resolve<SauceBearnaise>();
Благодаря экземпляру UnityContainer generic-метод Resolve можно использовать длолучения экземпляра конкретного класса SauceBearnaise. Поскольку класс
SauceBearnaise имеет конструктор по умолчанию, Unity автоматически понимает, каоздавать экземпляр этого класса. Никакого явного конфигурирования контейнера нребуется.
Unity поддерживает механизм автоматической интеграции. Поэтому даже при отсутствионструктора по умолчанию он сможет создавать экземпляры без предварительноонфигурации, пока все входящие в конструктор параметры являются конкретными
535
классами и все листья дерева параметров имеют тип, обладающий конструкторами пмолчанию.
Рассмотрим в качестве примера конструктор Mayonnaise:
public Mayonnaise(EggYolk eggYolk, OliveOil oil)
Несмотря на то, что рецепт приготовления майонеза слегка упрощен, и EggYolk, и
OliveOil являются конкретными классами, обладающими конструкторами по умолчанию.
Сам Mayonnaise не обладает конструктором по умолчанию, но Unity все равно можеоздавать его без предварительно й конфигурации:
var container = new UnityContainer();
var mayo = container.Resolve<Mayonnaise>();
Это возможно, поскольку Unity способен разгадать, как создавать все необходимыараметры конструктора. Но как только мы ввели слабое связывание, мы должнконфигурировать Unity, преобразовав абстракции в конкретные типы.
Преобразование абстракций в конкретные типы
Несмотря на то, что способность Unity автоматически интегрировать конкретные классожет, наверняка, время от времени быть полезной, для слабого связывания обычнывает необходимо преобразовывать абстракции к конкретным типам. Созданикземпляров на основании таких преобразований – ключевая услуга, предлагаемая любым
DI-контейнером, но вам все равно необходимо задать соответствующее преобразование.
В приведенном ниже примере вы преобразуете интерфейс IIngredient в конкретныласс SauceBearnaise, который позволяет успешно разрешать IIngredient:
var container = new UnityContainer();
container.RegisterType<IIngredient, SauceBearnaise>();
IIngredient ingredient = container.Resolve<IIngredient>();
Generic-метод RegisterType – один из тех нескольких методов расширения, которыызывают слабо типизированный метод RegisterType, заданный для IUnityContainer. В
предыдущем примере вы использовали перегрузку, в которой определяли абстракцию, акже конкретный тип как два типовых generic-аргумента. В этом примере вреобразуете IIngredient в SauceBearnaise таким образом, чтобы при дальнейшеазрешении IIngredient вы получали экземпляр SauceBearnaise.
Generic-метод расширения RegisterType помогает предотвратить появление ошибоонфигурации, поскольку конечный тип обладает generic-ограничителем, который задаесловие, согласно которому этот тип наследуется от исходного типа. Код, приведенный редыдущем примере, компилируется, поскольку SauceBearnaise реализует IIngredient.
В большинстве случаев все, что вам нужно – это строго типизированное API, и, поскольк таком API выполняется необходимая проверка во время компиляции, вам лучшспользовать его при любой возможности. Однако встречаются ситуации, когдазрешать сервисы необходимо с помощью более слабо типизированных способов. Такооже возможно.
536
Разрешение слабо типизированных сервисов
Иногда у вас нет возможности использовать generic API, поскольку на этапроектирования вы еще не знаете, какой тип вам понадобится. У вас есть тольккземпляр Type, но все же вам хотелось бы получить экземпляр этого типа. Пример такоитуации описан в разделе 7.2 "Построение ASP.NET MVC приложений", в которобсуждался ASP.NET класс DefaultControllerFactory. Соответствующий меториведен в следующем примере:
protected internal virtual IController GetControllerInstance(
RequestContext requestContext, Type controllerType);
Поскольку у вас имеется только экземпляр Type, вы не можете использовать generic'и, олжны прибегнуть к слабо типизированному API. К счастью, Unity имеет слабипизированную перегрузку метода Resolve, которая позволяет реализовывать метод
GetControllerInstance следующим образом:
return (IController)this.container.Resolve(controllerType);
Слабо типизированная перегрузка метода Resolve позволяет передавать аргуменontrollerType напрямую в Unity, но при этом вам необходимо явным образориводить возвращаемое значение к IController.
Независимо от того, какую из перегрузок метода Resolve вы используете, Unitарантирует, что этот метод будет возвращать экземпляр запрашиваемого типа илыдавать исключение при наличии зависимостей, неудовлетворяющих условиям. Послого, как все необходимые зависимости должным образом сконфигурированы, Unitожет выполнить автоматическую интеграцию запрашиваемого типа.
В предыдущем примере this.container – это экземпляр IUnityContainer. Чтобы можныло разрешать запрашиваемый тип, сначала необходимо сконфигурировать все слабвязанные зависимости. Существует множество способов конфигурирования контейнера
Unity, а в следующем разделе приведен обзор наиболее универсальных из этих способов.
Конфигурирование контейнера
Как уже говорилось в разделе 3.2 "Конфигурирование DI-контейнеров", существуеесколько концептуально разных способов конфигурирования DI-контейнера. На рисунке
14-3 представлен обзор возможных вариантов.
537
Рисунок 14-3: Концептуально разные варианты конфигурирования. Технологионфигурирования в коде подразумевает строгую типизированность и имеет тенденцию вному определению. XML, с другой стороны, предполагает позднее связывание, но тожклонен к явному определению. Автоматическая регистрация, напротив, полагается ноглашения, которые могут быть и строго типизированными, и более слабпределенными, но в Unity не встроена поддержка механизма автоматическоегистрации.
Несмотря на то, что Unity полностью поддерживает XML-конфигурацию, в его основежит императивная конфигурация. XML-конфигурация реализуется в произвольноиблиотеке, для использования которой необходимо явным образом на нее ссылаться.
Хотя Unity поддерживает и конфигурацию в коде, и XML-конфигурацию, в него нстроена поддержка основанного на соглашениях механизма автоматическоегистрации. Однако, как мы уже ранее упоминали, мы всегда можем реализоватоглашение посредством написания пользовательского императивного кода. В этоазделе мы будем рассматривать способы применения различных вариантоонфигурации.
Конфигурация в коде
В разделе 14.1.1 "Разрешение объектов" уже приводился краткий обзор строгипизированного API конфигурации контейнера Unity. В этом разделе мы рассмотрим еголее подробно.
За исключением некоторых моментов вся конфигурация контейнера Unity выполняется лабо типизированном методе RegisterType, определенном для IUnityContainer:
538
IUnityContainer RegisterType(Type from, Type to, string name,
LifetimeManager lifetimeManagerarams InjectionMember[] injectionMembers);
Помимо этого метода в состав Unity входят еще несколько методов расширений.
Некоторые из них являются строго типизированными generic-методами, а некоторые –
слабо типизированными методами. В этой главе мы сосредоточим все свое внимание нтрого типизированном API. Одним из наиболее часто используемых методов являетсриведенная ниже перегрузка:
container.RegisterType<IIngredient, SauceBearnaise>();
В отличие от Castle Windsor или Autofac преобразование IIngredient в SauceBearnaiseриведенное в предыдущем примере, не избавляет нас от разрешения самого
SauceBearnaise. И sauce, и ingredient будут соответствующим образом разрешаться ледующем коде:
container.RegisterType<IIngredient, SauceBearnaise>();
var sauce = container.Resolve<SauceBearnaise>();
var ingredient = container.Resolve<IIngredient>();
Возможно, из разделов 10.1.2 "Конфигурирование контейнера" и 13.1.2
"Конфигурирование ContainerBuilder" вы помните, что преобразование IIngredient в
SauceBearnaise с помощью Castle Windsor или Autofac будет приводить к исчезновенионкретного класса (SauceBearnaise) до тех пор, пока вы не предпримитополнительные шаги. При работе с Unity никаких дополнительных шагов предпринимате нужно, поскольку Unity позволяет разрешать и IIngredient, и SauceBearnaise. В
большинстве случаев возвращаемые объекты – это экземпляр ы SauceBearnaise.
В реальных приложениях нам всегда приходится преобразовывать более однобстракции, поэтому нам необходимо сконфигурировать несколько преобразований.
Сделать это можно с помощью нескольких вызовов метода RegisterType:
container.RegisterType<IIngredient, SauceBearnaise>();
container.RegisterType<ICourse, Course>();
Здесь выполняется преобразование IIngredient в SauceBearnaise и преобразование
ICourse в Course. Никаких наложений типов не происходит, поэтому все, что происходиальше должно быть довольно очевидным. Кроме того, вы можете попытатьсарегистрировать одну и ту же абстракцию несколько раз, но, если вы сделаете это такак приведено в примере ниже, то произойдет что-то неожиданное:
container.RegisterType<IIngredient, Steak>();
container.RegisterType<IIngredient, SauceBearnaise>();
Регистрация типа без имени определяет значение по умолчанию для этого типа, но пртом переопределяется предыдущ ее значение по умолчанию. Конечным результатом этогримера является то, что, если вы будете разрешать IIngredient, то получите экземпляр
SauceBearnaise, но регистрация Steak при этом будет уже невозможна. Для типозможно только одно значение по умолчанию, но зарегистрировать вы можете сколькгодно именованных компонентов. Чтобы использовать Steak в качестве IIngredient пмолчанию, вы можете зарегистрировать SauceBearnaise, присвоив ему имя:
539
container.RegisterType<IIngredient, Steak>();
container.RegisterType<IIngredient, SauceBearnaise>("sauce");
Steak остается IIngredient по умолчанию, но, кроме того, вы можете разрешить
IIngredient в SauceBearnaise, запросив IIngredient с именем sauce. Чтобы точнказать, как будут интегрироваться зависимости, можно воспользоваться именованнымомпонентами. К этой теме мы вернемся в разделе 14.3.1.
Возможны и другие способы конфигурирования Unity, но с помощью приведенных в этоазделе методов можно полноценно сконфигурировать приложение. Чтобы оградить себт слишком явного сопровождения конфигурации контейнера, было бы простамечательно вместо этих методов использовать другой подход, основанный ноглашениях – автоматическу ю регистрацию.
Автоматическая регистрация
Чаще всего большинство регистраций аналогичны друг другу. Т акие регистрации очентомительно сопровождать, а явная регистрация каждого компонента, возможно, нвляется самым продуктивным подходом.
Рассмотрим библиотеку, которая содержит реализации интерфейса IIngredient. Можныполнять индивидуальну ю регистрацию каждого класса, но это приведет ногочисленным схожим вызовам метода RegisterType. Что еще хуже, всякий раз пробавлении новой реализации IIngredient необходимо явно регистрировать ее вместе онтейнером, чтобы она была доступна для использования. Было бы более продуктивнстановить, что все реализации IIngredient, найденные в этой сборке, необходимарегистрировать.
К несчастью, в Unity не встроена поддержка автоматической регистрации, но, поскольку
Unity имеет комплексное императивное API, мы можем написать пользовательский кодтобы достичь того же эффекта. В следующем листинге мы рассмотрим простой примероторый демонстрирует, как этого можно достичь. Это никоим образом не являетскончательной трактовкой этой темы, а скорее зарисовкой возможных вариантов.
Чтобы просмотреть сборку и зарегистрировать все реализации интерфейса IIngredientожно воспользоваться комбинацией рефлекционного API .NET и слабо типизированногетода RegisterType, как это продемонстрировано в следующем листинге.
Листинг 14-1: Регистрация всех IIngredient сборкoreach (var t in typeof(Steak).Assembly.GetExportedTypes())
{
if (typeof(IIngredient).IsAssignableFrom(t))
{
container.RegisterType(typeof(IIngredient), t, t.FullName);
}
}
Из этой сборки вы можете вытащить перечень всех открытых типов и выбрать только тз них, которые напрямую или косвенно реализуют интерфейс IIngredient. Послрименения фильтра для регистрации каждого типа IIngredient относительннтерфейса можно воспользоваться слабо типизированным методом Register. Чтобредотвратить перетирание регистраций, необходимо не забывать присваивать каждой из
540
них уникальное имя. В этом примере вы используете полное имя каждого конкретногласса, но подойдет и что-нибудь другое, гарантирующее уникальность имени.
Несмотря на то, что Unity не обладает API, которое способно было бы справляться снованным на соглашениях механизмом автоматической регистрации, для достижениого же эффекта, можно было бы написать свой собственный код. Конечноредпочтительнее было бы иметь встроенную поддержку этого механизма, но, по крайнеере, API контейнера Unity не мешает нам определять соглашения вручную.
Подсказка
Проект с открытым исходным кодом Unity Auto Registration – одна из попыток определитовторно используемое API, которое позволило бы использовать механизвтоматической регистрации в Unity.
Будь мы более великодушны, мы могли бы сказать, что отсутствие API автоматическоегистрации означает для нас отсутствие всяких ограничений. Если мы можем что-такодировать, значит, мы можем это получить. Если бы мы захотели просмотреть папка факт наличия в ней сборок или выполнить поиск типов в каждой сборке, то мы дажмогли бы реализовать дополнительную функциональность, при которой можно было бобавлять в приложение расширения без повторной компиляции основного приложения.
Это был бы один из способов реализации позднего связывания. Еще один способ –
применение XML-конфигурации.
XML-конфигурация
XML-конфигурация является подходящим решением в тех ситуациях, когда наеобходимо уметь изменять конфигурацию без повторной компиляции приложения.
Подсказка
Рекомендую использовать XML-конфигурацию только для тех типов, изменять которыожно без повторной компиляции приложения. В остальных случаях используйтехнологию конфигурирования в коде.
Unity подразумевает, что мы размещаем XML-конфигурацию в конфигурационном файлриложения. Для загрузки и интерпретации XML-конфигурации в Unity используетстандартное .NET API конфигурации.
Подсказка
Поддержка контейнером Unity возможности выполнения XML-конфигурации полностьравнима с аналогичной возможностью других DI-контейнеров. В нем даже присутствует
XSD-файл, который применяется для того, чтобы разрешить использовать в Visual Studiонтекстную подсказку IntelliSense.
Примечание
Поскольку возможность поддержки контейнером Unity XML-конфигурации реализована иде отдельной сборки, для использования этой возможности необходимо добавитсылку на сборку Microsoft.Practices.Unity.Configuration.
541
После добавления ссылки на сборку Microsoft.Practices.Unity.Configuration молжны добавить директиву using для пространства имен
Microsoft.Practices.Unity.Configuration, чтобы нам стал доступен метод расширения
LoadConfiguration. Это позволяет нам загружать XML-конфигурацию посредством всегишь одного вызова метода:
container.LoadConfiguration();
Метод LoadConfiguration загружает XML-конфигурацию из стандартногонфигурационного файла приложения в контейнер.
Примечание
К сожалению, мы не можем считывать XML из других источников, например, из потоколи XML-узлов, поскольку соответствующее API в Unity отсутствует.
Подсказка
Несмотря на то, что мы не можем считывать XML из произвольных источников, можем считывать XML из любого конфигурационного файла с помощью API
ConfigurationManager.
Чтобы разрешить выполнять конфигурацию контейнера Unity в конфигурационном файлеы должны сначала добавить раздел конфигурации, используя стандартное .NET API
конфигурации, предназначенно е для определения пользовательских разделоонфигурации:
<configSections>
<section name="unity"
type="Microsoft.Practices.Unity.Configuration.
?UnityConfigurationSection,
?Microsoft.Practices.Unity.Configuration"/>
</configSections>
Это API позволяет нам добавить в конфигурационный файл раздел конфигурации unity.
Ниже приведен простой пример преобразования интерфейса IIngredient в класс Steak:
<unity>
<namespace name="Ploeh.Samples.MenuModel" />
<assembly name="Ploeh.Samples.MenuModel" />
<container>
<register type="IIngredient" mapTo="Steak" />
</container>
</unity>
XML-схема контейнера Unity позволяет определять осмысленные значения пмолчанию, которые, возможно, помогут сократить большие объемы кода, появляющиесри работе с квалифициро ванными именами типов сборки в XML. Несмотря на то, чтобавлять элементы namespace не обязательно, мы можем добавлять их в неограниченнооличестве. Элементы namespace эквивалентны директивам using языка C#. В
приведенном выше примере кода мы добавляем только одно пространство имен
Ploeh.Samples.MenuModel, но могли бы добавить и большее количество таких элементоли же вовсе их опустить. Если мы опускаем элемент namespace, то все равно можем
542
явным образом передавать полностью квалифициро ванно е имя типа в виде составляющеасти регистрации.
Работа с элементом assembly аналогична работе с элементом namespace. Мы можеобавлять неограниченное количество элементов assembly или же совсем их опускать. В
приведенном выше примере кода мы добавляем сборку Ploeh.Samples.MenuModel, оторой определяются интерфейс IIngredient и класс Steak.
Это позволяет нам четко устанавливать соответствие между IIngredient и Steak омощью элемента register. Поскольку мы добавили в контекст пространства имен борки, мы можем ссылаться на IIngredient и Steak по их сокращенным именам. Покмена в рамках контекста четко определены, Unity раскрывает их за нас подобно тому, като делает компилятор C#.
XML-конфигурация является подходящим решением в тех ситуациях, когда наеобходимо изменить конфигурацию одного или нескольких компонентов без повторноомпиляции приложения. Но поскольку такой подход является довольно хрупким, молжны использовать его только для таких случаев, а для остальной части конфигурационтейнера использовать технологию конфигурирования в коде.
Подсказка
Вы не забыли, что выигрывает последняя конфигурация? Этот факт вы можетспользовать для того, чтобы переписать жестко закодированную конфигурацию омощью XML-конфигурации. Для этого вы должны не забыть загрузить XML-
конфигурацию после конфигурации всех остальных компонентов. И наоборот, если у вамеется конфигурация, которую нельзя переписывать с помощью XML, примените этонфигурацию после загрузки XML-конфигурации.
В этом разделе мы, главным образом, рассматривали различные API регистрационтейнера Unity. Несмотря на то, что вы, наверняка, можете записать один большой блоеструктурированного кода конфигурации, лучше всего разбить конфигурацию нодули. Хотя контейнер Unity явным образом не поддерживает такую возможностьказывается, мы все равно можем достичь такого же результата.
Пакетирование конфигурации
Иногда существует необходимость упаковать логику конфигурации в повторнспользуемые группы. И даже в тех случаях, когда само по себе повторное использование является высшим приоритетом, при конфигурировании больших и сложныриложений может появиться необходимость создать некоторого рода структуру.
В контейнере Castle Windsor есть инсталлеры, в StructureMap – регистры, а в Autofac –
модули. Но в Unity нет ничего похожего. В нем отсутствует интерфейс, который был бредназначен, главным образом, для пакетирования конфигурации в повторнспользуемые компоненты. Но зато в нем есть более или менее достаточная замена этиеханизмам: расширения контейнера (Container Extensions).
Целью расширения контейнера Unity является не только пакетирование конфигурации овторно используемые пакеты. Как следует из его названия, расширение контейнеракже можно использовать для того, чтобы расширять функциональность контейнера
543
Unity. Например, такая возможность контейнера Unity, как механизм перехватаеализуется в виде расширения контейнера (это конкретное расширение мы рассмотрим азделе 14.3.4).
Несмотря на то, что расширения контейнера можно использовать для множествазличных целей, их также можно использовать и для разбиения конфигурации нодули. Все, что нам нужно для реализации расширения контейнера, – выполнитаследование от абстрактного класса UnityContainerExtension и реализовать метод
Initialize этого класса. В следующем листинге продемонстрировано, как можно егкостью преобразовать код из листинга 14-1 в расширение контейнера.
Листинг 14-2: Реализация расширения контейнерublic class IngredientExtension : UnityContainerExtension
{
protected override void Initialize()
{
var a = typeof(Steak).Assembly;
foreach (var t in a.GetExportedTypes())
{
if (typeof(IIngredient).IsAssignableFrom(t))
{
this.Container.RegisterType(
typeof(IIngredient), t, t.FullName);
}
}
}
}
Класс IngredientExtension наследуется от абстрактного класса
UnityContainerExtension для того, чтобы пакетировать основанную на соглашенияонфигурацию из листинга 14-1 в повторно используемый класс. При наследовании оласса UnityContainerExtension необходимо реализовать абстрактный метод
Initialize, в котором вы можете выполнить все необходимые вам действия.
Единственное функциональное отличие от листинга 14-1 заключается в том, что теперместо локальной переменной вы вызываете метод RegisterType унаследованногвойства Container.
Чтобы воспользоваться расширением контейнера, можно вызвать метод AddExtension илоответствующий метод расширения. Если расширение обладает конструктором пмолчанию, то вы можете использовать характерное условное обозначение методасширения:
container.AddNewExtension<IngredientExtension>();
Метод AddNewExtension вызывает метод AddExtension, который вы также можетспользовать в тех ситуациях, когда вам необходимо создать модуль вручную:
container.AddExtension(new IngredientExtension());
Эти примеры функционально эквивалентны.
544
Подсказка
Расширения контейнера Unity позволяют пакетировать и структурироватонфигурационный код вашего контейнера. Даже если расширения разрабатываютсовсем не для этих целей, у вас может появиться желание использовать их вместднострочной конфигурации. Такой подход сделает вашу Composition Root болеитабельной.
Благодаря функциональности расширений контейнера для конфигурирования контейнера
Unity можно использовать как технологию конфигурирования в коде, так и XML-
конфигурацию, и даже реализованный пользователем механизм автоматическоегистрации (хотя этот подход занимает больше времени). После того как контейнеконфигурирован, можно приступить к разрешению сервисов с помощью этогонтейнера, что описано в разделе 14.1.1 "Разрешение объектов".
Этот раздел познакомил нас с DI-контейнером Unity и продемонстрироваундаментальные принципы: как сконфигурировать и впоследствии использоватозданный контейнер для разрешения сервисов. Разрешение сервисов с легкостьыполняется посредством единичного вызова метода Resolve, поэтому вся сложностаключается в конфигурировании контейнера. Конфигурировать контейнер можнесколькими способами, включая императивный код и XML. До настоящего момента массматривали только самое основное API, а более продвинутые вопросы в этом разделще не охватывались. Одна из самых важных проблем – это управление жизненныиклом компонентов.
545
14.2. Управление жизненным циклом
В главе 8 обсуждался процесс управления жизненным циклом, в том числе наиболениверсальные стили существования, к примеру, Singleton и Transient. Unity поддерживаеножество различных стилей существования и позволяет конфигурировать жизненныиклы всех сервисов. Продемонстрированные в таблице 14-2 стили существованивляются частью API контейнера Unity.
В контейнере Unity реализации стилей существования Transient, Per Graph и Singletoквивалентны основным стилям существования, описанным в главе 8. Поэтому я не будратить время на рассмотрение этих стилей существования.
Предупреждение
Несмотря на то, что стиль существования Per Resolve совпадает с описаниемриведенным в разделе 8.3.3 "Per Graph", он имеет некоторые известные дефектыоторые делают менее предпочтительным для использования.
Таблица 14-2: Стили существования Unity
Название Комментарии
Transient Этот стиль существования используется по умолчанию. Экземпляр онтейнером не отслеживаются.
Container
Controlled В Unity это название используется для обозначения стиля Singleton.
Per Resolve В Unity это название используется для обозначения стиля Per Graph.
Экземпляры контейнером не отслеживаются.
Hierarchical Связывает жизненные циклы компонентов с дочерним контейнером (см.
раздел 14.2.1).
Per T hread Для одного потока создается один экземпляр. Экземпляр ы контейнером нтслеживаются.
Externally
Controlled
Разновидность стиля существования Singleton, при котором сам контейнеодержит только хрупкую ссылку на экземпляр, позволяющу ю уничтожатго сборщиком мусора в случае неиспользования.
Подсказка
Используемый по умолчанию стиль существования Transient является самым безопасныариантом, но не всегда самым эффективным. Наиболее подходящий стилуществования для потоко-безопасных сервисов – стиль Singleton, но при этом нужно набывать явным образом регистрировать эти сервисы.
В этом разделе вы познакомитесь со способами определения стилей существования дломпонентов – как с помощью кода, так и посредством XML. Кроме того, чтобродемонстрировать, что мы не ограничены встроенными стилями существованионтейнера Unity, мы рассмотрим процесс реализации пользовательского стилуществования. После прочтения этого раздела вы уже сможете использовать стилуществования контейнера Unity в своем собственном приложении.
546
Перед тем как приступить к разработке пользовательского стиля существованияеобходимо рассмотреть способы конфигурирования и использования стилеуществования.
Конфигурирование стиля существования
В этом разделе мы рассмотрим способы управления стилями существования компонентовоторые применяются в контейнере Unity. Жизненный цикл компонента конфигурируетс рамках регистрации компонентов и может задаваться как в коде, так и в XML. Моочередно рассмотрим каждый из этих способов.
Конфигурирова ние стиля существования с помощью кода
Стиль существования конфигурируется с помощью перегрузки метода RegisterTypeоторая используется для регистрации компонентов в целом. По своей простоте онавносильна следующему коду:
container.RegisterType<SauceBearnaise>(
new ContainerControlledLifetimeManager());
В этом примере конкретный класс SauceBearnaise конфигурируется в виде Singletoаким образом, что всякий раз при запрашивании SauceBearnaise возвращается один от же экземпляр. Если нам необходимо преобразовать абстракцию в конкретный классмеющий конкретный стиль существования, можно воспользоваться еще одной похожеерегрузкой метода RegisterType:
container.RegisterType<IIngredient, SauceBearnaise>(
new ContainerControlledLifetimeManager());
В этом примере IIngredient преобразуется в SauceBearnaise и конфигурируется в виде
Singleton. В двух предыдущих примерах вы использовали перегрузки метода
RegisterType, которые в качестве аргумента принимали экземпляр LifetimeManager.
Вместо ContainerControlledLifetimeManager вы можете использовать любой друголасс, унаследованный от абстрактного класса LifetimeManager. В контейнере Unity длаждого стиля существования, описанного в таблице 14-2, есть свой LifetimeManager. Ноак вы впоследствии увидите в разделе 14.2.2, можно создать и свой собственный
LifetimeManager.
Несмотря на то, что стиль Transient используется по умолчанию, мы можем задать этвным образом. Приведенные ниже примеры эквивалентны:
container.RegisterType<SauceBearnaise>();
container.RegisterType<SauceBearnaise>(
new TransientLifetimeManager());
Благодаря использованию технологии конфигурирования в коде мы можеегистрировать компоненты, имеющие различные стили существования, любыпособом. Несмотря на то, что это намного более гибкий способ конфигурированиомпонентов, иногда для получения позднего связывания нам необходимо прибегать к
XML. В этом случае мы также можем объявлять стили существования.
547
Конфигурирова ние стиля существования с помощью XML
Когда нам нужно определять компоненты в XML, нам также может понадобитьсозможность конфигурировать в этом же месте их стили существования. Это можно легкделать в рамках XML-схемы, которая уже рассматривалась в разделе 14.1.2
"Конфигурирование контейнера". Для объявления стиля существования можнспользовать и необязательный элемент lifetime:
<register type="IIngredient" mapTo="Steak">
<lifetime type="ContainerControlledLifetimeManager" />
</register>
Отличие от примера из раздела 14.1.2 "Конфигурирование контейнера" заключается в томто теперь вы добавили необязательный элемент lifetime для того, чтобы определитьакой из LifetimeManager должен использоваться для регистрации. Чтобконфигурировать компонент в виде Singleton, вы устанавливаете атрибут типа, равнысевдониму ContainerControlledLifetimeManager, но вместо него могли бспользовать и квалифицированное имя типа сборки или пользовательский псевдонимсли бы вам нужно было присвоить пользовательский LifetimeManager.
Конфигурировать жизненные циклы легко как в коде, так и в XML. В обоих случаяонфигурирование жизненных циклов выполняется в довольно декларативной манере.
Несмотря на то, что конфигурация выполняется довольно просто, вы не должны забыват том, что некоторые стили существования содержат объекты-долго жители, которыользуются ресурсами на протяжении всего своего жизненного цикла.
Высвобождение компонентов
Как уже говорилось в разделе 8.2.2 "Управление устраняемыми зависимостями", важнысвободить объекты после завершения работы с ними, чтобы каждый устраняемыкземпляр можно было бы устранить по истечении его жизненного цикла. Это возможноо в рамках контейнера Unity сделать это довольно-таки трудно.
Предупреждение
Контейнер Unity не уничтожает устраняемые зависимости до тех пор, пока кто-нибудвно не прикажет ему это сделать.
IUnityContainer определяет метод Teardown, который с первого взгляда кажетсохожим на эквивалентный метод Release контейнера Castle Windsor. Мы можеопробовать использовать его таким же образом:
container.Teardown(ingredient);
Однако независимо от того, какой из встроенных стилей существования мы выбрали, ндин из компонентов не уничтожается. Это приводит к нарушению принципа
"наименьшего удивления" (Principle of Least Surprise).
Предупреждение
Метод Teardown не уничтожает устраняемые зависимости.
548
Несмотря на то, что метод Teardown не выполняет (по умолчанию) то, что нам хотелосы, нам, тем не менее, доступны некоторые другие варианты. Один из таких вариантов –
реализовать пользовательский стиль существования (что вы и сделаете в следующеазделе). Еще один вариант – использовать комбинацию дочерних контейнеров и стилуществования Hierarchical.
Сущность стиля существования Hierarchical заключается в том, что в рамках дочернегонтейнера он выступает в роли Singleton, но при этом каждый дочерний контейнебладает своим собственным локальным Singleton.
Примечание
Комбинация дочерних контейнеров и стиля существования Hierarchical аналогичнбластям применения контейнера Autofac, описанным в разделе 13.2.1
"Конфигурирование областей применения экземпляров".
Дочерний контейнер – это копия родительского контейнера. При создании дочернегонтейнера из родительского дочерний контейнер наследует из него всю конфигурациюо впоследствии мы можем изменять дочерний контейнер, не влияя при этом нодительский. Такая возможность может быть полезной, если нам необходимереопределить только небольшую часть конфигурации родительского контейнера.
Дочерний контейнер чаще всего имеет более ограниченную область применения. Каоказывает рисунок 14-4, он также определяет границу, в пределах которой могуовторно использоваться компоненты.
Рисунок 14-4: Дочерние контейнеры могут совместно использовать компоненты ечение ограниченного периода или для ограниченного круга целей. Компонент
Hierarchical по существу играет роль Singleton в рамках этого контейнера. Независимт того, сколько раз мы запрашиваем у дочернего контейнера этот компонент, молучаем один и тот же экземпляр. Другой дочерний контейнер будет получать свообственный экземпляр, а родительский контейнер управляет совместно используемыми
Singleton'ами. Transient-компоненты нельзя использовать совместно.
549
При создании нового дочернего контейнера он наследует все Singleton'ы, которымправляет родительский контейнер, но при этом выступает в роли контейнера "локальных
Singleton'ов". Когда из дочернего контейнера запрашивается компонент Hierarchical, мсегда получаем один и тот же экземпляр. Отличие от истинных Singleton'ов заключаетс том, что, если мы запросим компонент Hierarchical у второго дочернего контейнера, толучим совсем другой экземпляр.
Однако Transient-компоненты функционируют так, как и должны, независимо от тогоазрешаем ли мы их из родительского или из дочернего контейнера.
Подсказка
Дочерние контейнеры и стиль существования Hierarchical можно использовать в качествще одного варианта опускания стиля существования Web Request Context: создайтовый дочерний контейнер в начале каждого веб-запроса и используйте его длазрешения компонентов. После завершения запроса уничтожьте дочерний контейнер.
Одной из важных особенностей дочерних контейнеров является то, что они позволяюам соответствующим образом высвобождать компоненты по истечении их жизненногикла. С помощью метода CreateChildContainer мы создаем новый дочерний контейне высвобождаем все соответствующие компоненты посредством вызова метода Dispose:
1. using (var child = container.CreateChildContainer()
2. {
3. var meal = child.Resolve<IMeal>();
4. }
Строка 3: Уничтожение обеда
Новый дочерний контейнер создается из container посредством вызова метода
CreateChildContainer. Возвращаемое значение реализует интерфейс IDisposableоэтому вы можете поместить его в директиву using. Получаем новый экземпляр
IUnityContainer. В связи с этим вы можете использовать child для того, чтобазрешать компоненты точно таким же способом, как и при использовании родительскогонтейнера.
После окончания работы с дочерним контейнером вы можете уничтожить его. Прспользовании директивы using дочерний контейнер автоматически уничтожается прыходе из этой директивы. Но, безусловно, вы можете сделать это и, явно уничтожиочерний контейнер посредством вызова метода Dispose. При уничтожении child вакже высвобождаете все компоненты, созданные дочерним контейнером. В случариведенного выше примера это означает, что вы высвобождаете диаграмму объектeal.
Примечание
Не забывайте, что высвобождение устраняемого компонента и его уничтожение – это ндно и то же. Это сигнал контейнеру о том, что срок эксплуатации этого компонентавершился. Если это Hierarchical-компо нент, то он уничтожится автоматически, а если
Singleton, то он не будет уничтожен автоматически.
550
Предупреждение
Устраняемые объекты со стилями существования Transient или Per Graph нничтожаются при уничтожении дочернего контейнера. Это может привести к утечкаамяти.
Ранее в этом разделе вы уже видели, как сконфигурировать компоненты в виде Singletoли Transient. Конфигурирование компонента в виде Hierarchical выполняетсналогичным образом:
container.RegisterType<IIngredient, SauceBearnaise>(
new HierarchicalLifetimeManager());
При регистрации компонента с определенным стилем существования всегда используетсерегрузка метода RegisterType, принимающая в качестве аргумента LifetimeManager.
Чтобы использовать стиль существования Hierarchical, вы передаете в метод экземпляр
HierarchicalLifetimeManager.
По своей сущности Singleton'ы не высвобождаются по истечении жизненного цикламого контейнера. Однако мы можем высвобождать даже такие компоненты, еслонтейнер нам больше не нужен. Делается это посредством уничтожения самогонтейнера:
container.Dispose();
На практике это не столь важно, поскольку жизненный цикл контейнера находится лизких взаимоотношениях с жизненным циклом поддерживаемого им приложения.
Обычно мы сохраняем контейнер активным до тех пор, пока приложение запущено.
Поэтому устраняем мы его только тогда, когда приложение закрывается, при этоперационная система восстанавливает память.
Стили существования, встроенные в контейнер Unity, могут показаться довольнсчерпывающим набором стилей существования, удовлетворяющим практически всеоседневным нуждам. Но когда дело доходит до высвобождения компонентов, могуозникать проблемы в виде дефектов, а также проблемы несовместимости. С друготороны, в контейнере Unity присутствует достаточное количество Seam'ов, чтобы можныло справиться с этими проблемами посредством разработки пользовательских стилеуществования.
Разработка пользовательского стиля существования
В большинстве случаев мы должны уметь выходить из разных ситуаций с помощьсчерпывающего набора стилей существования, уже предоставляемых контейнером Unityо если у нас имеются особые нужды или нам необходимо справиться с проблемамрекращения срока эксплуатации, можно реализовать пользовательский стилуществования. В данном разделе вы увидите, как это сделать. Мы рассмотрим Seam'ыоторые делают возможным создание пользовательского стиля существования, и частремени потратим на рассмотрение примера, перемежая теорию с практикой.
551
Понимание API LifetimeManager
В разделе 14.2.1 "Конфигурирование стиля существования" мы уже мелькоассматривали API стилей существования контейнера Unity. Несколько перегрузок метода
RegisterType принимают в качестве параметра экземпляр абстрактного класса
LifetimeManager, который моделирует процесс взаимодействия стилей существования стальной частью контейнера Unity. На рисунке 14-5 продемонстрирована небольшаерархия типов, связанная с классом LifetimeManager.
Рисунок 14-5: SomeLifetimeManager реализует пользовательский стиль существованиосредством наследования от абстрактного класса LifetimeManager, который, в свочередь, реализует интерфейс ILifetimePolicy, унаследованный от интерфейса
IBuilderPolicy. Пользовательский стиль существования может реализовать
IDisposable, чтобы внедрить функциональность постобработки, в результате котороничтожается контейнер.
При реализации пользовательского стиля существования важнейшим типом являетсбстрактный класс LifetimeManager. Даже если LifetimeManager реализует
ILifetimePolicy, это нас никоим образом не касается, поскольку перегрузки метода
RegisterType принимают в качестве параметра только экземпляры LifetimeManager, а нкземпляр ы ILifetimePolicy или IBuilderPolicy.
Мы можем реализовать IDisposable, чтобы внедрить функциональность постобработкио по умолчанию эта функциональность работает не так, как нам бы хотелось. Метод
Dispose вызывается не всегда. Позднее мы еще вернемся к рассмотрению этого вопроса.
Предупреждение
То, что мы реализуем IDisposable, еще не гарантирует, что будет вызван метод Dispose.
При разрешении компонента контейнер Unity взаимодействует с LifetimeManager, чтроиллюстрировано на рисунке 14-6.
552
Рисунок 14-6: Контейнер Unity взаимодействует с интерфейсом ILifetimePolicyызывая сначала метод GetValue. Если policy возвращает какое-то значение, то этначение незамедлительно используется. Если значение не возвращается, то Unity создаеовое значение и устанавливает его в policy перед тем, как вернуть это значение.
Примечание
Механизм, проиллюстрированный на рисунке 14-6, аналогичен взаимодействию
StructureMap с IObjectCache, которое продемонстрировано на рисунке 11-5.
Сначала Unity пытается получить запрашиваемый экземпляр из метода GetValue. Еслтот метод возвращает null, то Unity создает запрашиваемый экземпляр и добавляет его olicy с помощью метода SetValue перед тем, как вернуть это значение. Таким образомдин экземпляр ILifetimePolicy управляет одним компонентом.
Предупреждение
Метод RemoveValue никогда не вызывается контейнером Unity.
Несмотря на то, что методы GetValue и SetValue принимают участие в процессазрешения запроса контейнером Unity, метод RemoveValue никогда не вызываетсонтейнером. Объяснение того, почему метод Teardown не работает так, как нам ботелось, займет слишком времени. Мы могли бы оставить реализацию пустой, ноказывается, мы можем изменить назначение метода. Перед детальным рассмотрениетого вопроса изучение примера, охватывающего самые основы, могло бы прояснитекоторые моменты.
Разработка стиля существования Caching
В приведенном ниже примере мы будем разрабатывать стиль существования Cachingоторый уже создавали для контейнеров Castle Windsor и StructureMap в разделах 10.2.3
553
"Разработка пользовательского стиля существования" и 11.2.2 "Разработкользовательского стиля существования". Если кратко, то этот стиль существованиэширует и повторно в течение некоторого времени использует экземпляры перед тем, ках высвободить.
Несмотря на то, что вы можете добавить некоторую дополнительную линию поведенияеализовав IDisposable и применив некоторые уловки, вам нужно будет реализовать, каинимум, три абстрактных метода, определенных LifetimeManager. Этродемонстрировано в следующем листинге.
Листинг 14-3: Реализация пользовательского LifetimeManager
1. public partial class CacheLifetimeManager :
2. LifetimeManager, IDisposable
3. {
4. private object value;
5. private readonly ILease lease;
6. public CacheLifetimeManager(ILease lease)
7. {
8. if (lease == null)
9. {
10. throw new ArgumentNullException("lease");
11. }
12. this.lease = lease;
13. }
14. public override object GetValue()
15. {
16. this.RemoveValue();
17. return this.value;
18. }
19. public override void RemoveValue()
20. {
21. if (this.lease.IsExpired)
22. {
23. this.Dispose();
24. }
25. }
26. public override void SetValue(object newValue)
27. {
28. this.value = newValue;
29. this.lease.Renew();
30. }
31. }
Строка 14-18: Получение значения
Строка 19-25: Удаление значения
Строка 26-30: Установка значения
Чтобы реализовать стиль существования Caching, необходимо унаследовать класс
CacheLifetimeManager от абстрактного класса LifetimeManager. Кроме того, класс
CacheLifetimeManager реализует IDisposable, но мы немного повременим с изучениееализации, поэтому в листинге 14-3 метод Dispose пропущен.
CacheLifetimeManager для получения экземпляра ILease использует паттерн Constructor
Injection. Интерфейс ILease – это локальный вспомогательный интерфейс, которыводится для реализации необходимой функциональности. Впервые этот интерфейс был
554
введен в разделе 10.2.3 "Разработка пользовательского стиля существования" и никак нлияет на контейнер Unity или любой другой DI-контейнер.
Примечание
Пример реализации ILease можно увидеть в разделе 10.2.3 "Разработка пользовательскогтиля существования".
Метод GetValue сначала вызывает метод RemoveValue, чтобы обезопасить себя оедействительного срока аренды, а затем возвращает значение поля value. Поле valuожет иметь null-значение, но, как демонстрирует рисунок 14-6, это ожидаемыценарий. С другой стороны, в поле может содержаться значение, если сначала быызван метод SetValue и при этом срок аренды не просрочен.
Несмотря на то, что метод RemoveValue никогда не вызывается самим Unity, это все равнтличное место для реализации кода, позволяющего высвободить компонент. Посколькелью CacheLifetimeManager является кэширование значения на некоторое время, встраняете компонент только по окончании срока аренды. В противном случае вы хранитго несколько дольше. Метод Dispose не включен в листинг 14-3, но мы скоро к немернемся.
Метод SetValue сохраняет значение в поле value и продляет срок аренды. Согласнхеме, приведенной на рисунке 14-6, метод SetValue вызывается только тогда, когда
Unity создает новое значение для рассматриваемого компонента, причем в этом случаместно продлять срок аренды.
Примечание
Сравните конструктор из листинга 14-3 с более сложным кодом, приведенным в листинге
10.2. Это сравнение отчетливо демонстрирует превосходство паттерна Constructor
Injection над Method Injection.
Все это реализует ключевую функциональность, необходимую для LifetimeManager.
Хотя нам все равно нужно обсудить реализацию IDisposable и то, что под ниодразумевается, нам следует для начала вкратце рассмотреть то, как
CacheLifetimeManager сопоставляется с экземпляром UnityContainer.
Регистрация компонентов с пользовательским стилем существования
Применять CacheLifetimeManager в рамках компонента довольно легко и делается этаподобие определения всех остальных стилей существования:
var lease = new SlidingLease(TimeSpan.FromMinutes(1));
var cache = new CacheLifetimeManager(lease);
container.RegisterType<IIngredient, SauceBearnaise>(cache);
В этом примере кода контейнер конфигурируется таким образом, что он с одноминутноадержкой использует CacheLifetimeManager для экземпляра IIngredient. В рамкадноминутного промежутка вы можете запрашивать какое угодно количество диаграмбъектов, и всякий раз, когда диаграмма содержит экземпляр IIngredient, вы будетолучать один и тот же SauceBearnaise. По истечении одноминутной задержки проследующих запросах будет возвращаться новый экземпляр SauceBearnaise.
555
Разрешение компонентов с пользовательским стилем существования выполняетсбычным образом. Сюрпризы начинаются только, когда мы пытаемся высвободитазрешенные диаграммы объектов.
Высвобождение компонентов с пользовательским стилем существования
Как я уже упоминал, метод RemoveValue никогда не вызывается контейнером Unity. Т ее менее, если нам необходимо добавить функциональность постобработки длользовательского LifetimeManager, мы можем заставить LifetimeManager реализовать
IDisposable. Это приведет к тому, что пользовательский LifetimeManager буденичтожен при уничтожении контейнера, являющегося владельцем этого
LifetimeManager.
Однако могут возникать и другие сюрпризы, но не будем заострять на них внимание. В
листинге 14-3 вы уже видели, что CacheLifetimeManager реализует IDisposable, но ледующем листинге вы впервые увидите саму реализацию.
Листинг 14-4: Уничтожение LifetimeManager
1. public void Dispose()
2. {
3. GC.SuppressFinalize(this);
4. this.Dispose(true);
5. }
6. protected virtual void Dispose(bool disposing)
7. {
8. if (disposing)
9. {
10. var d = this.value as IDisposable;
11. if (d != null)
12. {
13. d.Dispose();
14. }
15. this.value = null;
16. }
17. }
Строка 10-15: Уничтожение устраняемого объекта
Класс CacheLifetimeManager реализует IDisposable, руководствуясь при этотандартным паттерном Dispose. Если полученное значение реализует IDisposable, вго уничтожаете. Но в любом случае вы устанавливаете в поле value значение nullтобы сборщик мусора мог уничтожить этот компонент.
Согласно теории, если вы регистрируете и разрешаете устраняемый компонент омощью CacheLifetimeManager, компонент должен быть уничтожен вместе онтейнером следующим образом:
var lease = new SlidingLease(TimeSpan.FromMinutes(1));
var cache = new CacheLifetimeManager(lease);
container.RegisterType<IIngredient, Parsley>(cache);
var ingredient = container.Resolve<IIngredient>();
container.Dispose();
Согласно документации, которая прилагается к контейнеру Unity, при устраненионтейнера также выполняется высвобождение ingredient. Как известно, петрушку
556
нельзя разогревать, поэтому класс Parsley, очевидно, является устраняемым. Прничтожении контейнера уничтожается и экземпляр Parsley. Пока все идет так, как надо.
Тем не менее, при создании и уничтожении дочернего контейнера вы будете рассчитывата то, что устраняемый LifetimeManager будет работать так же, как и
HierarchicalLifetimeManager:
1. IIngredient ingredient;
2. using (var child = container.CreateChildContainer())
3. {
4. ingredient = child.Resolve<IIngredient>()
5. }
Строка 4: Ingredient не уничтожается
При наличии конфигурации компонента Parsley, аналогичной той, чтродемонстрирована в предыдущем примере, вы рассчитываете на то, что ingredient будестранен при уничтожении дочернего контейнера. Увы, этого не происходит.
CacheLifetimeManager.Dispose никогда не вызывается.
Предупреждение
Даже когда LifetimeManager реализует IDisposable, метод Dispose вызывается толькри уничтожении контейнера-владельца.
Как такое может происходить, если в аналогичном коде, который вы уже видели в разделе
14.2.1 "Конфигурирование стиля существования", использовался
HierarchicalLifetimeManager? Оказывается, контейнер Unity обладаеоответствующим BuilderStrategy, который содержит особую логику
HierarchicalLifetimeManager, позволяющу ю использовать эту функциональность.
Хорошая новость – мы можем сделать то же самое.
Реализация пользовательской Lifetim eStrategy
Причиной того, что HierarchicalLifetimeManager работает должным образом, являетсот факт, что Unity обладает BuilderStrategy, который создает копию
HierarchicalLifetimeManager, содержащейся в родительском контейнере, и связывает е дочерним контейнером. Это позволяет дочернему контейнеру уничтожать
LifetimeManager, когда он сам устраняется. То же самое мы можем сделать, реализоваользовательский BuilderStrategy, продемонстрированный в следующем листинге.
Листинг 14-5: Реализация пользовательского LifetimeStrategy
1. public class CacheLifetimeStrategy : BuilderStrategy
2. {
3. public override void PreBuildUp(
4. IBuilderContext context)
5. {
6. if (context == null)
7. {
8. throw new ArgumentNullException("context");
9. }
10. IPolicyList policySource;
11. var lifetimePolicy = context
12. .PersistentPolicies
557
13. .Get<ILifetimePolicy>(context.BuildKey,
14. out policySource);
15. if (object.ReferenceEquals(policySource,
16. context.PersistentPolicies))
17. {
18. return;
19. }
20. var cacheLifetime =
21. lifetimePolicy as CacheLifetimeManager;
22. if (cacheLifetime == null)
23. {
24. return;
25. }
26. var childLifetime = cacheLifetime.Clone();
27. context
28. .PersistentPolicies
29. .Set<ILifetimePolicy>(childLifetime,
30. context.BuildKey);
31. context.Lifetime.Add(childLifetime);
32. }
33. }
Строка 3-4: Переопределение PreBuildUp
Строка 10-14: Получение стратегии жизненного цикла
Строка 15-19: Проверка принадлежно сти
Строка 20-25: Проверка типа
Строка 26: Создание копии
Строка 27-31: Смена стратегии жизненного цикла
CacheLifetimeStrategy наследуется от абстрактного класса BuilderStrategy еализует метод PreBuildUp, который вызывается всякий раз, когда контейнер Unitоздает новый экземпляр. Это дает вам возможность изменить контекст до созданибъекта.
Первое, что вам необходимо сделать, – получить текущий ILifetimePolicy дломпонента. Контекст может предоставить эту информацию, а также информацию осточнике стратегии. Экземпляр policySource косвенным образом сообщает вам о томде определен стиль существования. Если источником является родительский контейнеро в настоящий момент вы выполняете настройку в рамках дочернего контейнера, тредполагается, что источник стиля существования будет отличаться от текущегонтекста, если стиль существования первоначально был определен в родительскоонтейнере. Это то, что нам надо, поэтому вы преждевременно выходите из метода.
Эта конкретная реализация затрагивает только CacheLifetimeManager, поэтому если ачестве стиля существования используется какой-то другой стиль, вы также выходите иетода. С другой стороны, если в качестве стиля существования используется стиль
CacheLifetimeManager, то вы создаете его копию, которая будет использоваться очернем контейнере.
558
Если вы точно уверены в том, что на данный момент выполняете настройку в рамкаочернего контейнера, то добавляете копию CacheLifetimeManager обратно в контекстактически, заменяя унаследованный из родительского контейнера стиль существованиа стиль, необходимый для этого конкретного дочернего контейнера.
Это достаточно сложно, и потом, вы еще даже не все до конца выполнили. Несмотря но, что вы реализовали пользовательский BuilderStrategy, вы еще не сообщили об этом
Unity. К счастью, как демонстрирует следующий листинг, это намного проще, чееализация CacheLifetimeStrategy.
Листинг 14-6: Расширение Unity с помощью CacheLifetimeStrategublic class CacheLifetimeStrategyExtension : UnityContainerExtension
{
protected override void Initialize()
{
this.Context.Strategies
.AddNew<CacheLifetimeStrategy>(
UnityBuildStage.Lifetime);
}
}
Чтобы добавить CacheLifetimeStrategy в контейнер Unity, вы создаете новоасширение контейнера. Помните, как вы использовали расширения контейнера длакетирования конфигурации в разделе 14.1.3 "Пакетирование конфигурации"? Здесь жредставлен еще один пример, возможно, более идиоматического применениасширения контейнера.
В методе Initialize вы добавляете контекст CacheLifetimeStrategy, наряду нформацией о том, что этот конкретный BuilderStrategy предназначен для управлениизненным циклом.
Наконец, выполнив все это, вы можете расширить контейнер Unity таким образом, что
CacheLifetimeManager теперь функционирует точно так же, как и
HierarchicalLifetimeManager:
container.AddNewExtension<CacheLifetimeStrategyExtension>();
После добавления этого расширения контейнера сценарий, который ранее не работал, онце концов, становится работоспособным: для высвобождения объектов со стилем
CacheLifetimeManager вы можете воспользоваться дочерними контейнерами. Теперьогда вы изучили BuilderStrategy, мы можем закончить цикл обучения и реализоватоддержку метода Teardown.
Реализация поддержки метода Teardown
Когда мы в разделе 14.2.1 "Конфигурирование стиля существования" приступали бсуждению процесса высвобождения компонентов, мы сразу же опустили метод
Teardown, поскольку он не высвобождал компоненты должным образом. С друготороны, это не должно было привести вас к мысли о том, что метод Teardown бесполезен.
Напротив, он вызывает различные методы зарегистрированных BuilderStrategy. Этзначает, что мы можем реализовать пользовательский BuilderStrategy, которыолжным образом высвобождает компоненты в рамках Teardown.
559
Было бы хорошо, если бы Teardown поддерживал CacheLifetimeManager. К счастьюесмотря на то, что поддержка CacheLifetimeManager подразумевает создание ещдного BuilderStrategy (или расширение уже созданного нами BuilderStrategy)истинг 14-7 демонстрирует, что это намного проще, чем реализация
CacheLifetimeStrategy, приведенного в листинге 14-5.
Листинг 14-7: Реализация стратегии высвобождения
1. public class CacheReleasingLifetimeStrategy : BuilderStrategy
2. {
3. public override void PostTearDown(
4. IBuilderContext context)
5. {
6. if (context == null)
7. {
8. throw new ArgumentNullException("context");
9. }
10. var lifetimes = context
11. .Lifetime.OfType<CacheLifetimeManager>();
12. foreach (var lifetimePolicy in lifetimes)
13. {
14. lifetimePolicy.RemoveValue();
15. }
16. }
17. }
Строка 3-4: Реализация PostTearDown
Строка 6-9: Граничный оператор
Строка 10-15: Высвобождение значения
Вместо того, чтобы переопределять метод PreBuildUp, как вы поступали в листинге 14-5ы переопределяете метод PostTearDown, который вызывается из метода TearDown послого, как списывается большинство остальных ресурсов рассматриваемого компонента.
Контекст имеет целый список объектов, определяющих стили существования, норедполагается, что в большинстве случаев контекст содержит только один единственныкземпляр CacheLifetimeManager. Все-таки, для чистоты эксперимента, вы делаете видудто в контексте может присутствовать любое количество таких объектов, и вызываететод RemoveValue для каждого из них. Как вы можете помнить из реализации
CacheLifetimeManager, приведенной в листинге 14-3, метод RemoveValue удаляет страняет соответствующее значение только по истечении срока аренды.
И вот вы уже близки к завершению цикла. Можете добавить
CacheReleasingLifetimeStrategy к CacheLifetimeStrategyExtension, приведенному истинге 14-6:
this.Context.Strategies
.AddNew<CacheLifetimeStrategy>(
UnityBuildStage.Lifetime);
this.Context.Strategies
.AddNew<CacheReleasingLifetimeStrategy>(
UnityBuildStage.Lifetime);
560
В конце концов, это позволяет вам высвободить кэшированные компоненты с помощьетода Teardown:
container.AddNewExtension<CacheLifetimeStrategyExtension>();
var lease = new SlidingLease(TimeSpan.FromTicks(1));
var cache = new CacheLifetimeManager(lease);
container.RegisterType<IIngredient, Parsley>(cache);
var ingredient = container.Resolve<IIngredient>();
container.Teardown(ingredient);
После создания такой инфраструктуры переменная ingredient, которая на самом делвляется экземпляром устраняемого класса Parsley, должным образом высвобождаетсри вызове метода Teardown. По истечении срока аренды экземпляр уничтожается, тем ненее, если срок аренды не истек, то ничего не происходит.
После того как мы добавили все эти LifetimeManager, BuilderStrategy и расширенионтейнера Unity наконец-то начинает функционировать так, как нам и нужно, то есть, тго часть, которая относится к стилю существования cache. Вспомните, что стили
Transient и Per Graph все равно не ведут себя так, как нам бы того хотелось.
Подсказка
Несмотря на то, что ни TransientLifetimeManager, ни PerResolveLifetimeManager неализуют IDisposable и в их методах RemoveValue не исполняется никакой логики, онио крайней мере, не изолированы. Если мы хотим, чтобы они должным образоысвобождали компоненты, то можем выполнить наследование от этих классов, а затем набыть реализовать соответствующие BuilderStrategy.
В заключении, мы должны признать, что хотя Unity и обладает множеством Seam'овеобходимых для желаемой нами реализации пользовательских стилей существованияделать это очень сложно. С другой стороны, это хотя бы возможно, чего мы не можеказать о некоторых других DI-контейнерах.
Можно было бы упаковать такой пользовательский стиль существования в повторнспользуемую библиотеку затем, чтобы нам, по крайней мере, не пришлось повторнеализовывать этот стиль существования для каждого нового приложения, которое мланируем создать. Это тоже нужно, поскольку модель управления жизненным цикломспользуемая контейнером Unity, не позволяет реализовать все наши потребностиесмотря на очевидную исчерпывающую поддержку им различных стилеуществования.
На этом наш обзор механизма управления жизненным циклом контейнера Unity подоше концу. По сравнению с остальными разделами, посвященными конкретным DI-
контейнерам, этот раздел довольно объемный. Частично это зависит от множествазличных возможностей, доступных нам при реализации пользовательских стилеуществования. С другой стороны, такой объем объясняется некоторыми уникальнымовушками, связанными с механизмом управления жизненным циклом, которые мнотелось бы рассмотреть. Конфигурировать компоненты можно и посредством сочетаниазличных стилей существования. Это справедливо и при регистрации составныеализаций одной и той же абстракции. Мы уже рассматривали процесс работы оставными компонентами, но в следующем разделе этот вопрос обсуждается болеглубленно. Unity позволяет нам более подробно изучить этот процесс, поскольку он
561
поддерживает механизм перехвата. Следующий раздел можно рассматривать каасширение обсуждения Decorator'ов.
562
14.3. Работа с составными компонентами
DI-контейнеры процветают благодаря их индивидуа льности, но их неопределенносторождает ряд трудностей. При использовании Constructor Injection единичныонструктор предпочтительнее перегружаемых конструкторов, поскольку в этом случасно, какой конструктор использовать в ситуации, когда у вас нет выбора. То же самоасается и преобразования абстракций к конкретным типам. Если мы пытаемсреобразовать конкретные составные типы к одной и той же абстракции, это приводит еопределенности.
Несмотря на столь нежелательну ю особенность как неопределенность, нам частриходится работать с составными реализациями единичного интерфейса. Это можероисходить в следующих ситуациях:
? Для разных потребителей должны использоваться разные специфичные типы
? Зависимости являются последовательнос тями
? Используются Decorator'ы
В этом разделе мы рассмотрим каждую из этих ситуаций и увидим, как Unity поочередправляется с каждой из них. После прочтения раздела вы должны будете уметегистрировать и разрешать компоненты даже тогда, когда в дело вступают составныеализации одной и той же абстракции.
Рассмотрим сначала способы предоставления более тщательного контроля, нежели тототорый предоставляет механизм автоматической интеграции.
Выбор среди составных кандидатов
Автоматическая интеграция – удобный и мощный инструмент, но предоставляет наеньшие возможности контроля. Пока все абстракции преобразуются в конкретные типтдельно друг от друга, никаких трудностей не возникает, но как только мы вводиольшее количество реализаций для одного и того же интерфейса, возникаееопределенность.
Способ работы контейнера Unity с составными регистрациями одной и той же абстракцилегка отличается от того, который используется другими DI-контейнерами. С
рассмотрения этого вопроса мы и начнем изучение раздела, поскольку с помощью негстанавливаются некоторые фундаментальные правила, которые понадобятся нам стальной части раздела.
Регистрация составных реализаций одного и того же компонента
Как вы уже видели в разделе 14.1.2 "Конфигурирование контейнера", вы можетегистрировать составные компоненты одного и того же сервиса:
container.RegisterType<IIngredient, Steak>();
container.RegisterType<IIngredient, SauceBearnaise>("sauce");
В этом коде может присутствовать только одна неименованная регистрация. Оназывается регист рацией по умолчанию. Если вы впоследствии вызовете для IIngredient
563
метод RegisterType без имени, то регистрация Steak будет заменена новыомпонентом.
Примечание
Регистрация по умолчанию для типа может быть только одна, а именованных регистрациожет быть сколько угодно.
При вызове метода Resolve без имени мы получаем объект на основании регистрации пмолчанию. Благодаря предыдущей конфигурации метод Resolve возвращает экземпляр
Steak:
var ingredient = container.Resolve<IIngredient>();
Об именованной регистрации sauce мы не забыли. Разрешать составные IIngredienожно следующим образом:
IEnumerable<IIngredient> ingredients =
container.ResolveAll<IIngredient>();
В соответствии с конфигурацией, приведенной в предыдущем примере, вы получаетоследовательность, содержащую не экземпляр Steak, а экземпляр SauceBearnaise.
Предупреждение
Метод ResolveAll возвращает все именованные регистрации, но не регистрацию пмолчанию.
Если существуют сконфигурированные экземпляры плагина, которые не могут бытазрешены при вызове метода ResolveAll, Unity выдает исключение, поясняющее, чтуществуют зависимости, неудовлетворяющие условиям. Такое поведение совместимо оведением метода Resolve, но отлично от того, как поступают Castle Windsor или MEF.
В следующем листинге демонстрируется, как можно использовать именованныегистрации для предоставления подсказок, которые позднее можно применять прсуществлении выбора между различными сконфигурированными компонентами.
Листинг 14-8: Присваивание имен регистрацияontainer.RegisterType<IIngredient, Steak>("meat");
container.RegisterType<IIngredient, SauceBearnaise>("sauce");
Каждой регистрации можно присвоить свое уникальное имя, которое в дальнейшеожно применять для различения похожих компонентов.
Примечание
Существует возможность регистрировать для типа только именованные компоненты. Еслы так сделаем, то у типа не будет регистрации по умолчанию.
Благодаря именованным регистрациям, приведенным в листинге 14-8, вы можетазрешить и Steak, и SauceBearnaise следующим образом:
564
var meat = container.Resolve<IIngredient>("meat");
var sauce = container.Resolve<IIngredient>("sauce");
Обратите внимание на то, что вы передаете тот же самый идентификатор, которыспользовали для именования компонента во время регистрации.
Принимая во внимание тот факт, что мы всегда должны разрешать сервисы динственном Composition Root, мы, скорее всего, не должны ждать появления такоеопределенности на этом уровне.
Подсказка
Если вы обнаружите, что вызываете метод Resolve с конкретным именем илдентификатором, подумайте над тем, сможете ли вы сменить свой подход на менееопределенный.
Именованные регистрации можно использовать для осуществления выбора средескольких экземпляров при конфигурировании зависимостей данного сервиса.
Конфигурирова ние именованных зависимостей
Иногда бывает необходимо переопределить обычное поведение для того, чтоббеспечить более разветвленный контроль над тем, куда какая зависимость отправляется.
Кроме того, возможны ситуации, при которых приходится сталкиваться еопределенным API. В качестве примера рассмотрим следующий конструктор:
public ThreeCourseMeal(ICourse entree,
ICourse mainCourse, ICourse dessert)
В этом примере присутствуют три одинаковым образом типизированных зависимостиаждая из которых является отдельной, не похожей на другие сущностью. В большинствлучаев необходимо преобразовывать каждую из этих зависимостей в отдельный тип. В
следующем листинге продемонстрированы способы конфигурации преобразований
ICourse.
Листинг 14-9: Регистрация именованных coursontainer.RegisterType<ICourse, Rillettes>("entree");
container.RegisterType<ICourse, CordonBleu>("mainCourse");
container.RegisterType<ICourse, MousseAuChocolat>("dessert");
Как вы уже делали это в листинге 14-8, вы регистрируете три именованных компонентареобразуя Rilettes в экземпляр под названием "entree", CordonBleu – в экземпляр менем "mainCourse", а MousseAuChocolat – в экземпляр под названием "dessert".
Принимая во внимание эти регистрации, теперь вы можете зарегистрировать класс
ThreeCourseMeal так, как это продемонстрировано в следующем листинге.
Листинг 14-10: Переопределение механизма автоматической интеграциontainer.RegisterType<IMeal, ThreeCourseMeal>(
new InjectionConstructor(
new ResolvedParameter<ICourse>("entree")ew ResolvedParameter<ICourse>("mainCourse")ew ResolvedParameter<ICourse>("dessert")));
565
До этого момента мы еще не обсуждали подробно тот факт, что все перегрузки метода
RegisterType принимают в качестве параметра массив объектов класса InjectionMember.
InjectionMember – это стратегия, которую Unity использует в качестве инструкции промпоновке типов друг с другом. Например, InjectionConstructor позволяет определятараметры, используемые для паттерна Constructor Injection.
Один из способов переопределения механизма автоматической интеграции – задание его омощью массива экземпляров ResolvedParameter. Каждый ResolvedParameteпределяет тип, который необходимо разрешить, а также необязательное имя – это имменованной регистрации, а не имя аргумента конструктора. ResolvedParameter entreбозначает регистрацию entree. Параметры конструктора заполняются позиционныпособом, т.е. первый ResolvedParameter соответствует первому аргументу конструктор т.д.
Примечание
В отличие от большинства остальных DI-контейнеров, позиционная стратегия позволяеонтейнеру Unity оставаться стабильным при столкновении с такими формамефакторинга, как изменение имени аргументов конструктора. С другой стороны, если мереставим местами аргументы конструктора, то все рухнет. Другие DI-контейнеры могу этим справиться.
Переопределение автоматической интеграции посредством явного преобразованиараметров в именованные компоненты – общепринятый подход. Делать это можно дажесли именованные компоненты конфигурируются в одном расширении контейнера, отребитель – в совершенно другом расширении, поскольку единственнадентификация, связывающая именованный компонент с параметром – это имя. Этозможно, но если нам приходится управлять множеством имен, такой подход являетсовольно хрупким. Когда основной причиной, побуждающей нас использоватменованные компоненты, является неопределенность, наилучшее решение –
сконструировать свое собственное API, помогающее избавиться от этоеопределенности. Все это также приводит к лучшей конструкции в целом.
В следующем разделе вы увидите, как можно использовать менее неопределенный и болеибкий подход, при котором разрешается использовать в обеде несколько блюд. Теперы должны изучить то, как Unity работает со списками и последовательностями.
Интеграция последовательностей
В разделе 10.3.2 "Разработка пользовательского стиля существования" мы обсуждали, каыполнить рефакторинг явного класса ThreeCourseMeal к более универсальному классу
Meal, который обладает приведенным ниже конструктором:
public Meal(IEnumerable<ICourse> courses)
В этом разделе мы рассмотрим то, как можно сконфигурировать Unity, чтобы онтегрировал экземпляры Meal с соответствующими зависимостями ICourse. Послассмотрения этого вопроса вы должны будете приобрести хорошее понимание теозможностей, которые доступны в случае необходимости конфигурированикземпляров, имеющих последовательности зависимостей.
566
Автоматическая инте грация последовательностей
Unity довольно хорошо разбирается в массивах, но не в других видаоследовательностей, например, IEnumerable<T> или IList<T>. Для эффективной работ последовательностями мы должны определить или преобразовать их в массивы, чтобы
Unity мог работать с ними соответствующим образом.
Если вы попытаетесь зарегистрировать Meal, не сообщая при этом контейнеру о том, каму следует работать с зависимостью IEnumerable<ICourse>, то при попытке разрешить
IMeal будет выдаваться исключение:
container.RegisterType<IMeal, Meal>();
var meal = container.Resolve<IMeal>();
При разрешении IMeal выдается исключение, потому что Unity не знает, как нужназрешать IEnumerable<ICourse>. Т ак произойдет, даже если вы перед этиарегистрируете несколько компонентов ICourse, как вы и поступали в листинге 14-9.
Чтобы преобразовать все именованные регистрации ICourse в IEnumerable<ICourse>ожно воспользоваться преимуществами врожденного понимания контейнером Unitассивов. Самый простой способ сделать это – преобразовать два приведенных нижипа:
container.RegisterType<IEnumerable<ICourse>, ICourse[]>();
Это может показаться слегка странным, но зато такой подход достаточно хорошаботает. Всякий раз, когда Unity сталкивается с зависимостью IEnumerable<ICourse>, ореобразует ее в запрос массива экземпляров ICourse, что даст нам такой же самыезультат, как если бы мы вызвали container.ResolveAll<ICourse>().
Примечание
Unity разрешает массивы подобно тому, как он возвращает результат метода ResolveAll.
Возвращаются все запрашиваемые именованные компоненты, но не компонент пмолчанию.
После выполнения такого преобразования в результате разрешения IMeal возвращаетсорректный результат: экземпляр Meal с экземплярами ICourse из листинга 14-9:
Rillettes, CordonBleu и MousseAuChocolat.
Unity управляет массивами сообразно тому, как он реализует ResolveAll. Но вот кааботать с остальными видами последовательностей, он не знает, поэтому мы должнреобразовать их в массивы, чтобы заставить Unity их понимать. В результате молучим все зарегистрированные компоненты данного типа, и этого чаще всего бываеостаточно. Только когда нам нужно из большого набора компонентов явно отобратолько несколько из них, нам необходимо выполнить больше действий. Это возможнлагодаря более явной конфигурации.
О тбор нескольких компонентов из большого набора
Когда мы используем способность Unity разрешать массивы, все именованныомпоненты внедряются в потребителей. Чаще всего это корректная линия поведения, но,
567
как показывает рисунок 14-7, возможны случаи, когда нам необходимо отобрать толькесколько компонентов из большого набора всех зарегистрированных компонентов.
Рисунок 14-7: В ситуации, продемонстрированной слева, мы хотим явным образотобрать определенные зависимости из большого списка всех зарегистрированныомпонентов. Это отличается от ситуации, приведенной справа, когда мы отбираем всез разбора.
Когда мы ранее позволяли Unity автоматически интегрировать все сконфигурированныкземпляр ы, это соответствовало бы ситуации, изображенной в правой части рисунка 14-
7. Если нам нужно сконфигурировать экземпляр так, как изображено в левой частисунка, то мы должны явно определить, какие экземпляры необходимо использовать.
В листинге 14-10 вы использовали класс InjectionConstructor для того, чтобпределить вместо стратегии автоматической интеграции, используемой по умолчаниюругую стратегию. Когда дело касается класса Meal, вы можете сделать то же самое динственной лишь разницей, что теперь вместо трех отдельных аргументов ICoursнедряется зависимость IEnumerable<ICourse>. Следующий листинг демонстрирует, каконфигурировать явный массив с помощью InjectionConstructor.
Листинг 14-11: Внедрение именованных компонентов в последовательностontainer.RegisterType<IMeal, Meal>(
new InjectionConstructor(
new ResolvedArrayParameter<ICourse>(
new ResolvedParameter<ICourse>("entree")ew ResolvedParameter<ICourse>("mainCourse")ew ResolvedParameter<ICourse>("dessert"))));
Чтобы переопределить механизм автоматической интеграции и явным образом задаттратегию внедрения зависимостей в конструктор Meal, вы еще раз обращаетесь к классу
InjectionConstructor. Поскольку для конструктора Meal нужен IEnumerable<ICourse>,
568
вы можете воспользоваться экземпляром ResolvedArrayParameter<ICourse> длпределения массива, который будет вычисляться при разрешении контейнером класса
Meal. Класс ResolvedArrayParameter<ICourse> определяет стратегию, при которонализ массива экземпляров ICourse откладывается до тех пор, пока не разрешится сам
Meal.
Чтобы определить значения, которые будут использоваться при разрешении Meal, можнспользовать три именованных экземпляра ResolvedParameter<ICourse>, как вы ужелали в листинге 14-10. Единственное отличие – теперь они используются в качествргументов для конструктора ResolvedArrayParameter<ICourse> вместо того, чтобспользоваться напрямую в InjectionConstructor. При разрешении IMeal
ResolvedArrayParameter<ICourse> разрешает три именованных регистрации entree ainCourse и dessert, а также создает массив ICourse из этих трех компонентов.
Поскольку ICourse[] реализует IEnumerable<ICourse>, может подойти конструктор
Meal.
В очередной раз вы видите, что контейнер Unity отлично понимает массивы. Несмотря но, что он не поддерживает остальные виды последовательнос тей, это ограничение можнбойти путем преобразования зависимостей в массивы.
Потребители, которые полагаются на последовательности зависимостей, могут бытамым интуитивно понятным применением составных экземпляров одной и той жбстракции. Но перед тем как мы полностью отойдем от данной темы, нам необходимассмотреть последний (и, возможно, слегка неожиданный) случай, когда в дело вступаюоставные экземпляры.
Интеграция Decorator'ов
В разделе 9.1.2 "Паттерны и принципы механизма перехвата" мы обсуждали то, насколькаттерн проектирования Decorator полезен при реализации сквозных сущностей. Ппределению Decorator'ы представляют собой составные типы одной и той же абстракции.
У нас есть, по крайней мере, две реализации абстракции: сам Decorator и вложенный его тип. Если бы мы помещали Decorator'ы в стек, то у нас было бы еще большеализаций.
Это еще один пример составных регистраций одного и того же сервиса. В отличие оредыдущих разделов эти регистрации не являются концептуально равносильными, ависят друг от друга. В следующем разделе я продемонстрирую вам два разных способонфигурирования Unity для работы с данным паттерном.
С оздание обертки для именованного компонента
Класс Breading – это обертка IIngredient. Этот класс использует паттерн Constructor
Injection для получения того экземпляра, который ему необходимо обернуть:
public Breading(IIngredient ingredient)
Чтобы получить Cotoletta, вам необходимо будет вложить VealCutlet (еще один
IIngredient) в класс Breading. Поскольку вы уже знаете, как соединить именованныомпоненты с аргументами конструктора, было бы вполне естественным сделать что-тналогичное в следующем листинге.
569
Листинг 14-12: Создание обертки с помощью именованного компонентontainer.RegisterType<IIngredient, VealCutlet>("cutlet");
container.RegisterType<IIngredient, Breading>(
new InjectionConstructor(
new ResolvedParameter<IIngredient>("cutlet")));
Компонент Breading по умолчанию должен иметь тип IIngredient, поэтому вам нужнрисвоить VealCutlet имя IIngredient, поскольку по умолчанию IIngredient должеыть только один. При регистрации компонента Breading вы еще раз используете
InjectionConstructor, чтобы указать, как контейнер Unity должен интегрироватргумент конструктора ingredient класса Breading. ResolvedParameter<IIngredient>
позволяет вам указать, что должен разрешаться именно первый параметр конструктора (олько он) и интегрироваться с именованным компонентом cutlet.
При разрешении IIngredient вы получаете экземпляр Breading, в который вложен
VealCutlet.
Это общепринятый способ создания обертки для компонента, но в случае, когда нам нужны вложенные компоненты, мы можем использовать более неявный метод.
С оздание обертки для конкретного компонента
Если нам никогда не нужно будет напрямую разрешать вложенный компонент, мы можеспользовать более неявный способ создания для него обертки. Представьте себе, что ваикогда не придется разрешать VealCutlet напрямую в виде IIngredient. В тех случаяхогда вам нужен будет IIngredient, вам всегда хотелось бы получать Cotoletta.
В таком случае вообще нет никакой необходимости конфигурировать VealCutlet. Вместтого вы можете воспользоваться преимуществами того факта, что Unity автоматическазрешает конкретные типы, даже если они не зарегистрированы:
container.RegisterType<IIngredient, Breading>(
new InjectionConstructor(
new ResolvedParameter<VealCutlet>()));
Вы уже знаете, что вам нужно внедрить в экземпляр Breading именно VealCutletоэтому нет причин для неявного определения ResolvedParameter<IIngredient>, когды можете напрямую передать ResolvedParameter<VealCutlet>. Когда вы отправитапрос контейнеру на разрешение IIngredient, ResolvedParameter<VealCutlet> будевтоматически разрешен в экземпляр VealCutlet, поскольку это конкретный класс. В
связи с тем, что VealCutlet реализует IIngredient, он нам подходит.
Несмотря на то, что вы не регистрировали компонент VealCutlet, вы все еще можете этделать, если вам необходимо сконфигурировать другие аспекты, например, его стилуществования:
container.RegisterType<VealCutlet>(
new ContainerControlledLifetimeManager());
container.RegisterType<IIngredient, Breading>(
new InjectionConstructor(
new ResolvedParameter<VealCutlet>()));
570
В этом примере вы конфигурируете конкретный VealCutlet в виде Singleton, нооскольку вы не планируете разрешать его в виде IIngredient, вы не преобразуете его нтерфейс. Все это превращает его в VealCutlet по умолчанию, а затем
ResolvedParameter<VealCutlet> сможет должным образом его разрешить.
Как вы уже видели в этом разделе, при конфигурировании Decorator'ов существуеесколько возможных вариантов. Во всех этих вариантах используется класс
InjectionConstructor. В отличие от Castle Windsor контейнер Unity не поддерживает
Decorator'ы явным образом, что может быть немного удивительным, поскольку подобно
Windsor контейнер Unity максимально поддерживает паттерн Decorator: в виде механизмерехвата.
Создание перехватчиков
В разделе 9.3.3 "Пример: перехват с помощью Windsor" вы видели пример того, каобавить в WCF-приложение обработчик ошибок и Circuit Breaker с помощьозможности динамического перехвата, предлагаемой Castle Windsor. В этом разделе мделаем то же самое с помощью Unity.
Как показано на рисунке 14-8, добавление аспекта в Unity – процесс, включающий в себесколько шагов.
Рисунок 14-8: Шаги, которые включает в себя процесс добавления аспекта в Unity
Основная часть работы заключается в разработке самого перехватчика, но после егоздания мы должны добавить этот перехватчик в контейнер. Механизм перехвата – этасширение контейнера Unity, поэтому мы должны добавить это расширение и онтейнер, чтобы все это работало.
В этом разделе мы будем сначала создавать перехватчики для обработчика ошибок и
Circuit Breaker, а в конце сконфигурируем контейнер с помощью этих перехватчиков.
Реализация перехватчика обработчика исключений
Реализация перехватчика для контейнера Unity требует от нас реализации интерфейса
IInterceptionBehavior. Листинг 14-13 демонстрирует, как реализовать стратегибработки исключений, приведенную в главе 9. Эта конкретная реализация стратегии длонтейнера Unity соответствует листингу 9-8, который приводился при описании Castle
Windsor, и листингу 12-4, который приводился при описании Spring.NET.
571
Листинг 14-13: Реализация интерфейса IInterceptionBehavior, предназначенного длбработки исключений.
1. public class ErrorHandlingInterceptionBehavior :
2. IInterceptionBehavior
3. {
4. public IEnumerable<Type> GetRequiredInterfaces()
5. {
6. return Type.EmptyTypes;
7. }
8. public bool WillExecute
9. {
10. get { return true; }
11. }
12. public IMethodReturn Invoke(
13. IMethodInvocation input,
14. GetNextInterceptionBehaviorDelegate getNext)
15. {
16. var result = getNext()(input, getNext);
17. if (result.Exception is CommunicationException
18. || result.Exception is
19. InvalidOperationException)
20. {
21. this.AlertUser(result.Exception.Message);
22. return input.CreateMethodReturn(null);
23. }
24. return result;
25. }
26. private void AlertUser(string message)
27. {
28. var sb = new StringBuilder();
29. sb.AppendLine("An error occurred.");
30. sb.AppendLine("Your work is likely lost.");
31. sb.AppendLine("Please try again later.");
32. sb.AppendLine();
33. sb.AppendLine(message);
34. MessageBox.Show(sb.ToString(), "Error",
35. MessageBoxButton.OK,
36. MessageBoxImage.Error);
37. }
38. }
Строка 4-7: Передача интерфейсов
Строка 8-11: Подключение перехватчика
Строка 12-14: Реализация логики перехвата
Строка 16: Получение результата из вложенного объекта
Строка 17-22: Обработка исключений
Класс ErrorHandlingInterceptionBehavior реализует IInterceptionBehavior, которывляется интерфейсом с тремя членами. Двое из этих членов, в основном, относятся нфраструктуре Unity, и реализовать их довольно легко. Метод GetRequiredInterfaceозволяет нам указать, к каким интерфейсам обращается этот перехватчик, но возвращаустой массив, вы можете отложить принятие решения до того момента, когда вы будетонфигурировать, какие компоненты собираетесь перехватывать. Свойство WillExecutолжно возвращать true, если вы хотите, чтобы перехватчик работал. Это дает нам
572
возможность сконфигурировать, должен ли выполняться конкретный перехватчик. Но том примере вы хотите всегда выполнять ErrorHandlingInterceptionBehavior, если оконфигурирован для компонента.
Основная реализация IInterceptionBehavior выполняется в методе Invoke, которыызывается (так!) контейнером Unity при вызове перехватываемого компонента. Параметnput содержит некоторую информацию о текущем вызове метода, тогда как параметetNext содержит делегат, который можно использовать для вызова вложенногомпонента. Это приблизительно соответствует методу Procced, который используется в
Castle Windsor и продемонстрирован в листинге 9-8.
Вызов метода getNext дает вам метод Invoke, представляющий собой метод, которыложен в перехватчика. Это может быть другой перехватчик или сам вложенныомпонент. Вызывая этот метод Invoke с первоначальными параметрами, вы получаетезультат вложенного метода.
Если метод возвращает одно из тех исключений, которые необходимо обработать, то вредупреждаете об этом пользователя путем вывода на экран диалогового окна. В случаолучения обрабатываемого исключения вам хотелось бы пресечь его сразу же послого, как вы предупредите пользователя. Если бы вложенный метод возвращал result, тто позволило бы исключению распространиться, поэтому вместо этого вы создаете новоозвращаемое значение и возвращаете его. В противном случае при отсутствисключений вы вернули бы result из вложенного метода.
ErrorHandlingInterceptionBehavior обрабатывает определенные исключениложенного компонента. В роли этого компонента может выступать перехватчик в форме
Circuit Breaker.
Реализация Circuit Breaker перехватчика
Circuit Breaker перехватчик – слегка более сложный перехватчик, поскольку для негеобходима зависимость ICircuitBreaker. Но как демонстрирует следующий листингы решаем эту проблему путем применения стандартного паттерна Constructor Injection.
Когда дело доходит до компоновки класса, контейнер Unity выполняет ее так же, как юбой другой компонент: пока он может разрешать зависимость, все идет нормально.
Листинг 14-14: Реализация IInterceptionBehavior в виде Circuit Breaker
1. public class CircuitBreakerInteceptionBehavior :
2. IInterceptionBehavior
3. {
4. private readonly ICircuitBreaker breaker;
5. public CircuitBreakerInteceptionBehavior(
6. ICircuitBreaker breaker)
7. {
8. if (breaker == null)
9. {
10. throw new ArgumentNullException("breaker");
11. }
12. this.breaker = breaker;
13. }
14. public IMethodReturn Invoke(IMethodInvocation input,
15. GetNextInterceptionBehaviorDelegate getNext)
16. {
17. try
573
18. {
19. this.breaker.Guard();
20. }
21. catch (InvalidOperationException e)
22. {
23. return
24. input.CreateExceptionMethodReturn(e);
25. }
26. var result = getNext()(input, getNext);
27. if (result.Exception != null)
28. {
29. this.breaker.Trip(result.Exception);
30. }
31. else
32. {
33. this.breaker.Succeed();
34. }
35. return result;
36. }
37. public IEnumerable<Type> GetRequiredInterfaces()
38. {
39. return Type.EmptyTypes;
40. }
41. public bool WillExecute
42. {
43. get { return true; }
44. }
45. }
Строка 17-25: Реализация граничного оператора
Строка 26: Возвращение result из вложенного метода
Строка 27-30: Обработка исключения
Строка 31-34: Обозначение успешного выполнения
Строка 37-44: Необходимые данные для IInterceptionBehavior
CircuitBreakerInteceptionBehavior должен делегировать свою реализацию экземпляру
ICircuitBreaker. Поскольку Unity, как и любой другой компонент, будет автоматическнтегрировать перехватчик, для внедрения ICircuitBreaker можно воспользоватьстандартным паттерном Constructor Injection.
В методе Invoke вам необходимо реализовать идиоматическое выражение Guard-
Succeed/Trip, которое вы уже видели в листингах 9-4 и 9-9. Для начала вам необходимызвать метод Guard, и вернуть исключение, если этот метод возвращает исключение.
Unity предполагает, что вы будете передавать исключения не посредством вывода их, утем инкапсуляции их в экземпляры IMethodReturn. Поэтому вы должны явным образоерехватывать InvalidOperationException и из перехваченного исключения создаватозвращаемое значение.
Если метод Guard уже выполнился, то вы можете приступить к вызову вложенногетода. Делается это точно так же, как вы делали это в листинге 14-13. После получениesult из вложенного метода можно проанализировать это значение, чтобы определитье было ли возвращено исключение. Если это так, то с помощью метода Trip вы
574
устанавливаете прерыватель, но, обратите внимание на то, что при этом вы не изменяетesult. Не забудьте о том, что после вызова метода Trip все равно необходимо выдаватсключение, поэтому result вы можете оставить неизмененным – он уже инкапсулируесключение.
При отсутствии исключений вы можете аналогичным образом указать на этрерывателю, вызвав метод Succeed. Не забудьте о том, что это может привести акрытию другого открытого прерывателя.
После реализации ErrorHandlingInterceptionBehavior и
CircuitBreakerInteceptionBehavior настает время для того, чтобы сконфигурироватонтейнер таким образом, чтобы ErrorHandlingInterceptionBehavior и
CircuitBreakerInteceptionBehavior стали обертками для IProductManagementAgent.
Конфигурирова ние механизма перехвата
Все, что нам необходимо сделать, – перехватить компонент IProductManagementAgent омощью Circuit Breaker и механизма обработки ошибок таким образом, чтобы прозникновении исключений во время взаимодействия с веб-сервисом открывался Circuit
Breaker и обрабатывалось исключение. Это дает приложению возможностосстанавливаться при каждом последующем подключении веб-сервиса или сети.
Сначала нам необходимо добавить в контейнер Unity возможность поддержки механизмерехвата. Несмотря на то, что механизм перехвата является частью модуля приложенионтейнера Unity, реализуется он в отдельной сборке и, поэтому его необходимобавлять явным образом.
Примечание
Чтобы иметь возможность использовать механизм перехвата в рамках контейнера Unityеобходимо добавить ссылку на сборку
Microsoft.Practices.Unity.InterceptionExtension.
После добавления ссылки на сборку
Microsoft.Practices.Unity.InterceptionExtension необходимо добавить в контейнеасширение Interception. Это всего лишь еще одно расширение контейнера, поэтомобавить его можно с помощью метода AddNewExtension:
container.AddNewExtension<Interception>();
Несмотря на то, что приведенный код в принципе позволяет добавить в контейнеозможность использования механизма перехвата, нам все равно нужно добавить омпонент IProductManagementAgent необходимые перехватчики. На рисунке 14-9
продемонстрирована та конфигурация, к которой мы стремимся.
Рисунок 14-9: IProductManagementAgent должен быть вложен в Circuit Breakeерехватчик таким образом, чтобы при выдаче агентом исключения на некоторое времткрывался цикл. Circuit Breaker не управляет исключениями, а всего лишь регистрируех. Поэтому за управление исключениями отвечает перехватчик обработки ошибокоторый должен располагаться как можно дальше для того, чтобы иметь возможностправлять исключениями, получаемыми как от агента, так и от Circuit Breaker.
575
При конфигурировании механизма перехвата для компонента используется тот факт, чтсе перегрузки метода RegisterType принимают в качестве параметра массив объектов
InjectionMember. До настоящего момента вы использовали только класс
InjectionConstructor, но для конфигурирования механизма перехвата можнспользовать совокупность и других классов:
container.RegisterType<IProductManagementAgent,
?WcfProductManagementAgent>(
new Interceptor<InterfaceInterceptor>()ew InterceptionBehavior<ErrorHandlingInterceptionBehavior>()ew InterceptionBehavior<CircuitBreakerInteceptionBehavior>());
Разобъем этот код на составляющие части. Сначала вы добавляете
Interceptor<InterfaceInterceptor>. Это InjectionMember, который сообщает Unity ом, что далее следуют один или несколько InterceptionBehavior, которые выполняюерехват на уровне инетрфейса (в противоположность, например, перехвату виртуальныленов).
Следующие два InjectionMember добавляют реализованные вами перехватчики
ErrorHandlingInterceptionBehavior и CircuitBreakerInteceptionBehavior. Обратитнимание, что, поскольку вы сначала указываете ErrorHandlingInterceptionBehaviorн становится самым дальним перехватчиком и, в свою очередь, перехватывает
CircuitBreakerInteceptionBehavior.
В конце этого примера кода вам необходимо убедиться, что выполнены требования всеависимостей. Поскольку для CircuitBreakerInteceptionBehavior необходим
ICircuitBreaker, вы должны зарегистрировать этот компонент:
container.RegisterType<ICircuitBreaker, CircuitBreaker>(
new ContainerControlledLifetimeManager()ew InjectionConstructor(TimeSpan.FromMinutes(1)));
Для обеспечения эффективности важно, чтобы в коде присутствовал только одикземпляр Circuit Breaker (хотя бы по одному на каждый внешний ресурс), поэтому мегистрируем его как Singleton. Кроме того, для конструктора CircuitBreaker мы задаедноминутную задержку, чтобы гарантировать, что приложению разрешаетсосстанавливать прерванное подключение один раз в минуту.
Этот раздел продемонстрировал, как можно применять механизм динамическогерехвата в рамках контейнера Unity. Лично я считаю, что сложность использования
576
механизма перехвата в рамках Unity сравнима с поддержкой этого механизмонтейнерами Castle Windsor и Spring.NET. Несмотря на то, что это применение нвляется полностью тривиальным, пользу оно приносит колоссальну ю.
Механизм перехвата – это динамическая реализация паттерна Decorator, а паттерн
Decorator сам по себе является совместным применением составных компонентов одног того же типа. Контейнер Unity позволяет нам использовать различные подходы пработе с составными компонентами. Мы можем регистрировать компоненты в видльтернатив друг другу, в виде пиров, которые разрешаются в виде последовательностей виде иерархических Decorator'ов или даже в виде перехватчиков. Что касается массивово тут Unity сам поймет, как ему поступать дальше, а остальные типоследовательностей мы можем преобразовывать в массивы. Это также позволяет навным образом определять способ компоновки сервисов в случае, когда нам нужен болевный контроль.
Кроме того, это может происходить в ситуации, когда нам нужно иметь дело с APIтклоняющимися от Constructor Injection. До настоящего момента вы наблюдали за темак конфигурировать экземпляры, включая то, как определять стили существования и кааботать с составными компонентами. Но до этого момента мы позволяли контейнеродключать зависимости, явным образом предполагая, что все компоненты используют
Constructor Injection. Поскольку это не всегда происходит именно так, в следующеазделе мы сделаем краткий обзор того, как работать с классами, экземпляры которыолжны создаваться особым образом.
577
14.4. Конфигурирование сложных API
До настоящего момента мы рассматривали то, как можно конфигурировать компонентыспользующие Constructor Injection. Одним из главных преимуществ Constructor Injectioвляется то, что DI-контейнеры, например, Unity, могут с легкостью понимать, каомпоновать и создавать все классы диаграммы зависимостей.
Все становится менее понятным, когда API не столь хорошо функционируют. В этоазделе вы увидите, как работать с простейшими аргументами конструкторататическими фабриками и Property Injection. Все это требует особого внимания. Начнем ассмотрения классов, конструкторы которых принимают в качестве параметроростейшие типы, например, строки и целые числа.
Конфигурирование простейших зависимостей
Пока мы внедряем абстракции в потребителей, все в порядке. Но данный процессложняется, если конструктор зависит от простейшего типа, например, строковогоислового или перечисляемого. Наиболее часто это случается в реализациях доступа анным, которые принимают в качестве параметра конструктора строку соединения. Но о же время это является более общей проблемой, касающейся всех строковых и числовыипов.
В сущности, регистрация строкового или числового типа в качестве компонентонтейнера не имеет особого смысла. Но в рамках Unity это, по крайней мересуществимо.
Рассмотрим в качестве примера приведенный ниже конструктор:
public ChiliConCarne(Spiciness spiciness)
В этом примере Spiciness имеет перечисляемый тип:
public enum Spiciness
{
Mild = 0,
Medium,
Hot
}
Предупреждение
Согласно эмпирическому правилу перечисления являются code smell'ами и их нужнреобразовывать в полиморфные классы (имеющие разное состояние). Тем не менее, дланного примера они вполне нам подходят.
Если вы хотите, чтобы все потребители Spiciness использовали одно и то же значениеожно зарегистрировать Spiciness и ChiliConCarne независимо друг от друга:
container.RegisterInstance(Spiciness.Medium);
container.RegisterType<ICourse, ChiliConCarne>();
578
Когда вы впоследствии будете разрешать ChiliConCarne, его Spiciness будет иметначение Medium, как и все остальные компоненты, зависимые от Spiciness.
Если вы будете достаточным образом контролировать взаимосвязь Spiciness и
ChiliConCarne, то сможете таким же образом поступить и с вездесущим
InjectionConstructor, передав значение в конструктор:
container.RegisterType<ICourse, ChiliConCarne>(
new InjectionConstructor(Spiciness.Hot));
Ранее в этой главе InjectionConstructor в основном использовался с
ResolvedParameter<T>, но можно поступить и по-другому: передать значение, котороатем будет передано прямо в конструктор компонента. В приведенном примере вередаете значение Spiciness.Hot, которое затем будет передано прямо в конструктор
ChiliConCarne, возвращая значение Hot.
Оба описанных здесь варианта стимулируют автоматическую интеграцию нредоставление конкретного значения для компонента. Если вам нужна более строгипизированная конфигурация, которая вызывает конструктор или статическую фабрикуы также сможете это сделать.
Регистрация компонентов с помощью блоков кода
Еще один вариант создания компонента с примитивным значением – использовать ещдин InjectionMember, позволяющий передавать делегат, который создает компонент:
container.RegisterType<ICourse, ChiliConCarne>(
new InjectionFactory(
c => new ChiliConCarne(Spiciness.Hot)));
InjectionFactory – это еще один класс, унаследованный от абстрактного класса
InjectionMember. Он обладает двумя перегруженными конструкторами, но мспользуем самый простой из них, который в качестве входных данных принимает
Func<IUnityContainer, object>. Это дает нам возможность определить блок кода, омощью которого будет создаваться компонент. В этом примере всякий раз празрешении компонента ICourse будет вызываться конструктор ChiliConCarne араметром Spiciness.Hot.
Примечание
Блок кода, приведенный в примере выше, полностью идентичен соответствующему блокода, приведенному для контейнера Autofac в разделе 13.4.2 "Регистрация объектов омощью блоков кода".
Когда дело касается класса ChiliConCarne, вам предоставляется выбор междвтоматической интеграцией и использованием блока кода. Но другие классы болеграничены: их экземпляры нельзя создать с помощью открытого конструктора. Чтобоздать экземпляры типа, вместо открытого конструктора вам приходится использоватекоторого рода фабрику. Для DI-контейнеров это всегда проблематично, поскольку пмолчанию им нужны открытые конструкторы.
Рассмотрим приведенный ниже пример конструктора открытого класса JunkFood:
579
internal JunkFood(string name)
Даже если класс JunkFood является открытым, конструктор расположен внутри него.
Очевидно, экземпляры JunkFood должны создаваться с помощью статического класса
JunkFoodFactory:
public static class JunkFoodFactory
{
public static IMeal Create(string name)
{
return new JunkFood(name);
}
}
С точки зрения Unity, это проблемное API, поскольку в нем отсутствуют точныраженные и заданные соглашения касательно статических фабрик. Тут требуетсомощь – и мы можем предоставить ее посредством блока кода, который Autofac можесполнять для того, чтобы создать экземпляр:
container.RegisterType<IMeal, JunkFood>(
new InjectionFactory(
c => JunkFoodFactory.Create("chicken meal")));
В этот раз вы используете класс InjectionFactory для создания компонента, вызывататическую фабрику в рамках блока кода. Всякий раз при разрешении IMeal будеызываться JunkFoodFactory.Create и возвращаться результат.
Является ли написание блока кода для создания экземпляра лучшим вариантом, нежелрямой вызов кода? При использовании блока кода внутри конструктора
InjectionFactory мы приобретаем следующие преимущества:
? IMeal преобразуется в JunkFood.
? Стиль существования остается доступным для конфигурирования. Несмотря на тото для создания экземпляра вызывается блок кода, он может и не вызыватьссякий раз при запросе экземпляра. По умолчанию он вызывается, но если мзменим стиль существования на Singleton, то блок кода будет вызываться толькдин раз, а результат будет кэшироваться и впоследствии повторно использоваться.
Последним рассматриваемым нами отклонением от Constructor Injection является Property
Injection.
Интегрирование с помощью Property Injection
Property Injection – это менее определенная форма механизма внедрения зависимостейоскольку компилятор не принудает нас задавать значение свойства, доступного длаписи. Это касается и Unity, который будет оставлять доступные для записи свойствезаполненными до тех пор, пока мы явно не попросим его заполнить их.
Рассмотрим класс CaesarSalad:
public class CaesarSalad : ICourse
{
public IIngredient Extra { get; set; }
}
580
По всеобщему заблуждению в состав салата "Цезарь" входит курица. По своей сути
"Цезарь" является салатом, но, поскольку с курицей он вкуснее, то ее часто предлагаюспользовать в нем в качестве дополнительного ингредиента. Класс CaesarSalaоделирует такую возможность посредством доступного для записи свойства поазванием Extra.
Если вы конфигурируете только класс CaesarSalad, явно не обращаясь к свойству Extraо этому свойству не будет присвоено значение. Вы все равно можете разрешаткземпляр, но свойство Extra будет иметь значение по умолчанию, которое ему присвоионструктор (если только это имеет место).
Помимо этого, чтобы присвоить значение свойству, вы можете использовать
InjectionMember:
container.RegisterType<IIngredient, Chicken>();
container.RegisterType<ICourse, CaesarSalad>(
new InjectionProperty("Extra"));
Точно так же, как вы можете использовать класс InjectionConstructor длонфигурирования Constructor Injection, вы можете использовать класс
InjectionProperty для конфигурирования Property Injection. InjectionProperty – этще один класс, унаследованный от InjectionMember. Чтобы его использовать, волжны указать имя того свойства, которое необходимо заполнить. В этом примере вобираетесь заполнить свойство Extra. Это приведет к автоматической интеграцивойства, поэтому очень важно, чтобы Unity умел разрешать этот тип. Свойство Extrмеет тип IIngredient, поэтому Unity разрешит это свойство в Chicken благодаря томуто ранее вы зарегистрировали Chicken как IIngredient.
Предупреждение
Если для свойства задается паттерн Property Injection, то Unity должен уметь разрешатип этого свойства. Если он не сможет это сделать, то при попытке разрешения такогипа будет возникать исключение.
Когда вы на основании этой регистрации разрешаете ICourse, вы получаете экземпляр
CaesarSalad, свойству Extra которого присвоен экземпляр Chicken.
В предыдущем примере использовался IIngredient по умолчанию, но для того чтобрисвоить значение свойству, мы можем использовать и другую перегрузку класса
InjectionProperty. Мы можем присвоить ему непосредственное значение или можеоспользоваться проверенным классом ResolvedParameter<T>, чтобы сослаться нменованный компонент:
container.RegisterType<IIngredient, Chicken>("chicken");
container.RegisterType<IIngredient, Steak>("steak");
container.RegisterType<ICourse, CaesarSalad>(
new InjectionProperty("Extra"ew ResolvedParameter<IIngredient>("chicken")));
Экземпляр ResolvedParameter ссылается на ранее зарегистрированный компоненhicken, гарантируя, что при разрешении ICourse вы получите CaesarSalad, свойству
Extra которого присвоен экземпляр Chicken.
581
В этом разделе вы увидели, как можно использовать Unity для работы с более трудными
API разработки. Для указания конкретных экземпляров или блоков кода, которые будуспользоваться для создания экземпляро в, можно применять различные классынаследованные от InjectionMember, а также конфигурировать Property Injection. Я
считаю, что это API становится довольно простым для изучения, как только вы осознаетго смысл.
582
14.5. Резюме
Unity – это DI-контейнер, разрабатываемый группой Patterns&Practices компании
Microsoft. Несмотря на то, что он не является как таковым решением компании Microsoftногие организации, занимающиеся разработкой приложений, все еще считают егекоторого рода полуофициальным продуктом компании Microsoft. Теми компаниямиоторые строго соблюдают принцип использования только продуктов компании Microsoftтот факт может восприниматься как преимущество, поскольку в Unity часто входяодули приложений группы Patterns&Practices. Вторым фактором, влияющим на иыбор, является наличие официальной документации.
API, предлагаемое контейнером Unity, является постоянным, но, в отличие оольшинства других контейнеров, не гибким. Иногда это может приводить к усложненироверки, но как только вы поймете суть контейнера Unity, вы сможете оценить егостоянность: за исключением необязательных имен и LifetimeManager'ов, всальнейшая конфигурация выполняется с помощью классов, унаследованных обстрактного класса InjectionConstructor.
Помимо императивного API контейнер Unity также обладает комплексной XML-схемойоторая позволяет определять конфигурацию контейнера как в XML, так и в коде. С
другой стороны, он не поддерживает основанный на соглашениях механизвтоматической регистрации.
Unity – один из тех относительно немногих DI-контейнер'ов, которые поддерживаюеханизм перехвата. Эта поддержка обеспечивается за счет расширения основногонтейнера, но при этом является частью модуля приложений.
Одной из относительно слабых сторон контейнера Unity является механизм управлениизненным циклом. Несмотря на то, что встроенные стили существования кажутсполне достаточным набором стилей, управление ресурсами становится довольнрудным процессом, поскольку после прекращения использования компоненты нысвобождаются должным образом. К счастью, не все так уж плохо, поскольку мы можееализовать пользовательские стили существования, которые будут решать эти проблемы.
Получается, что управлять жизненными циклами в рамках контейнера Unity достаточнложно, но вполне возможно.
В общем Unity является довольно добротным DI-контейнер'ом. Он имеет свои слабытороны, но, с другой стороны, предоставляет довольно полный набор возможностей.
Единственная важная упущенная возможность – автоматическая регистрация, носкольку API контейнера Unity является открытым, при желании его можнсовершенствовать.
Эта глава познакомила нас с полуофициальным DI-контейнер'ом компании Microsoft. В
следующей главе мы рассмотрим контейнер, слегка отличающийся от контейнера Unity.
Некоторые вообще не считают его DI-контейнер'ом. С другой стороны, он входит в состатандартной библиотеки классов .NET 4 и имеет множество схожих с DI-контейнер'амерт. Поэтому стоит все-таки рассмотреть Managed Extensibility Framework (MEF –
управляемая платформа расширений).
583
15. MEF
Меню:
? Знакомство с MEF
? Управление жизненным циклом
? Работа с составными компонентами
? Конфигурирование сложных API
В пяти предыдущих главах вы наблюдали за тем, как можно использовать различные DI-
контейнер'ы в качестве средств реализации паттернов и принципов, описанных стальной части книги. В этой главе мы будем заниматься несколько другим, поскольку
Managed Extensibility Fram ework (MEF – управляемая платформа расширений) ействительности не является DI-контейнер'ом.
Судя по названию, MEF – это фреймворк, предназначенный для решения проблеасширяемости приложений. Целью MEF является подключение к стандартномриложению дополнительных сценариев. Вероятно, Visual Studio 2010 является самыервым и наиболее известным приложением, в котором MEF используется для поддержклагинов. Но с другой стороны, любое другое приложение, созданное на платформе .NET
4 или Silverlight 4, также может использовать MEF для раскрытия возможностеасширяемости.
Если MEF не является DI-контейнером, то почему тогда на ее рассмотрение мы выделилелую главу? Самая важная причина заключается в том, что MEF настолько похож на DI-
контейнер, что вы потратите уйму времени на то, чтобы разобраться, в чем же его отличит реального DI-контейнера. Поскольку он является частью .NET 4 или Silverlight 4озможно, использование его в качестве DI-контейнера было бы довольно заманчивымсли бы вы не понимали тонкой границы между ними. Цель этой главы – выявить этазличия для того, чтобы вы могли принять верное решение.
Примечание
Не забывайте, что если вам не интересен MEF и вы уже решили использовать другой DI-
контейнер, вы всегда можете пропустить эту главу.
Является ли MEF DI-контейнер'ом?
Вокруг того, является ли MEF DI-контейнером или нет, возникает слишком многутаницы. Если вкратце, то нет, MEF не является DI-контейнером, но у него настолькного общего с "настоящими" DI-контейнерами, что в будущем он может статолноценным DI-контейнером.
MEF не создавался как DI-контейнер. Его целью является предоставление универсальногреймворка для подключения дополнительной функциональности в стандартныриложения. С точки зрения стандартного приложения, расширение – это неизвестныомпонент. Несмотря на то, что расширение, по всей видимости, необходимо дласкрытия определенного интерфейса, это и есть все, что знает о нем приложение. В
зависимости от среды разработки в приложении могут присутствовать одно или несколькасширений, или же в приложение может не входить ни одного расширения. Эти MEF
584
отличается от DI-контейнера, в котором мы обычно на этапе компиляции бываесведомлены обо всех (или о большинстве) его компонентах.
Когда мы используем DI-контейнер в качестве инструмента для компоновки приложенияы точно знаем, из каких компонентов состоит приложение, и используем эти знания длого, чтобы сконфигурировать контейнер в Com position Root приложения.
С другой стороны, когда дело касается плагинов, мы знаем только о том, что плагинолжны реализовывать некоторого рода абстракцию, но не можем скомпилироватриложение, состоящее из конфигурации конкретных плагинов, поскольку на этапазработки они еще неизвестны. В этом случае нам необходим механизм, позволяющибнаруживать компоненты приложения.
Традиционный механизм обнаружения расширений заключается в просмотрпределенного каталога сборок с целью обнаружения всех классов, реализующиеобходимую абстракцию. Однако это не решает той проблемы, которая возникает, когд самого расширения есть зависимости. С другой стороны, MEF решает именно этроблему посредством расширенной модели обнаружения, которая для определениотребителей и их сервисов использует атрибуты.
DI-контейнер поддерживает раздельную компоновку сервисов. Такая возможностбеспечивает высокую степень гибкости, но является довольно затратной: будучазработчиками уже на этапе конфигурирования контейнера мы должны бытсведомлены о том, какие компоненты собираемся компоновать.
MEF поддерживает механизм обнаружения компонент ов. Такой подход успешно решаероблему, возникающу ю в ситуациях, когда на этапе проектирования мы почти ничего ннаем о расширениях. Компромисс заключается в том, что механизм обнаружениасширений сильно связан с компонентами, поэтому мы теряем некоторую гибкость.
При рассмотрении внутренней инфраструктуры MEF, оказывается, что процессбнаружения расширений и компоновки не связаны друг с другом. Это означает, чтомпания Microsoft может усовершенствовать MEF в направлении настоящего DI-
контейнера. С другой стороны, некоторые DI-контейнер'ы обладают столь огромныагажом основанных на соглашениях возможностей, что в будущем могут посягнуться на
MEF.
Даже на сегодняшний день MEF имеет столь много общего с DI-контейнерами, чтекоторые считают его DI-контейнером, а некоторые отвергают этот факт.
Подсказка
Если вы уже пытались использовать MEF в качестве DI-контейнера и были разочарован сбиты с толку, то эта глава объяснит вам, почему так произошло.
Несмотря на то, что, когда MEF зарождался и разрабатывался, возможностспользования его в качестве DI-контейнера не имела первостепенной важностиказывается, его все-таки можно использовать как DI-контейнер. Со временем это сталозможным, хотя и довольно затруднительным. Существует несколько сценариев, проторых имеет смысл использовать MEF в качестве DI-контейнера: в частности, риложениях, в которых он уже используется для реализации возможностеасширяемости приложения.
585
Примечание
Общая предпосылка этой главы (непреднамеренно) заключается в том, что использование
MEF не принесет нам успешного результата. Это не означает, что MEF делает что-то нак. Это означает, что мы пытаемся заставить MEF сделать то, для чего он нредназначен. Мы пытаемся сделать невозможное.
В этой главе мы рассмотрим, как можно использовать MEF для применения принципов аттернов, описанных в частях 1-3. На рисунке 15-1 продемонстрирована структура этолавы.
Рисунок 15-1: Эта глава состоит из четырех разделов. Первый раздел знакомит нас с MEF
и демонстрирует способы конфигурирования и разрешения компонентов. Следующие траздела связаны с паттернами применения, которые требуют дополнительного внимания.
Их можно прочитать по порядку или же пропустить некоторые из этих разделов рочитать только те, которые вас интересуют.
Структура главы является отражением структуры всех остальных глав части 4, поскольк считаю, что это облегчает сравнение различных DI-контейнеров. В случае с MEF этриводит к четырем неравноценным по размеру и важности разделам. Много времени мотратим на знакомство с MEF для того, чтобы получить полноценное понимание этогонтейнера и его API. На рассмотрение механизма управления жизненным циклоыделим только несколько страниц, поскольку в этой области MEF не обладаебширными возможностями. Далее большая часть оставшейся главы отведена на изучениозможностей работы с составными компонентами, а последний раздел снова занимаеовсем немного страниц. Первый раздел является предпосылко й остальных разделовставшиеся три раздела можно читать независимо друг от друга.
Эта глава должна дать вам возможность приступить к работе, а также справиться ольшинством общепринятых проблем, которые могут возникнуть при использовании
MEF. Однако это не окончательная трактовка MEF, поскольку мы рассматриваем его ерминах DI-контейнеров, а не с точки зрения его реального предназначения.
Вы можете прочитать эту главу, не читая при этом остальные главы части 4, специальнля того, чтобы познакомиться с MEF, или можете прочитать ее совместно с остальнымлавами части 4, чтобы сравнить MEF с "настоящими" DI-контейнерами. Цель даннолавы – показать, как MEF связан с паттернами и принципами, описанными в остальноасти книги, и как он их реализует.
15.1. Знакомство с MEF
15.2. Управление жизненным циклом
586
15.3. Работа с составными компонентами
15.4. Конфигурирование сложных API
15.5. Резюме
587
15.1. Знакомство с MEF
Из этого раздела вы узнаете, где можно взять MEF, что вы при этом получите и как начатго использовать. Кроме того, мы рассмотрим варианты конфигурирования акетирования компонентов. В таблице 15-1 содержится основополагающая информацияоторая, скорее всего, понадобится вам для того, чтобы приступить к работе с Unity.
Таблица 15-1: Краткая информация об MEF
Вопрос Ответ
Откуда мне еголучить? MEF является частью .NET 4 и Silverlight 4.
Что находится агруженном файле?
Вы получаете MEF при установке .NET 4 или Silverlight 4. MEF
является частью стандартной библиотеки классов и упакован борку System.ComponentModel.Composition.
Если вы посетите сайт http://mef.codeplex.com/, то сможете такжагрузить исходный код для дальнейшего внимательногзучения.
Какие платформоддерживаются?
.NET 4 и Silverlight 4.
На сайте http://mef.codeplex.com/ вы также можете найтеподдерживаемые версии для .NET 3.5 SP1 и Silverlight 3.
Сколько он стоит? Нисколько. MEF входит в состав .NET 4 и Silverlight 4.
Откуда мне получитомощь?
Поскольку MEF является частью .NET 4 и Silverlight 4, вы можетбратиться за поддержкой в компанию Microsoft.
На какой версии MEF
основана эта глава? .NET 4
В отличие от остальных DI-контейнеров MEF имеет другой цикл применения. Микогда не конфигурируем контейнер, зато снабжаем сами компоненты атрибутами. Нисунке 15-2 продемонстрирована взаимосвязь компонентов с движком компоновки.
Рисунок 15-2: При работе с MEF мы снабжаем части (к примеру, классы и члены)
атрибутами в рамках отдельных рабочих фаз. При компоновке приложения мы сначалтбираем соответствующие части в каталог, а затем используем этот каталог длпределения контейнера, из которого можно разрешать компоненты.
588
Терминология MEF
MEF использует терминологию, которая слегка отличается от той, которой мользовались при обсуждении других DI-контейнеров.
Обычно взаимодейству ющие классы мы называли компонент ами, но в MEF длбозначения таких классов используется термин част ь. Част ь – это класс или члеласса, который передает или использует зависимость.
Когда часть использует зависимость, мы говорим, что она импортирует ее. Напротивогда часть предоставляет сервис, она его экспорт ирует. В классическо м случае рофессионально й сфере слова import и export могут использоваться и кауществительные: импорт и экспорт.
Возможность экспорта и импорта определяется путем снабжения частеоответствующими атрибутами.
При компоновке приложения мы сопоставляем экспортируемые и импортируемыомпоненты в соответствии с контракт ами. Часто в качестве контрактов мы используеипы (например, интерфейсы), но MEF более гибкий, нежели контракты. Контракт, ействительности, – это всего лишь строка.
При работе с другими DI-контейнерами мы используем расщепленное API конфигурациля определения доступных компонентов, для определения того, как конкретные типреобразуются в абстракции, как создаются компоненты, и должны ли экземплярспользоваться совместно.
Напротив, при работе с MEF мы привязываем эту информацию к каждой части путерименения атрибутов к типам и членам. Это довольно легко понять, но такой подхоильно связывает конфигурацию компонента с самим компонентом.
Примечание
Помните о том, что MEF, по первой версии, использует атрибуты в качестве методбнаружения по умолчанию (и только по умолчанию), но по сути, не привязан трибутам как к средству обнаружения.
Чтобы скомпоновать приложение, мы отбираем соответствующие части и пакетируем их аталог, а затем создаем контейнер, который может разрешать компоненты из этогаталога.
После прочтения этого раздела вы приобретете полноценное понимание всей сущностаттерна применения MEF и сможете начать использовать его в сценариях, в которых всасти определяют простые экспортируемые и импортируемые компоненты. Давайтачнем с простейшего сценария и посмотрим, как можно разрешать объекты с помощьонтейнера MEF.
Разрешение объектов
Основная услуга, предоставляемая любым DI-контейнером – компоновка и разрешениомпонентов. В этом разделе мы рассмотрим API, которое позволяет разрешатомпоненты с помощью MEF. Что касается работы с любым другим контейнером,
589
разрешать объекты в них так же просто, как и вызывать простой метод. Но при работе с
MEF мы не можем что-либо разрешать до тех пор, пока не станут доступнымоответствующие экспортируемые компоненты.
Вспоминая обсуждение процесса разрешения компонентов при помощи Castle Windsor и
StructureMap, вы, возможно, припомните, что Windsor требует, чтобы перед тем, как сталозможным разрешение компонентов, все соответствующие компоненты быларегистрированы. MEF предъявляет аналогичное требование, несмотря на то, что микоим образом не можем зарегист рировать компонент. Вместо этого часть должнкспортировать необходимый сервис.
Чтобы разрешить сервис SauceBearnaise, мы должны его экспортировать. Самыростой способ осуществить это – путем аннотирования самого класса следующибразом:
[Export]
public class SauceBearnaise : IIngredient { }
Обратите внимание на атрибут [Export], которым снабжен класс SauceBearnaise. Это
MEF атрибут, который объявляет, что класс SauceBearnaise экспортирует самого себя.
Это означает, что, если вы поместите этот класс в каталог, то после этого сможетазрешать класс SauceBearnaise, но никакой другой, поскольку атрибутом экспорттмечен только этот класс:
var catalog = new TypeCatalog(typeof(SauceBearnaise));
var container = new CompositionContainer(catalog);
SauceBearnaise sauce =
container.GetExportedValue<SauceBearnaise>();
На рисунке 15-2 вы уже видели некоторый намек на понятие каталога. Более детально массмотрим его в разделе 15.1.3. А сейчас будет достаточно заметить, чтннотированный класс SauceBearnaise помещается в каталог, который вы используетля определения контейнера. После получения контейнера вы можете использовать егля разрешения сервиса SauceBearnaise.
Примечание
Метод GetExportedValue полностью соответствует методам Resolve контейнеров
Windsor, Autofac и Unity.
Помимо метода GetExportedValue MEF поддерживает и еще один стиль, при котором мначала получаем экспортируемые компоненты, а затем извлекаем значение этиомпонентов. Самая простая форма этого стиля выглядит следующим образом:
Lazy<SauceBearnaise> export =
container.GetExport<SauceBearnaise>();
SauceBearnaise sauce = export.Value;
Метод GetExport – отличный пример экспорта, который является первостепенныонятием MEF. Метод GetExport инкапсулирует экспортируемые компоненты, ноздавая при этом экземпляр части. Создание части можно отложить до тех пор, пока ме запросим свойство Value этой части, но все это зависит от стиля существования части.
590
И метод GetExportedValue, и метод GetExport обладают многочисленными аналогамито позволяет нам разрешать последовательности частей. Выглядят они следующибразом:
IEnumerable<IIngredient> ingredients =
container.GetExportedValues<IIngredient>();
IEnumerable<Lazy<IIngredient>> exports =
container.GetExports<IIngredient>();
До настоящего момента класс SauceBearnaise экспортировал только свой собственныип. Даже если он реализует IIngredient, он все равно не будет экспортировать этонтерфейс до тех пор, пока вы явно не укажете ему на это. При преобразованибстракций к конкретным типам также используется атрибут [Export].
Преобразование абстракций в конкретные типы
Атрибут [Export] экспортирует ту часть, к которой он относится. Иногда экспортируемаасть уже является абстракцией, но при аннотировании класса по умолчаникспортируется конкретный класс, даже если он реализует один или несколькнтерфейсов.
В связи со слабым связыванием нам необходимо преобразовывать абстракции онкретные типы. Создание экземпляров на основании таких преобразований – основнаслуга, предоставляемая любым DI-контейнером, но нам все равно нужно определитреобразование. При работе с MEF мы делаем это путем явного указания в атрибуте
[Export] того, что он должен экспортировать.
В приведенном ниже примере вы позволяете конкретному классу SauceBearnaisкспортировать интерфейс IIngredient:
[Export(typeof(IIngredient))]
public class SauceBearnaise : IIngredient { }
По сравнению с предыдущим примером вы изменили атрибут [Export] таким образомто теперь используется перегрузка, которая позволяет нам указывать, чткспортируемым типом является IIngredient. И снова вы пакетируете класс
SauceBearnaise в каталог, а затем из этого каталога создаете контейнер.
IIngredient ingredient = container.GetExportedValue<IIngredient>();
При разрешении IIngredient из контейнера, оказывается, что значение ingredient, как жидалось, является экземпляром класса SauceBearnaise. Однако если вы попытаетесазрешить SauceBearnaise таким образом, как делали это в первом примере, то получитсключение, в связи с отсутствием частей, которые экспортировали бы контракт
SauceBearnaise.
Вы легко можете это сделать, несколько раз применив атрибут [Export]:
[Export]
[Export(typeof(IIngredient))]
public class SauceBearnaise : IIngredient { }
591
Атрибут [Export] можно применять столько раз, сколько потребуется, поэтому при такоарианте экспортируется и класс SauceBearnaise, и интерфейс IIngredient.
До настоящего момента мы рассматривали строго типизированный generic-методспользуемый для разрешения сервисов. Однако существуют ситуации, когда длазрешения сервисов, нам необходим более слабо типизированный подход. Это возможноо подразумевает выполнение несколько большего количества действий, челанировалось.
Разрешение слабо типизированных сервисов
Иногда у вас нет возможности использовать generic API, поскольку на этапроектирования вы еще не знаете, какой тип вам понадобится. У вас есть тольккземпляр Type, но все же вам хотелось бы получить экземпляр этого типа. Пример такоитуации описан в разделе 7.2 "Построение ASP.NET MVC приложений", в которобсуждался ASP.NET класс DefaultControllerFactory. Соответствующий меториведен в следующем примере:
protected internal virtual IController GetControllerInstance(
RequestContext requestContext, Type controllerType);
Поскольку у вас имеется только экземпляр Type, вы не можете использовать generic'и, олжны прибегнуть к слабо типизированному API. К несчастью, единственноетипизированно е API, раскрываемое с помощью CompositionContainer, является слегкромоздким. Нетипизированных версий методов GetExportedValue или
GetExportedValues не существует, поэтому для реализации GetControllerInstance наеобходимо прибегнуть к не generic-версии GetExports:
var export = this.container.GetExports(
controllerType, null, null).Single();
return (IController)export.Value;
Существует несколько перегрузок метода GetExports, но в этом примере мы используеу, которая позволяет нам передавать результат напрямую в controllerType. Два другиараметра можно использовать для создания ограничителей запроса, но если они нам нужны, то мы можем передать для них значения типа null. Метод GetExports возвращаеоследовательность экспортируемых компонентов, но согласно нашему условикспортировать можно только один компонент, удовлетворяющий параметрам запроса.
Поэтому для получения единичного экземпляра из последовательнос ти мы вызываеетод расширения Single.
Поскольку метод GetExports является слабо типизированным, мы должны привесткспортируемое значение к IController перед тем, как его вернуть. В любом случаезависимо от того, какой конкретный метод вы используете для разрешения частей, MEF
компонует части посредством сопоставления импортируемых и экспортируемыомпонентов. MEF может это делать только, когда мы заранее явно определили это.
Определение импортируемых и экспортируемых компонентов
В разделе 3.2 "Конфигурирование DI-контейнеров" мы обсуждали несколько различныпособов конфигурирования DI-контейнера. На рисунке 15-3 представлен обзор
592
возможных вариантов, а также показано то, что MEF совершенно не подходит под этодель.
Рисунок 15-3: MEF не подходит под нашу стандартную концептуальную моделариантов конфигурирования, поскольку мы не можем конфигурировать контейнер. Всбычные варианты, которые мы рассматривали ранее, являются недоступными бозначены серым цветом. Снабжение частей атрибутами статистически наряду с типопределяет конфигурацию, тогда как каталоги обеспечивают гибкость.
Мы не можем сконфигурировать контейнер с помощью используемых нами ранепособов – ни с помощью императивного кода, ни посредством XML конфигурации. MEF
дает нам возможность определять только импортируемые и экспортируемые части, менно посредством применения атрибутов к этим частям. Атрибуты являются частямех типов, которыми они отмечены, поэтому мы должны рассматривать этот механизм каолее явный и более рано связанный, нежели, например, технология конфигурирования оде. С другой стороны, каталоги делают MEF довольно гибким, поскольку позволяютбирать типы, которые мы хотим включить в компоновку.
Предупреждение
Применение атрибутов сильно привязывает конфигурацию к реализации. В разделе 9.3.1
"Использование атрибутов для объявления аспектов" мы обсуждали недостаткспользования атрибутов для аспектов, но это обсуждение применимо и ко всему
593
остальному. Не забывайте, что в будущем в MEF может появиться некоторая альтернативтрибутам.
В этом разделе мы рассмотрим варианты импорта и экспорта частей, а затем в разделе
15.1.3 перейдем к изучению каталогов. Несмотря на то, что мы не можем использоваташи стандартные варианты конфигурирования контейнера, мы можем привестекоторые соответствия, чтобы рассмотреть другие сценарии. В этом разделе вознакомитесь с различными способами экспорта и импорта частей.
Экспорт типов
В этом разделе мы рассмотрим сценарий, при котором мы управляем классами, которыланируем экспортировать. Когда мы полностью контролируем исходный код телассов, которые собираемся экспортировать, мы можем экспортировать класс с помощьтрибута [Export]:
[Export]
[Export(typeof(IIngredient))]
public class SauceBearnaise : IIngredient { }
Свойство [Export] можно применять столько раз, сколько потребуется, поэтому один от же класс может экспортировать различные контракты. Класс SauceBearnaiseродемонстрированный в этом примере, экспортируется и как конкретный класс, и кантерфейс IIngredient.
Перегрузка [Export], позволяющая указывать экспортируемый тип, не нуждается роверке на этапе компиляции. Вы можете объявить невалидный атрибут экспорта, и пртом не произойдет никаких ошибок компиляции:
[Export(typeof(ICourse))]
public class SauceBearnaise : IIngredient { }
Класс SauceBearnaise не реализует интерфейс ICourse, хотя вы можете составитребование, что он должен его реализовывать. Однако при попытке разрешения ICoursыдается исключение, поскольку MEF не умеет приводить SauceBearnaise к ICourse.
Предупреждение
Можно объявлять невалидные атрибуты экспорта.
Очевидно, вы можете позволить различным классам экспортировать разные контракты, ри этом не возникнет никаких конфликтов:
[Export(typeof(IIngredient))]
public class SauceBearnaise : IIngredient { }
[Export(typeof(ICourse))]
public class Course : ICourse { }
Поскольку каждый отдельный класс экспортирует отличные от других контрактыонфликта не возникает, и вы можете отправить контейнеру запрос на разрешение и
ICourse, и IIngredient, получив в итоге экземпляры Course и SauceBearnaisоответственно.
594
Однако если мы экспортируем одну и ту же абстракцию несколько раз, то картинзменится:
[Export(typeof(IIngredient))]
public class SauceBearnaise : IIngredient { }
[Export(typeof(IIngredient))]
public class Steak : IIngredient { }
В этом примере вы экспортируете IIngredient дважды. Если вы попытаетесь разрешить
IIngredient, то контейнер выдаст исключение, поскольку в коде приведено нескольктрибутов экспорта. Под вызовом метода GetExport или GetExportedValuодразумевается запрос повсеместно встречающейся части. Вы все равно можетолучить и SauceBearnaise, и Steak, вызвав множественные методы GetExports или
GetExportedValues.
Примечание
В MEF нет такого понятия как компонент по умолчанию. Все экспортируемыомпоненты равны между собой.
Это и есть первый намек на такое важное понятие MEF, как мощ ность импортируемых кспортируемых компонентов. Количество экспортируемых компонентов должновпадать с количеством импортируемых компонентов. В таблице 15-2 показано, как MEF
сопоставляет импортируемые и экспортируемые компоненты по мощности.
Таблица 15-2: Сопоставление количества атрибутов импорта и экспорта
Export.Single Export.Many
Import.Single Равно Не равно
Import.Many Равно Равно
В этом контексте термин "many" используется для обозначения последовательностастей, обычно массива IEnumerable<T>. Если мы будем явным образом импортироватножество частей одного и того же контракта, то MEF всегда будет находитоответствие, поскольку нулевое количество атрибутов экспорта есть особый случаножественных атрибутов экспорта.
С другой стороны, явно импортируя один экземпляр, мы получаем несоответствиощностей в случае наличия нулевого или множественного количества атрибутокспорта, потому что импорт одного экземпляра означает, что у нас должен быть толькдин экземпляр.
Примечание
Мощ ность – это один из тех видов размерностей, по которым атрибуты экспорта мпорта должны соответствовать друг другу.
Как вы увидите в разделе 15.2.1, механизм управления жизненным циклом также можеграть важную роль в вопросе соответствия частей, но мощность учитывается всегда.
Далее в этом разделе вы увидите, как определять единичные и множественные атрибутмпорта. Но перед тем как приступить к рассмотрению этого вопроса, нам следует
595
рассмотреть процесс экспорта частей в тех ситуациях, когда мы не контролируем классычаствующие в этом процессе.
Экспорт адапте ров
Самый простой способ экспортировать часть – применить к классу атрибут [Export], нто не всегда возможно сделать. Нам может понадобиться экспортировать классыоторые уже были скомпилированы, а доступа к исходному коду у нас нет. В такилучаях мы не можем применять атрибуты, хотя нам и хотелось бы включить этот класс омпоновку.
И все равно мы можем достичь этой цели, усилив способность MEF экспортироватвойства так же, как и классы. Для примера рассмотрим конструктор Mayonnaise:
public Mayonnaise(EggYolk eggYolk, OliveOil oil)
Представьте себе, что класс Mayonnaise и составляющие его зависимости EggYolk и
OliveOil не подвластны нам. Одним из возможных вариантов в таком случае было баследование от первоначального класса и применение атрибута [Export] наследованному классу:
[Export(typeof(OliveOil))]
[Export(typeof(IIngredient))]
public class MefOliveOil : OliveOil { }
Обратите внимание, что если вам необходимо экспортировать и первоначальныонкретный класс, и интерфейс IIngredient, то вы должны явным образом установитьто базовый класс (который и является конкретным классом) также должен быткспортирован. Если бы вы использовали атрибут [Export] без указания типа, то вместазового класса вы бы экспортировали класс MefOliveOil.
Однако если рассматриваемые классы заблокированы, то вы не сможете экспортироватх таким образом. В этом случае, как показано в следующем листинге, можно создатдаптер и экспортировать часть через свойство.
Листинг 15-1: Экспорт OliveOil через адаптер
1. public class OliveOilAdapter
2. {
3. private readonly OliveOil oil;
4. public OliveOilAdapter()
5. {
6. this.oil = new OliveOil();
7. }
8. [Export]
9. public OliveOil OliveOil
10. {
11. get { return this.oil; }
12. }
13. }
Строка 8: Экспорт свойства
Класс OliveOilAdapter – это совершенно новый класс, который обертываеервоначальный класс OliveOil и экспортирует его посредством аннотированного
596
свойства. Атрибут [Export] можно применять как к свойствам, так и к типам, но стальном он работает аналогичным образом. Свойство OliveOil имеет тип OliveOilвляющийся, в свою очередь, контрактом, который вы собираетесь экспортироватьоэтому в этом случае вы можете использовать свойство [Export], не задавая явно тип.
Подсказка
Тип всегда можно экспортировать путем создания адаптера.
Когда у класса, который вам необходимо скомпоновать, есть зависимости, вам нужнкспортировать их посредством адаптера. Как показывает следующий листинг, этороцесс становится более сложным, но пока что вполне управляемым.
Листинг 15-2: Настройка класса, имеющего зависимости
1. public class MayonnaiseAdapter
2. {
3. private readonly Mayonnaise mayo;
4. [ImportingConstructor]
5. public MayonnaiseAdapter(
6. EggYolk yolk, OliveOil oil)
7. {
8. if (yolk == null)
9. {
10. throw new ArgumentNullException("yolk");
11. }
12. if (oil == null)
13. {
14. throw new ArgumentNullException("oil");
15. }
16. this.mayo = new Mayonnaise(yolk, oil);
17. }
18. [Export]
19. public Mayonnaise Mayonnaise
20. {
21. get { return this.mayo; }
22. }
23. }
Строка 5-6: Имитатор сигнатуры конструктора Mayonnaise
Строка 16: Создание Mayonnaise
Строка 18: Экспорт Mayonnaise
Чтобы экспортировать класс Mayonnaise посредством адаптера, вы должны учитывать тоакт, что у него есть зависимости, которые вам нужно будет импортировать. Чтобы иметозможность создать экземпляр класса, вы должны сымитировать сигнатуру конструктора
Mayonnaise в конструкторе адаптера для того, чтобы вы смогли импортировать всеобходимые части. После прохождения соответствующих граничных операторов воздаете новый экземпляр Mayonnaise из параметров конструктора и сохраняете результа приватном поле. Это и есть паттерн Constructor Injection в действии.
Чтобы экспортировать класс Mayonnaise, вы можете раскрыть поле mayo как свойство тметить его атрибутом [Export].
597
Благодаря EggYolkAdapter, похожему на OliveOilAdapter из листинга 15-1, вы можетоздать каталог, состоящий из трех адаптеров, и успешно разрешить экземпляр
Mayonnaise, даже если вы никогда не изменяли первоначальные классы.
Возможно, вы обратили внимание на атрибут [ImportingConstructor], которыоявился в листинге 15-2. Это часть другой стороны уравнения. До настоящего моменты рассматривали процесс экспорта частей. Теперь давайте изучим, как можнмпортировать части.
Импорт частей
В рамках MEF присутствует некоторого рода симметрия. Большинство из тетверждений, которые мы можем применить к атрибутам экспорта, также применимы трибутам импорта. Однако когда дело доходит до паттерна Constructor Injection, наеобходимо прибегнуть к атрибуту [ImportingConstructor], эквивалентов которого длкспортируемых компонентов не существует. Мы видели, как этот атрибут применялся к
MayonnaiseAdapter в листинге 15-2, но он должен применяться всякий раз, когда наужно применять паттерн Constructor Injection.
В приведенном примере мы предположили, что класс Mayonnaise нами нонтролируется. Благодаря невероятному стечению обстоятельств мы смогли невзначаерехватить исходный код и теперь можем изменять типы напрямую. В этом случае нае придется создавать адаптеры, и мы можем применять атрибуты [Export] напрямую лассам Mayonnaise, OliveOil и EggYolk.
MEF не распознал паттерн Constructor Injection, поэтому, даже если у Mayonnaise имеетссего один конструктор, при попытке разрешить этот класс мы сначала получисключение. Нам необходимо явным образом сообщить MEF о том, какой конструктор оолжен использовать при отсутствии конструктора по умолчанию:
[ImportingConstructor]
public Mayonnaise(EggYolk eggYolk, OliveOil oil)
[ImportingConstructor] – это сигнал MEF о том, что тот конструктор, к которомтносится этот атрибут, должен использоваться для компоновки типа.
Подсказка
Для конструкторов по умолчанию [ImportingConstructor] не нужен. Используйте этотрибут, если у класса нет конструктора по умолчанию, или если компоновксуществляется с помощью другого конструктора, а не конструктора по умолчанию.
Кроме того, мы можем использовать атрибут [Import] для поддержки паттерна Property
Injection, но к этому вопросу мы вернемся в разделе 15.4.3, который посвящен этоматтерну. Более того, существует атрибут [ImportMany]. Который используется длмпорта последовательностей частей, но его мы рассмотрим в разделе 15.3.2.
Импорт и экспорт частей основывается на применении атрибутов, а поскольку атрибутомпилируются в типы, это делает MEF негибким. Свою гибкость MEF приобретаелагодаря каталогам.
598
Работа с каталогами
Каталог инкапсулирует набор частей, которые контейнер может использовать дломпоновки диаграммы объектов. В этом разделе мы приведем обзор различных видоаталогов, доступных в MEF.
Использование каталогов в рамках контейнеров
В разделе 15.1.1 "Разрешение объектов" вы уже видели пример взаимодействия каталога онтейнера:
var catalog = new
TypeCatalog(typeof(SauceBearnaise));
var container = new
CompositionContainer(catalog);
В этом примере используется TypeCatalog конкретного типа, но вы можете создать
CompositionContainer с любым ComposablePartCatalog.TypeCatalog – это всего лишдин из множества дочерних классов. На рисунке 15-4 приведена схема иерархии типов.
Рисунок 15-4: В MEF входит четыре конкретных каталога, но помимо них мы можепределять пользовательские каталоги. Возможно, было бы достаточно простеализовать каталог, который выступал бы в роли Decorator для других каталогов
(например, каталог фильтрации), между тем, как настоящий пользовательский каталоыл бы в него вложен.
599
О пределение
Каталог – это любой класс, унаследованный от абстрактного класса
ComposablePartCatalog.
Как и подразумевает его имя, ComposablePartCatalog – это каталог частей, которые
CompositionContainer использует для сопоставления импортируемых и экспортируемыомпонентов. Одна из перегрузок конструктора класса CompositionContainer позволяеередавать ComposablePartCatalog, и именно этот конструктор мы использовали дастоящего момента:
public CompositionContainer(ComposablePartCatalog catalogarams ExportProvider[] providers)
Помимо того, что этот конструктор принимает в качестве параметра экземпляр
ComposablePartCatalog, он также принимает и массив params типа ExportProvidersоторый является еще одним механизмом расширяемости, не рассматриваемым в этониге.
Поскольку ComposablePartCatalog – это абстрактный класс, а CompositionContaineринимает в качестве параметра любой унаследованный класс, теоретически мы можеоздать пользовательские каталоги с самых азов. Это главный Seam контейнера MEF. Егаже можно использовать для определения других вариантов атрибутивной модели MEF
по умолчанию, которая используется для определения импортируемых и экспортируемыомпонентов. Несмотря на то, что такой подход возможен, он слишком трудозатратныйоэтому в этой главе мы не будем его рассматривать.
Подсказка
В проекте с открытым исходным кодом MEF Contrib содержится примеользовательского ComposablePartCatalog, полностью замещающего атрибутивнуодель конфигурирования более открытой моделью, которая больше похожа на другие
DI-контейнеры.
Все каталоги, входящие в состав MEF в .NET 4, используют атрибуты [Import] и
[Export] для определения импортируемых и экспортируемых данных, но по-разномпределяют местоположение частей. Например, TypeCatalog определяет местоположениастей, считывая атрибуты типов, содержащихся в каталоге.
Использование каталогов типов
Класс TypeCatalog позволяет определять каталог, состоящий из перечня типов, нсновании предположения о том, что эти типы определяют импортируемые кспортируемые компоненты с помощью атрибутов. Существует два перегруженныонструктора, которые позволяют нам создавать произвольное количество экземпляров
Type:
public TypeCatalog(params Type[] types)
public TypeCatalog(IEnumerable<Type> types)
600
В качестве примера для того, чтобы иметь возможность компоновать Mayonnaise идаптеров, созданных вами в листингах 15-1 и 15-2, вы можете создать каталоледующим образом:
var catalog = new TypeCatalog(
typeof(MayonnaiseAdapter)ypeof(EggYolkAdapter)ypeof(OliveOilAdapter));
Это небольшой каталог, позволяющий разрешать Mayonnaise. Если вы удалите любой ирех типов адаптеров, то экспортируемые компоненты будут упущены. Помимо того, чттот каталог позволяет вам разрешать Mayonnaise, он также позволяет разрешать EggYol OliveOil, но не более того.
Очевидно, что вы могли бы передать в TypeCatalog большее количество типов, чтобкспортировать больше данных, но при этом вы должны четко определить список типов.
Это имеет смысл для небольших сценариев с ограниченной областью применения.
Преимущество заключается в том, что вы можете отбирать только те типы, которые вобираетесь использовать при компоновке. При наличии типов, экспортирующионкурирующие типы, вы можете отобрать только те типы, которые вам нужны.
Подсказка
Вы можете создать несколько адаптеров, которые совершенно по-разному экспортируюдну и ту же часть, и передать в TypeCatalog только один из них. При написаниаблонного кода для этой главы я использовал этот прием для того, чтобы варьироваттрибуты MayonnaiseAdapter, не редактируя при этом код.
Недостаток применения TypeCatalog заключается в том, что вы должны явно передаватсе типы. При добавлении в сборку нового типа вам также нужно добавить его в
TypeCatalog, если вы хотите, чтобы он вошел в каталог. Это приводит к нарушениринципа DRY (Don't Repeat Yourself – Не повторяйся). Вы могли бы решить эту проблемутем написания кода, в котором для просмотра сборки с целью обнаружения всеткрытых типов используется рефлексия. Но вам не придется этого делать, поскольку ужуществует каталог, выполняющий то же самое.
Использование каталогов сборок
Класс AssemblyCatalog предназначен для просмотра сборки с целью поиска всемпортируемых и экспортируемых компонентов, определенных в этой сборке. Этот класозволяет нам продолжать добавлять части в сборку без необходимости помнить о томто нужно добавить эту часть еще и в каталог.
Использовать AssemblyCatalog так же просто, как и создавать экземпляр Assembly омощью конструктора:
var assembly = typeof(Steak).Assembly;
var catalog = new AssemblyCatalog(assembly);
В этом примере вы используете неизбирательный представительский тип (Steak) длпределения сборки, но подойдет и любой другой метод, который создаеоответствующий экземпляр Assembly.
601
Кроме того, существует перегрузка конструктора, которая вместо экземпляра Assemblринимает в качестве параметра имя файла. Это делает возможными более слабвязанные сценарии, поскольку мы можем заменить .dll файл, не компилируя повторнстальную часть приложения. Это приближает нас к смыслу подключения сценариеасширений в контейнере MEF. Благодаря AssemblyCatalog мы могли бы написатмперативный цикл и создать для каждого найденного нами файла каталог по этому пути.
Однако нам не приходится действовать подобным образом, поскольку в MEF уже естпециально предназначенный для этого каталог.
Использование каталогов директорий
Основная цель MEF – разрешить использовать сценарии расширений. Универсальнархитектура расширений – определить для расширений особую директорию. Главнориложение будет загружать и использовать любую сборку, размещенную в этоиректории.
MEF способствует выполнению такого сценария посредством класса DirectoryCatalog. В
конструктор мы передаем путь к директории, а он, в свою очередь, ищет в этоиректории файлы с расширением .dll и загружает все, что обнаружено в этих сборках:
var catalog = new DirectoryCatalog(directory);
Еще одна перегрузка конструктора также позволяет нам задавать шаблон поискосредством универсальных специальных символов.
Примечание
При использовании MEF в качестве фреймворка расширяемости, что является ключевыго предназначением, предполагается, что DirectoryCatalog является самыниверсальным из используемых каталогов.
Несмотря на то, что в директории мы можем разместить произвольное количество сборок затем отбирать их с помощью DirectoryCatalog, мы можем захотеть сочетать каталогз нескольких отличных друг от друга источников. Даже если для включениозможности расширяемости мы используем DirectoryCatalog, нам также могуонадобиться некоторые реализации по умолчанию или внутренние реализациоответствующих импортируемых и экспортируемых элементов. Эти реализации нолжны размещаться в папке расширений, потому что в этом случае пользователи смогудалить из приложения жизненно важную функциональность. Возможно, было бы лучшоздать такие реализации по умолчанию с помощью TypeCatalog, но это означает, чтам пришлось бы соединить разные каталоги в один.
Использование каталогов агрегатов
Для соединения каталогов можно использовать класс AggregateCatalog, которывляется тем же самым Composite только с другим именем. Он объединяет в единое целороизвольное количество каталогов и в то же самое время сам является каталогом:
var catalog = new AggregateCatalog(catalog1, catalog2);
var container = new CompositionContainer(catalog);
602
Входящие в MEF четыре каталога уже обеспечивают достаточную гибкость приложенияо для получения наибольшего контроля мы реализуем также пользовательские каталоги.
Один из примеров, который легко реализовать и использовать, – это каталог фильтрации.
Реализация каталога фильтрации
Несмотря на то, что реализация пользовательского каталога с нуля, возможно, являетсовольно замысловатой затеей, мы можем довольно легко реализовать Decorator, которызменит поведение другого каталога.
Наиболее очевидный пример – каталог фильтрации, который отфильтровываеложенный каталог. В следующем листинге продемонстрирован пользовательскиаталог, который является оберткой для другого каталога и может вступить в игру тольк помощью тех составляющих, которые экспортируют контракт, содержащий строку
"Sauce". Этот пользовательский каталог можно использовать, чтобы отобрать из каталогсех ингредиентов только соусы.
Листинг 15-3: Реализация пользовательского каталога
1. public class SauceCatalog : ComposablePartCatalog
2. {
3. private readonly ComposablePartCatalog catalog;
4. public SauceCatalog(ComposablePartCatalog cat)
5. {
6. if (cat == null)
7. {
8. throw new ArgumentNullException("cat");
9. }
10. this.catalog = cat;
11. }
12. public override
13. IQueryable<ComposablePartDefinition> Parts
14. {
15. get
16. {
17. return this.catalog.Parts.Where(def =>
18. def.ExportDefinitions.Any(x =>
19. x.ContractName
20. .Contains("Sauce")));
21. }
22. }
23. }
Строка 1: Наследование от ComposablePartCatalog
Строка 3-11: Constructor Injection
Строка 12-22: Реализация фильтра
Чтобы реализовать пользовательский каталог, вы выполняете наследование обстрактного класса ComposablePartCatalog. Поскольку вы пожелали создать оберткля другого каталога, вы запрашиваете этот каталог через Constructor Injection.
Свойство Parts – единственный абстрактный член ComposablePartCatalog, поэтому эт есть тот единственный член класса, который необходимо реализовать. При желании вожете реализовать и другие виртуальные члены, но для этого примера это не
603
потребуется. Фильтр реализуется с помощью выражения Where, которое отфильтровываесе ComposablePartDefinitions, не экспортирующие никакого контракта и содержащилово "Sauce".
SauceCatalog – это конкретный класс, но вы можете обобщить реализацию, чтобоздать универсальный FilteringCatalog. В документации к MEF есть соответствующиример.
Пользовательские каталоги
Возможно, листинг 15-3 вас удивил: если нам для создания пользовательского каталогеобходимо реализовать только одно единственное свойство, то, как этот процесс можеыть сложным? Проблема заключается в том, что ComposablePartDefinition являетсбстрактным типом и не имеет ни одной открытой реализации. При реализацинаследованного ComposablePartCatalog необходимо также реализоватользовательский ComposablePartDefinition. Теперь паттерн повторяется, поскольку
ComposablePartDefinition определяет еще один абстрактный метод, возвращаемоначение которого относится к типу, не имеющему открытой реализации. Хотя создатользовательский каталог возможно, но в этой книге этот процесс не рассматривается.
Каталоги – существенные строительные блоки MEF. Несмотря на то, что атрибуттатичны, каталоги придают приложению большую гибкость. В MEF встроены четыраталога, которые содержат элементы, полученные из явных типов, из одной и той жборки или из найденных в папке сборок. В случае необходимости сочетать части иазных каталогов можно воспользоваться AggregateCatalog.
MEF поддерживает только возможность конфигурирования частей с помощью атрибутов.
Но если нам нужно скомпоновать части, не используя атрибуты, мы всегда можем создатдаптеры, которые импортируют и экспортируют эти части. Такие адаптеры можнспользовать для того, чтобы преодолеть разрыв между статической аттрибутивнооделью и конфигурацией контейнера, которую мы использовали для других DI-
контейнеров. Мы можем разделить существующий каталог типов на подклассы с темтобы расфасовать совокупность частей или адаптеров, которые впоследствии можночетать с AggregateCatalog для компоновки приложения.
До настоящего момента мы рассматривали только то, как можно определитмпортируемые и экспортируемые компоненты таким образом, что MEF мог компоноватиаграмму объектов. Существуют и другие стороны механизма внедрения зависимостейоторые мы еще не рассматривали. Один из наиболее важных вопросов – как управлятизненным циклом объектов.
604
15.2. Управление жизненным циклом
В главе 8 обсуждался процесс управления жизненным циклом, в том числе наиболениверсальные стили существования, к примеру, Singleton и Transient. Сделать обзооступных стилей существования MEF довольно легко, поскольку MEF обладает тольквумя стилями существования, продемонстрированными в таблице 15-3.
Таблица 15-3: Стили существования MEF
Название Комментарии
Shared
Этот стиль считается стилем по умолчанию, несмотря на то, что он зависит ооответствия импортируемых и экспортируемых элементов. Так в MEF
называется стиль существования Singleton.
NonShared Так в MEF называется стиль существования Transient. Контейнер отслеживаекземпляры.
Примечание
В MEF стили существования называются полит иками создания.
Реализации в MEF стилей существования Transient и Singleton эквивалентны стиляуществования, описанным в главе 8, поэтому в этой главе я не буду тратить время на иассмотрение.
Подсказка
В MEF используемым по умолчанию является стиль Singleton. Этим он отличается оругих DI-контейнеров. Как уже обсуждалось в главе 8, Singleton – самый эффективныйо не всегда самый безопасный стиль. Поэтому в MEF эффективность приоритетнеезопасности.
В MEF существует только две политики создания, а реализовать пользовательскиизненные циклы в нем невозможно, поэтому по сравнению с остальными главами части
4 этот раздел довольно краток. Вы увидите, как объявлять стили существования дластей и как высвобождать компоненты. После прочтения этого раздела вы сможетоздавать политики создания в своем собственном приложении.
Сообразно остальному API контейнера MEF политика создания определяется с помощьтрибутов.
Объявление политики создания
Объявить политику создания можно посредством добавления в класс атрибута
[PartCreationPolicy]:
[Export(typeof(IIngredient))]
[PartCreationPolicy(CreationPolicy.NonShared)]
public class SauceBearnaise : IIngredient { }
Для атрибута [PartCreationPolicy] необходимо, чтобы вы указали значение для
CreationPolicy. В этом примере в качестве значения CreationPolicy вы указали
605
"NonShared" для того, чтобы объявить SauceBearnaise как Transient-компонент. Но каемонстрирует таблица 15-4, у перечисления CreationPolicy есть еще несколькариантов.
Таблица 15-4: Значение CreationPolicy
Значение Описание
Any
Это значение используется по умолчанию. Часть может быть как Singleton-
компонентом, так и Transient. Но пока явно не будет запрашиваться значение
NonShared, часть будет вести себя как Shared.
Shared Часть является Singleton-компонентом.
NonShared Часть всегда выступает в роли Transient –компонента.
Примечание
Атрибут [PartCreationPolicy] можно применять только к классам. Он отличается отрибутов [Import] и [Export], которые можно применять к классам, членам классов араметрам.
Неудивительно, что мы можем использовать значения Shared и NonShared, но вот то, чты можем указать значение Any, возможно, слегка вас удивило. Мы вкратце рассмотриначение Any, но сначала завершим рассмотрение значений Shared и NonShared.
Экспорт с помощью политик создания
Как мы только что обсуждали, политику создания мы задаем с помощью атрибута
[PartCreationPolicy]. Если мы не указываем значение этого атрибута, то используетсначение Any. Однако если мы поставим этот атрибут рядом с атрибутами [Import] и
[ImportingConstructor], которые вы уже видели в этой главе, то по умолчанию будеспользоваться стиль Singleton.
В этом контексте два приведенных ниже примера эквивалентны:
[Export(typeof(IIngredient))]
public class SauceBearnaise : IIngredient { }
[Export(typeof(IIngredient))]
[PartCreationPolicy(CreationPolicy.Shared)]
public class SauceBearnaise : IIngredient { }
Единственное отличие между двумя верхними строчками кода и тремя нижнимаключается в том, что в нижнем примере вы явно указываете на то, что часть является
Singleton-компон ентом. До тех пор, пока импортер не запрашивает конкретную политикоздания, поведение приведенных примеров кода будет идентично.
Разница состоит в том, что в верхнем примере не указана явная политика создания, т.е.
используется значение Any. Несмотря на то, что в большинстве случаев по умолчаниспользуется поведение, соответствующее стилю Singleton, все намного сложнее.
606
Импорт с помощью требований политики создания
CreationPolicy.Any явно указывает на то, что политика создания части не определена, то жизненный цикл будет определен посредством сопоставления атрибутов экспорта мпорта.
Среди многочисленных вариантов импорта зависимостей в MEF есть возможностьозволяющая нам потребовать, чтобы часть имела конкретную политику создания. Этогло бы выглядеть следующим образом:
[ImportingConstructor]
public Mayonnaise(
[Import(RequiredCreationPolicy = CreationPolicy.NonShared)]
EggYolk eggYolk,
OliveOil oil)
{ }
Этот конструктор Mayonnaise явно указывает на то, что принимаются только свежиелтки. С точки зрения кулинарии, возможно, это и не кажется таким уж сложным, ноогда дело касается кода, это требование задает строгое ограничение для импортируемоасти. Это требование компилируется в класс Mayonnaise посредством атрибута
[Import], которым отмечается аргумент конструктора eggYolk. Обратите внимание на тото этим атрибутом отмечен только атрибут eggYolk, что позволяет вам для созданиескольких порций майонеза брать оливковое масло из той же самой бутылки.
Предупреждение
Задание требования политики создания в компилируемом атрибуте потребителя – этазновидность анти-паттерна Control Freak. MEF позволяет это сделать, но ваеобходимо воздержаься от такого поведения, поскольку это ограничивает вашозможности компоновки.
Свойство RequiredCreationPolicy потенциально может изменить контексопоставления импортируемых и экспортируемых компонентов. Если мы не используето свойство, то принимается любое значение (Shared и NonShared), но прспользовании свойства RequiredCreationPolicy несовместимые экспортируемылементы будут отбрасываться.
Помните ли вы таблицу 15-2, в которой описывается, как сопоставляются импортируемы экспортируемые компоненты по мощности? Сопоставление по политике создания – этще одна сторона алгоритма сопоставления, используемого в MEF. В таблице 15-5
демонстрируется, как сопоставляются политики создания.
Таблица 15-5: Сопоставление импортируемых и экспортируемых компонентов политике создания
Export.Any Export.Shared Export.NonShared
Im port.Any Shared Shared NonShared
Im port.Shared Shared Shared Не сопоставимы
Im port.NonShared NonShared Не сопоставимы NonShared
607
Не забывайте, что сопоставление по политике создания – это всего лишь одна из стороопоставления импортируемых и экспортируемых компонентов, и перед тем, как будеыполнено сопоставление, должны быть проверены все ограничения. Не указывать длмпортируемых элементов политику создания – наиболее предпочтительный вариант.
В этом разделе вы увидели, что политика создания определяется с помощью атрибутов, бщем случае подобных атрибутам импорта и экспорта. Указание политик создания –
первая составляющая процесса управления жизненным циклом. Но после разрешенииаграмм объектов, которые могут содержать части, имеющие смешанные жизненныиклы, мы должны не забыть их высвободить.
Высвобождение объектов
Как мы уже обсуждали в разделе 8.2.2 "Управление устраняемыми зависимостями", важнысвободить объекты после того, как мы завершили работу с ними, чтобы можно былничтожить любые устраняемые экземпляр ы при завершении их жизненного цикла. В
MEF выполнить это довольно легко. Мы можем явным образом высвободиткспортируемые элементы или же устранить весь контейнер, если он нам больше нужен.
Высвобождение экспортируе мых компонентов
Высвобождать экспортируемые компоненты очень легко, но особенностью MEF являетсо, что, несмотря на возможность высвобождать экспортируемые компоненты, мы ножем высвобожlать экспортированные значения. В чем отличие?
Ниже приведено экспортированное значение:
var ingredient = container.GetExportedValue<IIngredient>();
Как вы уже видели в разделе 15.1.1 "Разрешение объектов", метод GetExportedValuозвращает экземпляр запрашиваемого типа, таким образом, ingredient являетскземпляром IIngredient. Вместо того чтобы запрашивать экспортированное значениеожно запросить экспортируемый компонент:
var x = container.GetExport<IIngredient>();
Метод GetExport возвращает Lazy<IIngredient>, а не экземпляр IIngredient. Однакы можете получить экспортированное значение из свойства Value экспортируемогомпонента:
var ingredient = x.Value;
Поскольку x – это экземпляр Lazy<IIngredient>, ingredient является экземпляром
IIngredient. Если вы собираетесь высвобождать разрешенные компоненты, вы должнспользовать экспортируемые компоненты, поскольку для CompositionContaineозможен только один метод Release:
public void ReleaseExport<T>(Lazy<T> export)
Для метода ReleaseExport нужен экспортируемый компонент и неэкспортированноначение. Это означает, что вы не можете напрямую высвобождать экспортированное
608
значение посредством передачи переменной ingredient, а для того, чтобы высвободитго, должны использовать экспортируемый компонент:
container.ReleaseExport(x);
Поскольку ingredient был создан из x, он высвобождается, когда высвобождаетсодобный экспортируемый компонент. Устраняемые зависимости должным образоничтожаются, если заканчивается их жизненный цикл. Высвобождать части столь жросто, как и вызывать метод ReleaseExport. Но для того чтобы иметь возможностызывать этот метод, вы должны использовать первоначальный экспортируемыомпонент.
В сценариях, когда один и тот же контейнер разрешает множество экземпляров, важнметь возможность высвобождать экспортируемые компоненты, не устраняя при этом саонтейнер. Такой сценарий обычно используется в веб-приложениях и веб-сервисах, оторых один и тот же контейнер управляет сразу несколькими запросами. С друготороны, в клиентских приложениях необходимо разрешать только одну диаграммависимостей, при этом мы можем уничтожить контейнер после закрытия приложения.
Высвобождение конте йнера
Такие клиентские приложения, как WPF, Windows Forms или консольные приложенияолжны руководствоваться простым паттерном Register Release Resolve, создавая толькдну диаграмму объектов для всего жизненного цикла приложения. Это означает, что наужно всего лишь высвободить диаграмму объектов после окончания жизненного циклриложения.
Несмотря на то, что мы можем высвободить экспортируемый компонент с помощьетода ReleaseExport, проще устранить сам контейнер, и при этом нам не придетсранить ссылку на экспортируемый компонент. После закрытия приложения контейнеже не нужен, поэтому мы можем соответствующим образом высвободить все частосредством уничтожения самого контейнера:
container.Dispose();
При устранении контейнера высвобождаются все части, при этом устраняются как
Singleton-, так и Transient-компоненты.
На этом наше путешествие по процессу управления жизненным циклом в MEF подходит онцу. Части можно компоновать из компонентов со смешанными стилямуществования, и это справедливо даже тогда, когда мы определяем нескольккспортируемых компонентов одной и той же абстракции. Мы еще не рассматривалроцесс работы с составными частями, поэтому давайте обратим наше внимание на этему.
609
15.3. Работа с составными компонентами
DI-контейнеры процветают благодаря их индивидуа льности, но их неопределенносторождает ряд трудностей. При использовании Constructor Injection единичныонструктор предпочтительнее перегружаемых конструкторов, поскольку в этом случасно, какой конструктор использовать в ситуации, когда у вас нет выбора. То же самоасается и преобразования абстракций к конкретным типам. Если мы пытаемсреобразовать конкретные составные типы к одной и той же абстракции, это приводит еопределенности.
Несмотря на столь нежелательну ю особенность как неопределенность, нам частриходится работать с составными реализациями единичного интерфейса. Это можероисходить в следующих ситуациях:
? Для разных потребителей должны использоваться разные специфичные типы
? Зависимости являются последовательнос тями
? Используются Decorator'ы
В этом разделе мы рассмотрим каждую из этих ситуаций и увидим, как MEF поочередправляется с каждой из них. После прочтения раздела вы должны будете уметь добавляттрибуты и успешно высвобождать части даже в тех ситуациях, когда в игру вступаюоставные реализации одной и той же абстракции.
Примечание
В этом разделе мы не обсуждаем процесс перехвата во время выполнения, поскольку MEF
не поддерживает этот механизм.
Иногда нам необходим более тщательный контроль, нежели тот, который предоставляееханизм автоматической интеграции. В следующем разделе описывается, как можнбеспечить более тщательный контроль при работе с MEF.
Выбор среди составных кандидатов
Автоматическая интеграция – удобный и мощный инструмент, но предоставляет наеньшие возможности контроля. Пока все абстракции преобразуются в конкретные типтдельно друг от друга, никаких трудностей не возникает, но как только мы вводиольшее количество реализаций для одного и того же интерфейса, возникаееопределенность.
Для начала мы должны повторить то, как MEF справляется с составнымкспортируемыми компонентами одной и той же абстракции.
Работа с составными реализациями одного и того же экспортируе мого компонента
Как вы уже видели в разделе 15.1.2 "Определение экспортируемых и импортируемылементов", можно создать составные части одного и того же экспорта:
[Export(typeof(IIngredient))]
public class SauceBearnaise : IIngredient { }
[Export(typeof(IIngredient))]
public class Steak : IIngredient { }
610
В этом примере и SauceBearnaise, и Steak определяются как экспортируемыомпоненты типа IIngredient. Однако в отличие от большинства остальных DI-
контейнеров в MEF не используется понятие компонента по умолчанию. Существует либдинственный экспортируемый компонент части, либо несколько компонентов. Это и еста мощность, которая проиллюстрирована в таблице 15-2. Если вы экспортируете и
SauceBearnaise, и Steak как IIngredient, то получаете составные экспортируемыомпоненты, а разрешить их вы можете только посредством импорта составныкземпляров.
При наличии двух экспортируемых компонентов попытка разрешить один экземпляр
IIngredient приводит к исключению:
var ingredient = container.GetExportedValue<IIngredient>();
В этом случае выдается исключение, поскольку существуют составные экспортируемыомпоненты IIngredient, и MEF отказывается отбирать только один из них. Это имееначение при рассмотрении ключевого сценария MEF: в сценариях расширяемостбычно мы будем получать экспортируемые компоненты из сборок, находящихся оотвествующей папке. Экспортируемые компоненты являются расширениями, поэтомо время проектирования мы еще не знаем, какие экспортируемые компоненты будут наоступны, если они вообще будут нам доступны. В таком контексте нет смысла отбиратолько один экспортируемый компонент, теряя при этом остальные. Мы должны либделать экспортируемые компоненты неопределенными каким-то другим способом, либолжны уметь справляться с множественност ью. Далее мы снова ненадолго вернемся опросу импорта составных компонентов, но сначала рассмотрим варианты наделеникспортируемых компонентов наибольшей индивидуальностью.
Один из способов сделать экспортируемый компонент более индивидуальным –
присвоить ему имя. Перегрузка конструктора атрибута [Export] позволяет присвоиткспортируемому компоненту имя:
[Export("sauce", typeof(IIngredient))]
public class SauceBearnaise : IIngredient { }
[Export("meat", typeof(IIngredient))]
public class Steak : IIngredient { }
В этом примере вместо двух частей, порождающих один и тот же экспортируемыомпонент (IIngredient), определяются два разных экспортируемых компонента: один иоторых экспортирует сочетание IIngredient и имени "sauce", а другой – сочетание
IIngredient и имени "meat". Теперь нет ни одного неименованного контракта
IIngredient.
Примечание
При экспорте только именованных типов отсутствуют экспортируемые компонентеименованного типа.
При попытке разрешить неименованный IIngredient будет выдаваться исключение:
var ingredient = container.GetExportedValue<IIngredient>();
611
Несмотря на то, что этот код приводит к выдаче исключения, оба именованныкспортируемых компонента можно разрешить, выполнив запрос конкретно этиомпонентов:
var meat = container.GetExportedValue<IIngredient>("meat");
var sauce = container.GetExportedValue<IIngredient>("sauce");
Явное разрешение именованного экспортируемого компонента с помощьоответствующей перегрузки GetExportedValue – хороший способ продемонстрироватьак разрешаются части, но если мы руководствуемся паттерном Register Release Resolveо нет необходимости запрашивать таким способом конкретный именованный компонент.
Подсказка
Если вы обнаружите, что вызываете метод GetExportedValue с конкретным именем илдентификатором, подумайте над тем, сможете ли вы сменить свой подход на менееопределенный.
Когда части определяются таким образом, чтобы сопоставляться с данным потребителемля осуществления выбора среди нескольких вариантов можно использоватменованные экспортируемые компоненты.
Импорт именованных экспортируемых компонентов
Иногда бывает необходимо переопределить обычное поведение для того, чтоббеспечить более разветвленный контроль над тем, куда какая зависимость отправляется.
Кроме того, возможны ситуации, при которых приходится сталкиваться еопределенным API. В качестве примера рассмотрим следующий конструктор:
public ThreeCourseMeal(ICourse entree,
ICourse mainCourse, ICourse dessert)
В этом примере присутствуют три одинаковым образом типизированных зависимостиаждая из которых является отдельной, не похожей на другие сущностью. В большинствлучаев вам необходимо, чтобы три, отличающихся друг от друга, экспортируемыомпонента заполнялись соответствующими параметрами. В следующем листингродемонстрировано, как можно отметить нужные классы, чтобы создатоответствующие экспортируемые компоненты.
Листинг 15-4: Определение именованных экспортируемых компонентов
[Export("entree", typeof(ICourse))]
public class Rillettes : ICourse { }
[Export("mainCourse", typeof(ICourse))]
public class CordonBleu : ICourse { }
[Export("dessert", typeof(ICourse))]
public class MousseAuChocolat : ICourse { }
Вы помечаете Rilettes экспортируемым компонентом под названием "entree", класс
CordonBleu – экспортируемым компонентом под названием "mainCourse", а
MousseAuChocolat – экспортируемым компонентом под названием "dessert".
612
Принимая во внимание эти экспортируемые компоненты, теперь вы можете следующибразом отметить конструктор класса ThreeCourseMeal соответствующими атрибутами
[Import]:
[ImportingConstructor]
public ThreeCourseMeal(
[Import("entree", typeof(ICourse))]ICourse entree,
[Import("mainCourse", typeof(ICourse))]ICourse mainCourse,
[Import("dessert", typeof(ICourse))]ICourse dessert)
Обратите внимание на то, что вы можете применить атрибут [Import] к аргументаонструктора. Обычно в тех случаях, когда конструктор уже отмечен атрибутом
[ImportingConstructor], вам не нужно явным образом применять атрибут [Import] ргументам конструктора. Но в этом примере вам необходимо отметить каждый параметтрибутом, чтобы они соответствовали разным именованным экспортируемыомпонентам. Поскольку в листинге 15-4 присутствуют соответствующикспортируемые компоненты, из этих частей вы теперь можете успешно разрешить класс
ThreeCourseMeal.
Подсказка
Если вы не можете (или не хотите) явным образом изменять классы, можете вместо ниоздать экспортирующие адаптеры.
Метаданные
Сопоставление импортируемых и экспортируемых компонентов с помощью именованныонтрактов – отличный способ справиться с неопределенно стью. Однако использованиаких жестко закодированных строк приводит к небезопасному рефакторингу. Можнопытаться исправить это, определив константы, которые мы будем использовать вместестко закодированных строк, но это не дает гарантии, что все разработчики будуомнить об использовании этих констант.
Еще один вариант – использовать такую возможность MEF, как метаданные. Этозможность позволяет определять пользовательские атрибуты экспортанкапсулирующие дополнительные метаданные, которые мы собираемся добавить кспортируемый компонент. Полноценная трактовка метаданных не будеассматриваться в этой книге, но если вы хотите узнать о них больше, обратитесь к статье
Глена Блока "Managed Extensibility Framework" в журанле "MSDN Magazine".
Чтобы избавиться от неопределенности, мы всегда можем сопоставить именованнымпортируемые компоненты со схожими именованными экспортируемымомпонентами, но лучшим решением будет сконструировать вышеупомяну тое API. Этриводит и к лучешму дизайну в целом.
В следующем разделе вы увидите, как можно использовать менее неопределенный и болеибкий подход, при котором разрешается использовать в обеде несколько блюд. Теперы должны изучить то, как MEF работает со списками и последовательно стями.
613
Интеграция последовательностей
В разделе 10.3.2 "Разработка пользовательского стиля существования" мы обсуждали, каыполнить рефакторинг явного класса ThreeCourseMeal к более универсальному классу
Meal, который обладает приведенным ниже конструктором:
public Meal(IEnumerable<ICourse> courses)
В этом разделе мы рассмотрим то, как можно сконфигурировать MEF, чтобы онтегрировал экземпляры Meal с соответствующими зависимостями ICourse. Послассмотрения этого вопроса вы должны будете приобрести хорошее понимание теозможностей, которые доступны в случае необходимости конфигурирования частеймеющих последовательности зависимостей.
Автоматическая инте грация последовательностей
Как мы уже говорили в разделах 15.1.2 "Определение экспортируемых и импортируемылементов" и 15.3.1 "Выбор среди составных кандидатов", в MEF используется такоонятие, как мощность. Это также означает, что MEF разбирается в составнымпортируемых и экспортируемых компонентах, но чтобы мы должны их явнпределять. В разделе 15.1.2 вы видели, как нужно применять атрибут
[ImportingConstructor], чтобы обеспечить возможность использования паттерна
Constructor Injection. Несмотря на то, что нужно применять к конструктору Meal атрибут
[ImportingConstructor], этого недостаточно. Такое поведение указывает MEF на то, чтонструктор Meal необходимо использовать для композиции, но при этом предполагаетсспользовать импортируемый компонент IEnumerable<ICourse>.
Экспортировать части ICourse можно так, как это продемонстрировано в листинге 15-4.
Однако поскольку теперь вы не хотите явно различать эти части, ни одной из них нрисваивается имя:
[Export(typeof(ICourse))]
public class Rillettes : ICourse { }
[Export(typeof(ICourse))]
public class CordonBleu : ICourse { }
[Export(typeof(ICourse))]
public class MousseAuChocolat : ICourse { }
Обратите внимание, что единственное отличие от листинга 15-4 заключается в том, что ндин из экспортируемых компонентов не имеет имени. Сейчас у вас имеются составныкспортируемые компоненты типа ICourse, но это, само по себе, еще не устраняеесоответствия между составными экспортируемыми компонентами ICourse динственным импортируемым компонентом IEnumerable<ICourse>. Последним шагоудет применение атрибута [ImportMany]:
[ImportingConstructor]
public Meal([ImportMany]IEnumerable<ICourse> courses)
Атрибут [ImportMany] используется для того, чтобы явно преобразовать составныкспортируемые компоненты в единственный оператор импорта последовательностей.
Экспортируемые компоненты могут браться из разных сборок, но при этом они будуомпоноваться в одну последовательность. При разрешении IMeal вы получаете
614
экземпляр Meal, имеющий три экспортируемых компонента ICourse: Rillettes,
CordonBleu и MousseAuChocolat.
С помощью атрибута [ImportMany] часть может импортировать последовательность всеоответствующих экспортируемых компонентов. Только когда нам нужно из большогабора экземпляров явно отобрать только несколько из них, нам необходимо выполнитольше действий. Рассмотрим, как это сделать.
Отбор нескольких экспортируе мых компонентов из большого набора
Когда мы имеем дело с множественностью экспортируемых компонентов, та стратегияоторая подразумевается под использованием атрибута [ImportMany], являетсорректной линией поведения. Это позволяет сопоставить импортеру все экспортируемыомпоненты необходимого контракта. Но, как показывает рисунок 15-5, возможнлучаи, когда из большого набора всех экспортируемых компонентов нам необходимтобрать только некоторые из них.
Рисунок 15-5: В ситуации, продемонстрированной слева, мы хотим явным образотобрать определенные зависимости из большого списка всех экспортируемыомпонентов. Это отличается от ситуации, приведенной справа, когда мы отбираем всез разбора.
Когда мы ранее позволяли MEF автоматически интегрировать все экспортируемыомпоненты, это соответствовало бы ситуации, изображенной в правой части рисунка 15-
5. Если нам нужно скомпоновать часть так, как изображено в левой части рисунка, то молжны явно определить, какие экспортируемые компоненты необходимо использовать.
Единственный способ это сделать – еще раз прибегнуть к именованным экспортируемыомпонентам. Однако выбранная нами стратегия немного отличается от используемой истинге 15-4, поскольку теперь для того, чтобы отметить все те экспортируемые
615
компоненты, которые необходимо импортировать в класс Meal, мы собираемсспользовать именованный атрибут экспорта. Как показано в следующем листинге, это нсключает экспорта других контрактов, а также контракта, лежащего в основовокупности компонентов.
Листинг 15-5: Отбор экспортируемых компонентов из набора
1. [Export(typeof(ICourse))]
2. [Export("meal", typeof(ICourse))]
3. public class Rillettes : ICourse { }
4. [Export(typeof(ICourse))]
5. public class LobsterBisque { }
6. [Export(typeof(ICourse))]
7. [Export("meal", typeof(ICourse))]
8. public class CordonBleu : ICourse { }
9. [Export(typeof(ICourse))]
10. [Export("meal", typeof(ICourse))]
11. public class MousseAuChocolat : ICourse { }
Строка 2, 7, 10: Искомые экспортируемые компоненты
Строка 1, 6, 9: Обычные атрибуты экспорта
Строка 4-5: Не выполняется отбор компонентов
Все три класса Rillettes, CordonBleu и MousseAuChocolat экспортируют контракт менем "meal". Этот именованный контракт можно использовать для импорта только теастей, которые экспортируют этот конкретный контракт. Однако для другиотребителей, которым могут понадобиться все экспортируемые компоненты ICoursезависимо от их имени, можно также экспортировать эти три класса как неименованныонтракт ICourse. К части можно добавлять сколько угодно атрибутов [Export].
Класс LobsterBisque экспортирует не именованный контракт meal, а толькеименованный контракт ICourse. Это означает, что те потребители, которые собираютсмпортировать все экспортируемые компоненты ICourse, могут сделать это с помощьтрибута [ImportMany] по умолчанию. Однако вы все равно можете установить, что частмпортирует только те части, которые явно экспортируют именованный контракт meal:
[ImportingConstructor]
public Meal(
[ImportMany("meal", typeof(ICourse))]
IEnumerable<ICourse> courses)
Вместо конструктора по умолчанию атрибута [ImportMany] можно использоватерегрузку конструктора, которая позволяет импортировать только именованныонтракт. Атрибут помечает параметр courses, что означает, что в последовательностourses будут отбираться только те части, которые экспортируют именованный контракeal. Благодаря экспортируемым компонентам из листинга 15-5 вы получите Mealодержащий Rillettes, CordonBleu и MousseAuChocolat, но без LobsterBisque.
Именованные экспортируемые компоненты можно использовать в качестве маркероаким образом, чтобы помеченные экспортируемые компоненты можно было выборочнтбирать в потребители. Поскольку можно использовать сколько угодно атрибутов
[Export], помечать экспортируемые компоненты можно для разных целей.
616
В обоих случаях, продемонстрированных на рисунке 15-5, атрибут [ImportMany] являетслючевым элементом, позволяющим импортировать множественные экспортируемыомпоненты в одного потребителя. Импорт последовательностей – хороший спосозбавиться от неопределенности, а используемые в MEF понятие мощности и явнытрибуты делают этот процесс более понятным.
Потребители, которые полагаются на последовательности зависимостей, могут бытамым интуитивно понятным применением составных экспортируемых компонентодной и той же абстракции. Но перед тем как мы полностью отойдем от данной темы, наеобходимо рассмотреть последний (и, возможно, слегка неожиданный) случай, когда ело вступают составные экземпляры.
Интеграция Decorator'ов
В разделе 9.1.2 "Паттерны и принципы механизма перехвата" мы обсуждали то, насколькаттерн проектирования Decorator полезен при реализации сквозных сущностей. Ппределению Decorator'ы представляют собой составные типы одной и той же абстракции.
У нас есть, по крайней мере, две реализации абстракции: сам Decorator и вложенный его тип. Если бы мы помещали Decorator'ы в стек, то у нас было бы еще большеализаций.
Это еще один пример составных экспортируемых компонентов одного и того жонтракта. В отличие от предыдущих разделов эти экспортируемые компоненты нвляются концептуально равносильными, а зависят друг от друга. В этом разделе я ввидите, как сконфигурировать части, чтобы они могли использовать этот паттерн. В
рамках MEF компоновать Decorator'ы можно несколькими способами, но поскольку всни похожи друг на друга, мы рассмотрим только один из них.
С оздание обертки с помощью конкретных контрактов
Рассмотрим проверенный класс Breading, который является Decorator'ом для
IIngredient. Для получения экземпляра, оберткой для которого он должен стать, класс
Breading использует паттерн Constructor Injection:
public Breading(IIngredient ingredient)
Чтобы получить Cotoletta, вам необходимо будет вложить VealCutlet (еще один
IIngredient) в класс Breading. Один из способов это сделать – связать VealCutlet лассом Breading, используя конкретный класс VealCutlet в качестве контракта:
[Export(typeof(VealCutlet))]
public class VealCutlet : IIngredient { }
Обратите внимание, что часть VealCutlet экспортирует не IIngredient, а тольконкретный тип, даже если она реализует интерфейс. Теперь конструктор Breading можевно утверждать, что он импортирует конкретный контракт VealCutlet:
[ImportingConstructor]
public Breading(
[Import(typeof(VealCutlet))]
IIngredient ingredient)
617
MEF сопоставляет экспортируемые и импортируемые компоненты, поэтому до тех порока отсутствует неопределенное сопоставление, композиция выполняется успешно.
VealCutlet реализует IIngredient, поэтому даже если в алгоритме сопоставления ачестве контракта используется конкретный тип, части все равно можно сравнивать.
Однако обратите внимание, что компилятор этого не гарантирует.
Примечание
Этот подход концептуально схож с подходом, описанным в разделе 14.3.3, где мспользовали Unity для компоновки Breading и VealCutlet через класс VealCutlet.
Примечание
Поскольку атрибут компилируется в класс, будет проще изменить конструктор Breadinаким образом, чтобы он принимал в качестве параметра VealCutlet, а не IIngredient.
По-моему, это хорошая демонстрация недостатков использования атрибутов длправления компоновкой.
Несмотря на то, что класс VealCutlet реализует IIngredient, он его не экспортирует. Этущественная составляющая этого подхода. Если бы VealCutlet экспортировал
IIngredient, то это приводило бы к неопределенности, поскольку Breading ужкспортирует интерфейс. Это приводило бы к несовпадению по мощности, потому что том случае имелось бы два экспортируемых компонента IIngredient, и, импортируя
IIngredient, вы не смогли бы разрешить Breading.
Предупреждение
Нельзя интегрировать Decorator'ы, если вложенный экспортируемый компонент должекспортировать и его абстракцию.
Части Breading и VealCutlet компонуются вместе, поскольку обладаюопоставляемыми контрактами. Точная форма контракта не так важна. В этом примере вспользовали конкретный тип вложенного класса, но могли бы использоватменованный контракт или, как в этом конкретном случае, любую явную строку. Важното соответствие между двумя частями является определенным.
MEF позволяет работать с составными экспортируемыми компонентами несколькимпособами. Мы можем конфигурировать их в виде альтернатив друг другу, в виде пировоторые разрешаются в виде последовательностей, или в виде иерархических Decorator'ов.
В любом случае мы должны явно указывать MEF на то, как сопоставлять экспортируемы импортируемые компоненты.
Кроме того, это может происходить в ситуации, когда нам нужно иметь дело с APIтклоняющимися от Constructor Injection. До настоящего момента вы наблюдали за темак компоновать части, включая то, как определять политики создания и как работать оставными экспортируемыми компонентами. Но до этого момента мы позволялонтейнеру подключать зависимости, явным образом предполагая, что все компонентспользуют Constructor Injection. Поскольку это не всегда происходит именно так, ледующем разделе мы сделаем краткий обзор того, как работать с классами, экземпляроторых должны создаваться особым образом.
618
15.4. Конфигурирование сложных API
До настоящего момента мы рассматривали то, как можно компоновать частиспользующие Constructor Injection. Одним из главных преимуществ Constructor Injectioвляется то, что DI-контейнеры могут с легкостью понимать, как компоновать и создаватсе классы диаграммы зависимостей. В MEF, с другой стороны, необходимо явнспользовать атрибут [ImportingConstructor], поэтому для MEF это не совсеправедливо.
В этом разделе вы увидите, как работать с простейшими аргументами конструкторататическими фабриками и Property Injection. Все это требует особого внимания. Начнем ассмотрения классов, конструкторы которых принимают в качестве параметроростейшие типы, например, строки и целые числа.
Конфигурирование простейших зависимостей
Пока мы внедряем абстракции в потребителей, все в порядке. Но данный процессложняется, если конструктор зависит от простейшего типа, например, строковогоислового или перечисляемого. Наиболее часто это случается в реализациях доступа анным, которые принимают в качестве параметра конструктора строку соединения. Но о же время это является более общей проблемой, касающейся всех строковых и числовыипов.
В сущности, регистрация строкового или числового типа в качестве контракта не имеесобого смысла. Что значит импортировать строку или число, если мы руководствуемсолько типом? Нужна ли нам любая строка? В основном нам нужна конкретная строкаапример, строка соединения. Такие же рассуждения можно применить и к простейшемначению, включая строки, числа и перечисления.
Рассмотрим в качестве примера приведенный ниже конструктор:
public ChiliConCarne(Spiciness spiciness)
В этом примере Spiciness имеет перечисляемый тип:
public enum Spiciness
{
Mild = 0,
Medium,
Hot
}
Предупреждение
Согласно эмпирическому правилу перечисления являются code smell'ами и их нужнреобразовывать в полиморфные классы (имеющие разное состояние). Тем не менее, дланного примера они вполне нам подходят.
Чтобы соответствующим образом пометить ChiliConCarne, вы добавляете к конструктортрибут [ImportingConstructor]. При экспорте Spiciness лучше всего сделать это омощью адаптера:
619
public class SpicinessAdapter
{
[Export]
public Spiciness Spiciness
{
get { return Spiciness.Hot; }
}
}
Этот адаптер экспортирует значение Spiciness.Hot таким образом, что, если вомпонуете ChiliConCarne из каталога, в котором содержатся эти части, то вы получиторячее Chili con Carne.
Подсказка
Вместо того чтобы экспортировать и импортировать сам тип Spiciness, можнспользовать пользовательску ю строку в качестве совместно используемого контракта.
Для этого потребуется добавить дополнительный атрибут [Import] в аргуменонструктора spiciness с целью определения контракта.
С помощью адаптеров и контрактов можно должным образом сопоставить простейшиипы и импортируемые компоненты. Такой подход можно использовать в ситуацияхогда все типы и конструкторы являются открытыми. А что нам делать с типами, оторых нет открытых конструкторов?
Компоновка частей без открытых конструкторов
Экземпляры некоторых классов нельзя создать с помощью открытого конструктора.
Вместо открытых конструкторов для создания экземпляров такого типа нам приходитсспользовать некоторого рода фабрику. Для DI-контейнеров это всегда проблематичнооскольку по умолчанию им нужны открытые конструкторы.
Рассмотрим приведенный ниже пример конструктора открытого класса JunkFood:
internal JunkFood(string name)
Даже если класс JunkFood является открытым, конструктор расположен внутри него.
Очевидно, экземпляры JunkFood должны создаваться с помощью статического класса
JunkFoodFactory:
public static class JunkFoodFactory
{
public static IMeal Create(string name)
{
return new JunkFood(name);
}
}
Предположим, что вы не можете изменить это API. Как вы тогда поступите в этоитуации, чтобы суметь должным образом сынтегрировать и скомпоновать JunkFood?
Ответ на этот вопрос точно такой же, как и для всех остальных случаев, когда вы ножете изменить первоначальный экспортированный тип: используйте адаптер подобному, как это продемонстрировано в следующем листинге.
620
Листинг 15-6: Экспорт типа, имеющего внутренний конструктоublic class JunkFoodAdapter
{
private readonly IMeal junk;
public JunkFoodAdapter()
{
this.junk = JunkFoodFactory.Create("chicken meal");
}
[Export]
public IMeal JunkFood
{
get { return this.junk; }
}
}
В JunkFoodAdapter инкапсулировано знание о том, что экземпляр JunkFood создается омощью метода JunkFoodFactory.Create. Этот метод создает экземпляр в конструктор импортирует его через свойство. Поскольку тип свойства – IMeal, то он также являетс экспортированным контрактом.
С помощью расположенного в каталоге класса JunkFoodAdapter вы можете успешназрешать IMeal и возвращать экземпляра блюда из курицы JunkFood.
Последним рассматриваемым нами отклонением от Constructor Injection является Property
Injection.
Интегрирование с помощью Property Injection
Property Injection – это менее определенная форма механизма внедрения зависимостейоскольку компилятор не принудает нас задавать значение свойства, доступного длаписи. По иронии MEF был задуман скорее как использующий паттерн Property Injection не Constructor Injection. Это объясняет тот факт, что нам не нужно явно применяттрибуты ко всему, что мы собираемся скомпоновать: с точки зрения MEF, паттерн
Property Injection (являющийся неопределенным) является используемым по умолчанию, а
Constructor Injection – менее идиоматичным вариантом.
Несмотря на то, что я считаю эту точку зрения одновременно и устаревшей, и невернойто все же позволяет без затруднений использовать в MEF паттерн Property Injection. Всето нам приходится делать, – применять к свойству атрибут [Import].
Рассмотрим класс CaesarSalad:
public class CaesarSalad : ICourse
{
public IIngredient Extra { get; set; }
}
По всеобщему заблуждению в состав салата "Цезарь" входит курица. По своей сути
"Цезарь" является салатом, но, поскольку с курицей он вкуснее, то ее часто предлагаюспользовать в нем в качестве дополнительного ингредиента. Класс CaesarSalaоделирует такую возможность посредством доступного для записи свойства поазванием Extra.
621
Чтобы разрешить использовать для CaesarSalad паттерн Property Injection, ваеобходимо просто применить атрибут [Import]:
[Import(AllowDefault = true)]
public IIngredient Extra { get; set; }
В этой книге я последовательно рассматриваю паттерн Property Injection, которырименяется в тех случаях, когда есть возможность передавать внешние зависимости. Этмеет смысл, поскольку компилятор не принуждает вас присваивать свойству значение (тличие от аргумента конструктора). Но MEF не придерживается этой точки зрения. Пмолчанию импорт должен выполняться, пока вы явно с помощью свойства AllowDefaulе укажете, что делать это необязательно. Чтобы продолжать соответствовать описанномыше паттерну Property Injection, свойству AllowDefault вы присваиваете значение true.
Это означает, что MEF не будет выдавать исключение, если не сможет импортировать
IIngredient.
Вы должны знать, что если свойство AllowDefault имеет значение true, то вместо тоготобы игнорировать свойство, когда импорт не может быть выполнен, MEF будет явныбразом присваивать свойству значение по умолчанию (в этом случае null). Чтобрименить эту возможность, вы должны быть готовы к работе с null-значениями, но этриведет к разрушению инвариантов класса. Вы должны использовать большие значениятобы избежать присваивания null-значений приватным полям.
Один из способов работы с null-значениями – молча поглотить такое значение:
1. [Import(AllowDefault = true)]
2. public IIngredient Extra
3. {
4. get { return this.extra; }
5. set
6. {
7. if (value == null)
8. {
9. return;
10. }
11. this.extra = value;
12. }
13. }
Строка 7-10: Молчаливое игнорирование null-значений
Вы можете явным образом проверить, имеет ли свойство значение null, и выйти, еслызывающий оператор пытается внедрить null-значение. Такое поведение приводит арушению принципа "наименьшего удивления" (Principle of Least Surprise), посколькызывающих операторов может удивить тот факт, что присваивание значения не даликакого результата, даже если при этом не выдавалось никакого исключения. И снова вришли к тому, что Property Injection – очень проблематичный паттерн, и лучше всегзбегать его использования, пока оно не будет оправданно.
Известно, что Property Injection характерен для MEF, но, как часто бывает, все зло кроетс деталях. Даже при работе с MEF я предпочитаю использовать Constructor Injection, моюбимый паттерн.
622
В этом разделе вы увидели, как можно использовать MEF для работы с более трудными
API разработки. Процесс применения Property Injection, а также всего остального, к чемы можем обратиться с помощью экспортируемых адаптеров, довольно прост. Такоодход всегда является универсальным решением, если все перестает работать, а мы ножем модифицировать части.
623
15.5. Резюме
Среди всех остальных DI-контейнеров, охваченных в части 4, MEF является самысобенным. Во-первых, это единственная технология компоновки, официальноставляемая и поддерживаемая компанией Microsoft. Во-вторых, MEF, ействительности, является не DI-контейнером, а фреймворком расширяемости (каидно из его названия Managed Extensibility Framework), поэтому рассматривать его с тоозиции, как если бы он был DI-контейнером, было бы не правильно.
Между MEF и другими DI-контейнерами столько схожих черт, что эта глава не тольквляется обоснованной, но и необходимой. Вы должны четко понимать, почему M EF нвляется DI-контейнером, чтобы принять правильное решение о том, когда его можнспользовать.
Эта глава продемонстрировала, что мы можем выдавить из MEF большую частункциональности обычного DI-контейнера, но при этом используя достаточнеудобные способы. Наиболее проблемая сторона MEF – зависимость от атрибутовотому что атрибуты сильно привязывают к типам такие вопросы, как жизненный цикл тбор импортируемых компонентов из совокупности компонентов. В сценарияасширяемости это не является проблемой, но в процессе компоновки полноценногриложения это ограничение приводит к возникновению трудностей.
В ситуациях, когда мы не можем или не хотим помечать типы атрибутами MEF, можем создавать адаптеры, которые импортируют и экспортируют соответствующиасти ради реальной реализации. Мы можем рассматривать такие адаптеры MEF ачестве конфигурационного API, но в отличие от большинства других строгипизированных свободных интерфейсов DI-контейнеров это API довольно громоздко.
Однако адаптер MEF – универсально используемая хитрость, которую можнспользовать, чтобы справиться с конкретными проблемами, возникающими в MEF.
Можно использовать адаптеры не только для компоновки не атрибутивных типов, накже для экспорта частей из методов фабрики и для много другого.
Имеет ли смысл использовать в приложениях MEF в качестве DI-контейнера? Ответ нтот вопрос зависит от обстоятельств. Одним из сильных аргументов в пользспользования MEF является тот факт, что MEF является частью .NET 4 и Silverlight 4оэтому если для приложения будут использоваться эти платформы, MEF в них уже будеоступен. Дело не только в удобстве применения. Для тех организаций, в которыогласно их внутренней политике должны использоваться только официальныехнологии компании Microsoft, использование MEF может стать больширеимуществом.
Поскольку MEF – это официальный продукт компании Microsoft, нам предоставляетсругой уровень поддержки, нежели тот, который мы получали при использовании других
DI-контейнеров. Нам предоставляется такая же поддержка, как и при использовании .NET
и Silverlight, при этом мы можем быть уверены, что в MEF не возникнет неполадок.
Однако эти преимущества могут не перевесить недостатки использования MEF в теолях, для которых она не была сконструирована. MEF был создан для сценариеасширяемости, поэтому имеет смысл использовать его в приложениях, в которыасширяемость является важной чертой. В таких приложениях, возможно, имеет смысл
624
расширить ответственность MEF до композиции всего приложения, поскольку этозможность уже используется.
Для приложений, в которых расширяемость не играет значительной роли, возможномеет смысл выбрать специально предназначенный для композиции объектов DI-
контейнер.
Неважно, какой DI-контейнер вы выбрали, или даже если вы предпочитаете Poor Man's DI надеюсь, что эта книга передала вам следующу ю мысль: механизм внедрениависимостей не основывается на какой-то конкретной технологии, например, нонкретном DI-контейнере. Приложения могут и должны создаваться с помощью DI-
дружественных паттернов и приемов, описанных в этой книге. Если мы в этом преуспелио огромное значение имеет выбор DI-контейнера. DI-контейнер – это инструментоторый компонует наше приложение, но в идеале мы должны уметь заменять одионтейнер на другой, не переписывая при этом другие части нашего приложения, кромак Composition Root.